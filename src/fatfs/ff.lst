  Thu May 20 2021 21:37                                                Page 1


                     ***************************************
                     **      WDC 65C816 Macro Assembler   **
                     **                                   **
                     **     Version 3.49.1- Feb  6 2006    **
                     ***************************************

     1                        ;:ts=8
     2             00000001   R0	equ	1
     3             00000005   R1	equ	5
     4             00000009   R2	equ	9
     5             0000000D   R3	equ	13
     6                        ;/*-----------------------------------------------
                    -----------------------------/
     7                        ;/  FatFs - Generic FAT Filesystem Module  R0.14b 
                                                 /
     8                        ;/------------------------------------------------
                    -----------------------------/
     9                        ;/
    10                        ;/ Copyright (C) 2021, ChaN, all right reserved.
    11                        ;/
    12                        ;/ FatFs module is an open source software. Redist
                    ribution and use of FatFs in
    13                        ;/ source and binary forms, with or without modifi
                    cation, are permitted provided
    14                        ;/ that the following condition is met:
    15                        ;/
    16                        ;/ 1. Redistributions of source code must retain t
                    he above copyright notice,
    17                        ;/    this condition and the following disclaimer.
    18                        ;/
    19                        ;/ This software is provided by the copyright hold
                    er and contributors "AS IS"
    20                        ;/ and any warranties related to this software are
                     DISCLAIMED.
    21                        ;/ The copyright owner or contributors be NOT LIAB
                    LE for any damages caused
    22                        ;/ by use of this software.
    23                        ;/
    24                        ;/------------------------------------------------
                    ----------------------------*/
    25                        ;
    26                        ;
    27                        ;#include <string.h>
    28                        ;#include "ff.h"			/* Declarations 
                    of FatFs API */
    29                        ;#include "diskio.h"		/* Declarations 
                    of device I/O functions */
    30                        ;
    31                        ;
    32                        ;/*-----------------------------------------------
                    ---------------------------
    33                        ;
    34                        ;   Module Private Definitions
    35                        ;
    36                        ;-------------------------------------------------
                    --------------------------*/
    37                        ;
    38                        ;#if FF_DEFINED != 86631	/* Revision ID */
  Thu May 20 2021 21:37                                                Page 2


    39                        ;#error Wrong include file (ff.h).
    40                        ;#endif
    41                        ;
    42                        ;
    43                        ;/* Limits and boundaries */
    44                        ;#define MAX_DIR		0x200000		
                    /* Max size of FAT directory */
    45                        ;#define MAX_DIR_EX	0x10000000		
                    /* Max size of exFAT directory */
    46                        ;#define MAX_FAT12	0xFF5			
                    /* Max FAT12 clusters (differs from specs, but right for rea
                    l DOS/Windows behavior) */
    47                        ;#define MAX_FAT16	0xFFF5			
                    /* Max FAT16 clusters (differs from specs, but right for rea
                    l DOS/Windows behavior) */
    48                        ;#define MAX_FAT32	0x0FFFFFF5		
                    /* Max FAT32 clusters (not specified, practical limit) */
    49                        ;#define MAX_EXFAT	0x7FFFFFFD		
                    /* Max exFAT clusters (differs from specs, implementation li
                    mit) */
    50                        ;
    51                        ;
    52                        ;/* Character code support macros */
    53                        ;#define IsUpper(c)		((c) >= 'A' && (
                    c) <= 'Z')
    54                        ;#define IsLower(c)		((c) >= 'a' && (
                    c) <= 'z')
    55                        ;#define IsDigit(c)		((c) >= '0' && (
                    c) <= '9')
    56                        ;#define IsSeparator(c)	((c) == '/' || (c) == '\
                    \')
    57                        ;#define IsTerminator(c)	((UINT)(c) < (FF_USE_LFN
                     ? ' ' : '!'))
    58                        ;#define IsSurrogate(c)	((c) >= 0xD800 && (c) <=
                     0xDFFF)
    59                        ;#define IsSurrogateH(c)	((c) >= 0xD800 && (c) <=
                     0xDBFF)
    60                        ;#define IsSurrogateL(c)	((c) >= 0xDC00 && (c) <=
                     0xDFFF)
    61                        ;
    62                        ;
    63                        ;/* Additional file access control and file status
                     flags for internal use */
    64                        ;#define FA_SEEKEND	0x20	/* Seek to end o
                    f the file on file open */
    65                        ;#define FA_MODIFIED	0x40	/* File has been
                     modified */
    66                        ;#define FA_DIRTY	0x80	/* FIL.buf[] needs to be
                     written-back */
    67                        ;
    68                        ;
    69                        ;/* Additional file attribute bits for internal us
                    e */
    70                        ;#define AM_VOL		0x08	/* Volume label 
                    */
    71                        ;#define AM_LFN		0x0F	/* LFN entry */
    72                        ;#define AM_MASK		0x3F	/* Mask of defin
                    ed bits in FAT */
  Thu May 20 2021 21:37                                                Page 3


    73                        ;#define AM_MASKX	0x37	/* Mask of defined bits 
                    in exFAT */
    74                        ;
    75                        ;
    76                        ;/* Name status flags in fn[11] */
    77                        ;#define NSFLAG		11		/* Index
                     of the name status byte */
    78                        ;#define NS_LOSS		0x01	/* Out of 8.3 fo
                    rmat */
    79                        ;#define NS_LFN		0x02	/* Force to crea
                    te LFN entry */
    80                        ;#define NS_LAST		0x04	/* Last segment 
                    */
    81                        ;#define NS_BODY		0x08	/* Lower case fl
                    ag (body) */
    82                        ;#define NS_EXT		0x10	/* Lower case fl
                    ag (ext) */
    83                        ;#define NS_DOT		0x20	/* Dot entry */
    84                        ;#define NS_NOLFN	0x40	/* Do not find LFN */
    85                        ;#define NS_NONAME	0x80	/* Not followed 
                    */
    86                        ;
    87                        ;
    88                        ;/* exFAT directory entry types */
    89                        ;#define	ET_BITMAP	0x81	/* Allocation bi
                    tmap */
    90                        ;#define	ET_UPCASE	0x82	/* Up-case table
                     */
    91                        ;#define	ET_VLABEL	0x83	/* Volume label 
                    */
    92                        ;#define	ET_FILEDIR	0x85	/* File and dire
                    ctory */
    93                        ;#define	ET_STREAM	0xC0	/* Stream extens
                    ion */
    94                        ;#define	ET_FILENAME	0xC1	/* Name extensio
                    n */
    95                        ;
    96                        ;
    97                        ;/* FatFs refers the FAT structure as simple byte 
                    array instead of structure member
    98                        ;/ because the C structure is not binary compatibl
                    e between different platforms */
    99                        ;
   100                        ;#define BS_JmpBoot			0	
                    	/* x86 jump instruction (3-byte) */
   101                        ;#define BS_OEMName			3	
                    	/* OEM name (8-byte) */
   102                        ;#define BPB_BytsPerSec		11		
                    /* Sector size [byte] (WORD) */
   103                        ;#define BPB_SecPerClus		13		
                    /* Cluster size [sector] (BYTE) */
   104                        ;#define BPB_RsvdSecCnt		14		
                    /* Size of reserved area [sector] (WORD) */
   105                        ;#define BPB_NumFATs			16	
                    	/* Number of FATs (BYTE) */
   106                        ;#define BPB_RootEntCnt		17		
                    /* Size of root directory area for FAT [entry] (WORD) */
   107                        ;#define BPB_TotSec16		19		
  Thu May 20 2021 21:37                                                Page 4


                    /* Volume size (16-bit) [sector] (WORD) */
   108                        ;#define BPB_Media			21	
                    	/* Media descriptor byte (BYTE) */
   109                        ;#define BPB_FATSz16			22	
                    	/* FAT size (16-bit) [sector] (WORD) */
   110                        ;#define BPB_SecPerTrk		24		
                    /* Number of sectors per track for int13h [sector] (WORD) */
   111                        ;#define BPB_NumHeads		26		
                    /* Number of heads for int13h (WORD) */
   112                        ;#define BPB_HiddSec			28	
                    	/* Volume offset from top of the drive (DWORD) */
   113                        ;#define BPB_TotSec32		32		
                    /* Volume size (32-bit) [sector] (DWORD) */
   114                        ;#define BS_DrvNum			36	
                    	/* Physical drive number for int13h (BYTE) */
   115                        ;#define BS_NTres			37		
                    /* WindowsNT error flag (BYTE) */
   116                        ;#define BS_BootSig			38	
                    	/* Extended boot signature (BYTE) */
   117                        ;#define BS_VolID			39		
                    /* Volume serial number (DWORD) */
   118                        ;#define BS_VolLab			43	
                    	/* Volume label string (8-byte) */
   119                        ;#define BS_FilSysType		54		
                    /* Filesystem type string (8-byte) */
   120                        ;#define BS_BootCode			62	
                    	/* Boot code (448-byte) */
   121                        ;#define BS_55AA				510	
                    	/* Signature word (WORD) */
   122                        ;
   123                        ;#define BPB_FATSz32			36	
                    	/* FAT32: FAT size [sector] (DWORD) */
   124                        ;#define BPB_ExtFlags32		40		
                    /* FAT32: Extended flags (WORD) */
   125                        ;#define BPB_FSVer32			42	
                    	/* FAT32: Filesystem version (WORD) */
   126                        ;#define BPB_RootClus32		44		
                    /* FAT32: Root directory cluster (DWORD) */
   127                        ;#define BPB_FSInfo32		48		
                    /* FAT32: Offset of FSINFO sector (WORD) */
   128                        ;#define BPB_BkBootSec32		50		
                    /* FAT32: Offset of backup boot sector (WORD) */
   129                        ;#define BS_DrvNum32			64	
                    	/* FAT32: Physical drive number for int13h (BYTE) */
   130                        ;#define BS_NTres32			65	
                    	/* FAT32: Error flag (BYTE) */
   131                        ;#define BS_BootSig32		66		
                    /* FAT32: Extended boot signature (BYTE) */
   132                        ;#define BS_VolID32			67	
                    	/* FAT32: Volume serial number (DWORD) */
   133                        ;#define BS_VolLab32			71	
                    	/* FAT32: Volume label string (8-byte) */
   134                        ;#define BS_FilSysType32		82		
                    /* FAT32: Filesystem type string (8-byte) */
   135                        ;#define BS_BootCode32		90		
                    /* FAT32: Boot code (420-byte) */
   136                        ;
   137                        ;#define BPB_ZeroedEx		11		
  Thu May 20 2021 21:37                                                Page 5


                    /* exFAT: MBZ field (53-byte) */
   138                        ;#define BPB_VolOfsEx		64		
                    /* exFAT: Volume offset from top of the drive [sector] (QWOR
                    D) */
   139                        ;#define BPB_TotSecEx		72		
                    /* exFAT: Volume size [sector] (QWORD) */
   140                        ;#define BPB_FatOfsEx		80		
                    /* exFAT: FAT offset from top of the volume [sector] (DWORD)
                     */
   141                        ;#define BPB_FatSzEx			84	
                    	/* exFAT: FAT size [sector] (DWORD) */
   142                        ;#define BPB_DataOfsEx		88		
                    /* exFAT: Data offset from top of the volume [sector] (DWORD
                    ) */
   143                        ;#define BPB_NumClusEx		92		
                    /* exFAT: Number of clusters (DWORD) */
   144                        ;#define BPB_RootClusEx		96		
                    /* exFAT: Root directory start cluster (DWORD) */
   145                        ;#define BPB_VolIDEx			100	
                    	/* exFAT: Volume serial number (DWORD) */
   146                        ;#define BPB_FSVerEx			104	
                    	/* exFAT: Filesystem version (WORD) */
   147                        ;#define BPB_VolFlagEx		106		
                    /* exFAT: Volume flags (WORD) */
   148                        ;#define BPB_BytsPerSecEx	108		/* exFAT
                    : Log2 of sector size in unit of byte (BYTE) */
   149                        ;#define BPB_SecPerClusEx	109		/* exFAT
                    : Log2 of cluster size in unit of sector (BYTE) */
   150                        ;#define BPB_NumFATsEx		110		
                    /* exFAT: Number of FATs (BYTE) */
   151                        ;#define BPB_DrvNumEx		111		
                    /* exFAT: Physical drive number for int13h (BYTE) */
   152                        ;#define BPB_PercInUseEx		112		
                    /* exFAT: Percent in use (BYTE) */
   153                        ;#define BPB_RsvdEx			113	
                    	/* exFAT: Reserved (7-byte) */
   154                        ;#define BS_BootCodeEx		120		
                    /* exFAT: Boot code (390-byte) */
   155                        ;
   156                        ;#define DIR_Name			0		
                    /* Short file name (11-byte) */
   157                        ;#define DIR_Attr			11		
                    /* Attribute (BYTE) */
   158                        ;#define DIR_NTres			12	
                    	/* Lower case flag (BYTE) */
   159                        ;#define DIR_CrtTime10		13		
                    /* Created time sub-second (BYTE) */
   160                        ;#define DIR_CrtTime			14	
                    	/* Created time (DWORD) */
   161                        ;#define DIR_LstAccDate		18		
                    /* Last accessed date (WORD) */
   162                        ;#define DIR_FstClusHI		20		
                    /* Higher 16-bit of first cluster (WORD) */
   163                        ;#define DIR_ModTime			22	
                    	/* Modified time (DWORD) */
   164                        ;#define DIR_FstClusLO		26		
                    /* Lower 16-bit of first cluster (WORD) */
   165                        ;#define DIR_FileSize		28		
  Thu May 20 2021 21:37                                                Page 6


                    /* File size (DWORD) */
   166                        ;#define LDIR_Ord			0		
                    /* LFN: LFN order and LLE flag (BYTE) */
   167                        ;#define LDIR_Attr			11	
                    	/* LFN: LFN attribute (BYTE) */
   168                        ;#define LDIR_Type			12	
                    	/* LFN: Entry type (BYTE) */
   169                        ;#define LDIR_Chksum			13	
                    	/* LFN: Checksum of the SFN (BYTE) */
   170                        ;#define LDIR_FstClusLO		26		
                    /* LFN: MBZ field (WORD) */
   171                        ;#define XDIR_Type			0	
                    	/* exFAT: Type of exFAT directory entry (BYTE) */
   172                        ;#define XDIR_NumLabel		1		
                    /* exFAT: Number of volume label characters (BYTE) */
   173                        ;#define XDIR_Label			2	
                    	/* exFAT: Volume label (11-WORD) */
   174                        ;#define XDIR_CaseSum		4		
                    /* exFAT: Sum of case conversion table (DWORD) */
   175                        ;#define XDIR_NumSec			1	
                    	/* exFAT: Number of secondary entries (BYTE) */
   176                        ;#define XDIR_SetSum			2	
                    	/* exFAT: Sum of the set of directory entries (WORD) */
   177                        ;#define XDIR_Attr			4	
                    	/* exFAT: File attribute (WORD) */
   178                        ;#define XDIR_CrtTime		8		
                    /* exFAT: Created time (DWORD) */
   179                        ;#define XDIR_ModTime		12		
                    /* exFAT: Modified time (DWORD) */
   180                        ;#define XDIR_AccTime		16		
                    /* exFAT: Last accessed time (DWORD) */
   181                        ;#define XDIR_CrtTime10		20		
                    /* exFAT: Created time subsecond (BYTE) */
   182                        ;#define XDIR_ModTime10		21		
                    /* exFAT: Modified time subsecond (BYTE) */
   183                        ;#define XDIR_CrtTZ			22	
                    	/* exFAT: Created timezone (BYTE) */
   184                        ;#define XDIR_ModTZ			23	
                    	/* exFAT: Modified timezone (BYTE) */
   185                        ;#define XDIR_AccTZ			24	
                    	/* exFAT: Last accessed timezone (BYTE) */
   186                        ;#define XDIR_GenFlags		33		
                    /* exFAT: General secondary flags (BYTE) */
   187                        ;#define XDIR_NumName		35		
                    /* exFAT: Number of file name characters (BYTE) */
   188                        ;#define XDIR_NameHash		36		
                    /* exFAT: Hash of file name (WORD) */
   189                        ;#define XDIR_ValidFileSize	40		
                    /* exFAT: Valid file size (QWORD) */
   190                        ;#define XDIR_FstClus		52		
                    /* exFAT: First cluster of the file data (DWORD) */
   191                        ;#define XDIR_FileSize		56		
                    /* exFAT: File/Directory size (QWORD) */
   192                        ;
   193                        ;#define SZDIRE				32	
                    	/* Size of a directory entry */
   194                        ;#define DDEM				0xE5	
                    /* Deleted directory entry mark set to DIR_Name[0] */
  Thu May 20 2021 21:37                                                Page 7


   195                        ;#define RDDEM				0x05	
                    /* Replacement of the character collides with DDEM */
   196                        ;#define LLEF				0x40	
                    /* Last long entry flag in LDIR_Ord */
   197                        ;
   198                        ;#define FSI_LeadSig			0	
                    	/* FAT32 FSI: Leading signature (DWORD) */
   199                        ;#define FSI_StrucSig		484		
                    /* FAT32 FSI: Structure signature (DWORD) */
   200                        ;#define FSI_Free_Count		488		
                    /* FAT32 FSI: Number of free clusters (DWORD) */
   201                        ;#define FSI_Nxt_Free		492		
                    /* FAT32 FSI: Last allocated cluster (DWORD) */
   202                        ;
   203                        ;#define MBR_Table			446	
                    	/* MBR: Offset of partition table in the MBR */
   204                        ;#define SZ_PTE				16	
                    	/* MBR: Size of a partition table entry */
   205                        ;#define PTE_Boot			0		
                    /* MBR PTE: Boot indicator */
   206                        ;#define PTE_StHead			1	
                    	/* MBR PTE: Start head */
   207                        ;#define PTE_StSec			2	
                    	/* MBR PTE: Start sector */
   208                        ;#define PTE_StCyl			3	
                    	/* MBR PTE: Start cylinder */
   209                        ;#define PTE_System			4	
                    	/* MBR PTE: System ID */
   210                        ;#define PTE_EdHead			5	
                    	/* MBR PTE: End head */
   211                        ;#define PTE_EdSec			6	
                    	/* MBR PTE: End sector */
   212                        ;#define PTE_EdCyl			7	
                    	/* MBR PTE: End cylinder */
   213                        ;#define PTE_StLba			8	
                    	/* MBR PTE: Start in LBA */
   214                        ;#define PTE_SizLba			12	
                    	/* MBR PTE: Size in LBA */
   215                        ;
   216                        ;#define GPTH_Sign			0	
                    	/* GPT: Header signature (8-byte) */
   217                        ;#define GPTH_Rev			8		
                    /* GPT: Revision (DWORD) */
   218                        ;#define GPTH_Size			12	
                    	/* GPT: Header size (DWORD) */
   219                        ;#define GPTH_Bcc			16		
                    /* GPT: Header BCC (DWORD) */
   220                        ;#define GPTH_CurLba			24	
                    	/* GPT: Main header LBA (QWORD) */
   221                        ;#define GPTH_BakLba			32	
                    	/* GPT: Backup header LBA (QWORD) */
   222                        ;#define GPTH_FstLba			40	
                    	/* GPT: First LBA for partitions (QWORD) */
   223                        ;#define GPTH_LstLba			48	
                    	/* GPT: Last LBA for partitions (QWORD) */
   224                        ;#define GPTH_DskGuid		56		
                    /* GPT: Disk GUID (16-byte) */
   225                        ;#define GPTH_PtOfs			72	
  Thu May 20 2021 21:37                                                Page 8


                    	/* GPT: Partation table LBA (QWORD) */
   226                        ;#define GPTH_PtNum			80	
                    	/* GPT: Number of table entries (DWORD) */
   227                        ;#define GPTH_PteSize		84		
                    /* GPT: Size of table entry (DWORD) */
   228                        ;#define GPTH_PtBcc			88	
                    	/* GPT: Partation table BCC (DWORD) */
   229                        ;#define SZ_GPTE				128	
                    	/* GPT: Size of partition table entry */
   230                        ;#define GPTE_PtGuid			0	
                    	/* GPT PTE: Partition type GUID (16-byte) */
   231                        ;#define GPTE_UpGuid			16	
                    	/* GPT PTE: Partition unique GUID (16-byte) */
   232                        ;#define GPTE_FstLba			32	
                    	/* GPT PTE: First LBA (QWORD) */
   233                        ;#define GPTE_LstLba			40	
                    	/* GPT PTE: Last LBA inclusive (QWORD) */
   234                        ;#define GPTE_Flags			48	
                    	/* GPT PTE: Flags (QWORD) */
   235                        ;#define GPTE_Name			56	
                    	/* GPT PTE: Name */
   236                        ;
   237                        ;
   238                        ;/* Post process on fatal error in the file operat
                    ions */
   239                        ;#define ABORT(fs, res)		{ fp->err = (BYT
                    E)(res); LEAVE_FF(fs, res); }
   240                        ;
   241                        ;
   242                        ;/* Re-entrancy related */
   243                        ;#if FF_FS_REENTRANT
   244                        ;#if FF_USE_LFN == 1
   245                        ;#error Static LFN work area cannot be used in thr
                    ead-safe configuration
   246                        ;#endif
   247                        ;#define LEAVE_FF(fs, res)	{ unlock_fs(fs, 
                    res); return res; }
   248                        ;#else
   249                        ;#define LEAVE_FF(fs, res)	return res
   250                        ;#endif
   251                        ;
   252                        ;
   253                        ;/* Definitions of logical drive - physical locati
                    on conversion */
   254                        ;#if FF_MULTI_PARTITION
   255                        ;#define LD2PD(vol) VolToPart[vol].pd	/* Get p
                    hysical drive number */
   256                        ;#define LD2PT(vol) VolToPart[vol].pt	/* Get p
                    artition number (0:auto search, 1..:forced partition number)
                     */
   257                        ;#else
   258                        ;#define LD2PD(vol) (BYTE)(vol)	/* Each logical 
                    drive is associated with the same physical drive number */
   259                        ;#define LD2PT(vol) 0			/* Auto 
                    partition search */
   260                        ;#endif
   261                        ;
   262                        ;
  Thu May 20 2021 21:37                                                Page 9


   263                        ;/* Definitions of sector size */
   264                        ;#if (FF_MAX_SS < FF_MIN_SS) || (FF_MAX_SS != 512 
                    && FF_MAX_SS != 1024 && FF_MAX_SS != 2048 && FF_MAX_SS != 40
                    96) || (FF_MIN_SS != 512 && FF_MIN_SS != 1024 && FF_MIN_SS !
                    = 2048 && FF_MIN_SS != 4096)
   265                        ;#error Wrong sector size configuration
   266                        ;#endif
   267                        ;#if FF_MAX_SS == FF_MIN_SS
   268                        ;#define SS(fs)	((UINT)FF_MAX_SS)	/* Fixed
                     sector size */
   269                        ;#else
   270                        ;#define SS(fs)	((fs)->ssize)	/* Variable sect
                    or size */
   271                        ;#endif
   272                        ;
   273                        ;
   274                        ;/* Timestamp */
   275                        ;#if FF_FS_NORTC == 1
   276                        ;#if FF_NORTC_YEAR < 1980 || FF_NORTC_YEAR > 2107 
                    || FF_NORTC_MON < 1 || FF_NORTC_MON > 12 || FF_NORTC_MDAY < 
                    1 || FF_NORTC_MDAY > 31
   277                        ;#error Invalid FF_FS_NORTC settings
   278                        ;#endif
   279                        ;#define GET_FATTIME()	((DWORD)(FF_NORTC_YEAR -
                     1980) << 25 | (DWORD)FF_NORTC_MON << 21 | (DWORD)FF_NORTC_M
                    DAY << 16)
   280                        ;#else
   281                        ;#define GET_FATTIME()	get_fattime()
   282                        ;#endif
   283                        ;
   284                        ;
   285                        ;/* File lock controls */
   286                        ;#if FF_FS_LOCK != 0
   287                        ;#if FF_FS_READONLY
   288                        ;#error FF_FS_LOCK must be 0 at read-only configur
                    ation
   289                        ;#endif
   290                        ;typedef struct {
   291                        ;	FATFS *fs;		/* Object ID 1, volume (
                    NULL:blank entry) */
   292                        ;	DWORD clu;		/* Object ID 2, containi
                    ng directory (0:root) */
   293                        ;	DWORD ofs;		/* Object ID 3, offset i
                    n the directory */
   294                        ;	WORD ctr;		/* Object open counter, 
                    0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
   295                        ;} FILESEM;
   296                        ;#endif
   297                        ;
   298                        ;
   299                        ;/* SBCS up-case tables (\x80-\xFF) */
   300                        ;#define TBL_CT437  {0x80,0x9A,0x45,0x41,0x8E,0x41
                    ,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
   301                        ;					0x90,0x92,0x92,0
                    x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   302                        ;					0x41,0x49,0x4F,0
                    x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
  Thu May 20 2021 21:37                                                Page 10


                    xAF, \
   303                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   304                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   305                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   306                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   307                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   308                        ;#define TBL_CT720  {0x80,0x81,0x82,0x83,0x84,0x85
                    ,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
   309                        ;					0x90,0x91,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   310                        ;					0xA0,0xA1,0xA2,0
                    xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   311                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   312                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   313                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   314                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   315                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   316                        ;#define TBL_CT737  {0x80,0x81,0x82,0x83,0x84,0x85
                    ,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
   317                        ;					0x90,0x92,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0
                    x87, \
   318                        ;					0x88,0x89,0x8A,0
                    x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0
                    x96, \
   319                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   320                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   321                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   322                        ;					0x97,0xEA,0xEB,0
                    xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0
  Thu May 20 2021 21:37                                                Page 11


                    xEF, \
   323                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   324                        ;#define TBL_CT771  {0x80,0x81,0x82,0x83,0x84,0x85
                    ,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
   325                        ;					0x90,0x91,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   326                        ;					0x80,0x81,0x82,0
                    x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0
                    x8F, \
   327                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   328                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   329                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0
                    xDE, \
   330                        ;					0x90,0x91,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   331                        ;					0xF0,0xF0,0xF2,0
                    xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0
                    xFF}
   332                        ;#define TBL_CT775  {0x80,0x9A,0x91,0xA0,0x8E,0x95
                    ,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
   333                        ;					0x90,0x92,0x92,0
                    xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0
                    x9F, \
   334                        ;					0xA0,0xA1,0xE0,0
                    xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   335                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   336                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   337                        ;					0xB5,0xB6,0xB7,0
                    xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   338                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0
                    xEF, \
   339                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   340                        ;#define TBL_CT850  {0x43,0x55,0x45,0x41,0x41,0x41
                    ,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
   341                        ;					0x45,0x92,0x92,0
                    x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0
                    x9F, \
   342                        ;					0x41,0x49,0x4F,0
                    x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
  Thu May 20 2021 21:37                                                Page 12


   343                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   344                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   345                        ;					0xD1,0xD1,0x45,0
                    x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0
                    xDF, \
   346                        ;					0x4F,0xE1,0x4F,0
                    x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0
                    xEF, \
   347                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   348                        ;#define TBL_CT852  {0x80,0x9A,0x90,0xB6,0x8E,0xDE
                    ,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
   349                        ;					0x90,0x91,0x91,0
                    xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0
                    xAC, \
   350                        ;					0xB5,0xD6,0xE0,0
                    xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0
                    xAF, \
   351                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0
                    xBF, \
   352                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   353                        ;					0xD1,0xD1,0xD2,0
                    xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   354                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0
                    xEF, \
   355                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0
                    xFF}
   356                        ;#define TBL_CT855  {0x81,0x81,0x83,0x83,0x85,0x85
                    ,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
   357                        ;					0x91,0x91,0x93,0
                    x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0
                    x9F, \
   358                        ;					0xA1,0xA1,0xA3,0
                    xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0
                    xAF, \
   359                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0
                    xBF, \
   360                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   361                        ;					0xD1,0xD1,0xD3,0
                    xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0
                    xDF, \
   362                        ;					0xE0,0xE2,0xE2,0
                    xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0
                    xEF, \
  Thu May 20 2021 21:37                                                Page 13


   363                        ;					0xF0,0xF2,0xF2,0
                    xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0
                    xFF}
   364                        ;#define TBL_CT857  {0x80,0x9A,0x90,0xB6,0x8E,0xB7
                    ,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
   365                        ;					0x90,0x92,0x92,0
                    xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0
                    x9E, \
   366                        ;					0xB5,0xD6,0xE0,0
                    xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   367                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   368                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   369                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   370                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0
                    xEF, \
   371                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   372                        ;#define TBL_CT860  {0x80,0x9A,0x90,0x8F,0x8E,0x91
                    ,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
   373                        ;					0x90,0x91,0x92,0
                    x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   374                        ;					0x86,0x8B,0x9F,0
                    x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   375                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   376                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   377                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   378                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   379                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   380                        ;#define TBL_CT861  {0x80,0x9A,0x90,0x41,0x8E,0x41
                    ,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
   381                        ;					0x90,0x92,0x92,0
                    x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0
                    x9F, \
   382                        ;					0xA4,0xA5,0xA6,0
                    xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   383                        ;					0xB0,0xB1,0xB2,0
  Thu May 20 2021 21:37                                                Page 14


                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   384                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   385                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   386                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   387                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   388                        ;#define TBL_CT862  {0x80,0x81,0x82,0x83,0x84,0x85
                    ,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
   389                        ;					0x90,0x91,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   390                        ;					0x41,0x49,0x4F,0
                    x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   391                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   392                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   393                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   394                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   395                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   396                        ;#define TBL_CT863  {0x43,0x55,0x45,0x41,0x41,0x41
                    ,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
   397                        ;					0x45,0x45,0x45,0
                    x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0
                    x9F, \
   398                        ;					0xA0,0xA1,0x4F,0
                    x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   399                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   400                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   401                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   402                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   403                        ;					0xF0,0xF1,0xF2,0
  Thu May 20 2021 21:37                                                Page 15


                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   404                        ;#define TBL_CT864  {0x80,0x9A,0x45,0x41,0x8E,0x41
                    ,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
   405                        ;					0x90,0x92,0x92,0
                    x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   406                        ;					0x41,0x49,0x4F,0
                    x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   407                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   408                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   409                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   410                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   411                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   412                        ;#define TBL_CT865  {0x80,0x9A,0x90,0x41,0x8E,0x41
                    ,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
   413                        ;					0x90,0x92,0x92,0
                    x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   414                        ;					0x41,0x49,0x4F,0
                    x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   415                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   416                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   417                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   418                        ;					0xE0,0xE1,0xE2,0
                    xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0
                    xEF, \
   419                        ;					0xF0,0xF1,0xF2,0
                    xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   420                        ;#define TBL_CT866  {0x80,0x81,0x82,0x83,0x84,0x85
                    ,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
   421                        ;					0x90,0x91,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   422                        ;					0x80,0x81,0x82,0
                    x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0
                    x8F, \
   423                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
  Thu May 20 2021 21:37                                                Page 16


                    xBF, \
   424                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   425                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0
                    xDF, \
   426                        ;					0x90,0x91,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0
                    x9F, \
   427                        ;					0xF0,0xF0,0xF2,0
                    xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0
                    xFF}
   428                        ;#define TBL_CT869  {0x80,0x81,0x82,0x83,0x84,0x85
                    ,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
   429                        ;					0x90,0x91,0x92,0
                    x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0
                    x90, \
   430                        ;					0x91,0x90,0x92,0
                    x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0
                    xAF, \
   431                        ;					0xB0,0xB1,0xB2,0
                    xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0
                    xBF, \
   432                        ;					0xC0,0xC1,0xC2,0
                    xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0
                    xCF, \
   433                        ;					0xD0,0xD1,0xD2,0
                    xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0
                    xDF, \
   434                        ;					0xA9,0xAA,0xAC,0
                    xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0
                    xEF, \
   435                        ;					0xF0,0xF1,0xD1,0
                    xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0
                    xFF}
   436                        ;
   437                        ;
   438                        ;/* DBCS code range |----- 1st byte -----|  |-----
                    ------ 2nd byte -----------| */
   439                        ;/*                  <------>    <------>    <----
                    -->    <------>    <------>  */
   440                        ;#define TBL_DC932 {0x81, 0x9F, 0xE0, 0xFC, 0x40, 
                    0x7E, 0x80, 0xFC, 0x00, 0x00}
   441                        ;#define TBL_DC936 {0x81, 0xFE, 0x00, 0x00, 0x40, 
                    0x7E, 0x80, 0xFE, 0x00, 0x00}
   442                        ;#define TBL_DC949 {0x81, 0xFE, 0x00, 0x00, 0x41, 
                    0x5A, 0x61, 0x7A, 0x81, 0xFE}
   443                        ;#define TBL_DC950 {0x81, 0xFE, 0x00, 0x00, 0x40, 
                    0x7E, 0xA1, 0xFE, 0x00, 0x00}
   444                        ;
   445                        ;
   446                        ;/* Macros for table definitions */
   447                        ;#define MERGE_2STR(a, b) a ## b
   448                        ;#define MKCVTBL(hd, cp) MERGE_2STR(hd, cp)
   449                        ;
   450                        ;
   451                        ;
  Thu May 20 2021 21:37                                                Page 17


   452                        ;
   453                        ;/*-----------------------------------------------
                    ---------------------------
   454                        ;
   455                        ;   Module Private Work Area
   456                        ;
   457                        ;-------------------------------------------------
                    --------------------------*/
   458                        ;/* Remark: Variables defined here without initial
                     value shall be guaranteed
   459                        ;/  zero/null at start-up. If not, the linker opti
                    on or start-up routine is
   460                        ;/  not compliance with C standard. */
   461                        ;
   462                        ;/*--------------------------------*/
   463                        ;/* File/Volume controls           */
   464                        ;/*--------------------------------*/
   465                        ;
   466                        ;#if FF_VOLUMES < 1 || FF_VOLUMES > 10
   467                        ;#error Wrong FF_VOLUMES setting
   468                        ;#endif
   469                        ;static FATFS* FatFs[FF_VOLUMES];	/* Pointer to th
                    e filesystem objects (logical drives) */
   470                        ;static WORD Fsid;				
                    	/* Filesystem mount ID */
   471                        ;
   472                        ;#if FF_FS_RPATH != 0
   473                        ;static BYTE CurrVol;				
                    /* Current drive */
   474                        ;#endif
   475                        ;
   476                        ;#if FF_FS_LOCK != 0
   477                        ;static FILESEM Files[FF_FS_LOCK];	/* Open 
                    object lock semaphores */
   478                        ;#endif
   479                        ;
   480                        ;#if FF_STR_VOLUME_ID
   481                        ;#ifdef FF_VOLUME_STRS
   482                        ;static const char* const VolumeStr[FF_VOLUMES] = 
                    {FF_VOLUME_STRS};	/* Pre-defined volume ID */
   483                        ;#endif
   484                        ;#endif
   485                        ;
   486                        ;#if FF_LBA64
   487                        ;#if FF_MIN_GPT > 0x100000000
   488                        ;#error Wrong FF_MIN_GPT setting
   489                        ;#endif
   490                        ;static const BYTE GUID_MS_Basic[16] = {0xA2,0xA0,
                    0xD0,0xEB,0xE5,0xB9,0x33,0x44,0x87,0xC0,0x68,0xB6,0xB7,0x26,
                    0x99,0xC7};
   491                        ;#endif
   492                        ;
   493                        ;
   494                        ;
   495                        ;/*--------------------------------*/
   496                        ;/* LFN/Directory working buffer   */
   497                        ;/*--------------------------------*/
   498                        ;
  Thu May 20 2021 21:37                                                Page 18


   499                        ;#if FF_USE_LFN == 0		/* Non-LFN confi
                    guration */
   500                        ;#if FF_FS_EXFAT
   501                        ;#error LFN must be enabled when enable exFAT
   502                        ;#endif
   503                        ;#define DEF_NAMBUF
   504                        ;#define INIT_NAMBUF(fs)
   505                        ;#define FREE_NAMBUF()
   506                        ;#define LEAVE_MKFS(res)	return res
   507                        ;
   508                        ;#else					/* LFN c
                    onfigurations */
   509                        ;#if FF_MAX_LFN < 12 || FF_MAX_LFN > 255
   510                        ;#error Wrong setting of FF_MAX_LFN
   511                        ;#endif
   512                        ;#if FF_LFN_BUF < FF_SFN_BUF || FF_SFN_BUF < 12
   513                        ;#error Wrong setting of FF_LFN_BUF or FF_SFN_BUF
   514                        ;#endif
   515                        ;#if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3
   516                        ;#error Wrong setting of FF_LFN_UNICODE
   517                        ;#endif
   518                        ;static const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,
                    20,22,24,28,30};	/* FAT: Offset of LFN characters in the 
                    directory entry */
   519                        ;#define MAXDIRB(nc)	((nc + 44U) / 15 * SZDIR
                    E)	/* exFAT: Size of directory entry block scratchpad buffe
                    r needed for the name length */
   520                        ;
   521                        ;#if FF_USE_LFN == 1		/* LFN enabled w
                    ith static working buffer */
   522                        ;#if FF_FS_EXFAT
   523                        ;static BYTE	DirBuf[MAXDIRB(FF_MAX_LFN)];	
                    /* Directory entry block scratchpad buffer */
   524                        ;#endif
   525                        ;static WCHAR LfnBuf[FF_MAX_LFN + 1];		
                    /* LFN working buffer */
   526                        ;#define DEF_NAMBUF
   527                        ;#define INIT_NAMBUF(fs)
   528                        ;#define FREE_NAMBUF()
   529                        ;#define LEAVE_MKFS(res)	return res
   530                        ;
   531                        ;#elif FF_USE_LFN == 2 	/* LFN enabled with dyna
                    mic working buffer on the stack */
   532                        ;#if FF_FS_EXFAT
   533                        ;#define DEF_NAMBUF		WCHAR lbuf[FF_MA
                    X_LFN+1]; BYTE dbuf[MAXDIRB(FF_MAX_LFN)];	/* LFN working b
                    uffer and directory entry block scratchpad buffer */
   534                        ;#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; (
                    fs)->dirbuf = dbuf; }
   535                        ;#define FREE_NAMBUF()
   536                        ;#else
   537                        ;#define DEF_NAMBUF		WCHAR lbuf[FF_MA
                    X_LFN+1];	/* LFN working buffer */
   538                        ;#define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; }
   539                        ;#define FREE_NAMBUF()
   540                        ;#endif
   541                        ;#define LEAVE_MKFS(res)	return res
   542                        ;
  Thu May 20 2021 21:37                                                Page 19


   543                        ;#elif FF_USE_LFN == 3 	/* LFN enabled with dyna
                    mic working buffer on the heap */
   544                        ;#if FF_FS_EXFAT
   545                        ;#define DEF_NAMBUF		WCHAR *lfn;	
                    /* Pointer to LFN working buffer and directory entry block s
                    cratchpad buffer */
   546                        ;#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_
                    MAX_LFN+1)*2 + MAXDIRB(FF_MAX_LFN)); if (!lfn) LEAVE_FF(fs, 
                    FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYT
                    E*)(lfn+FF_MAX_LFN+1); }
   547                        ;#define FREE_NAMBUF()	ff_memfree(lfn)
   548                        ;#else
   549                        ;#define DEF_NAMBUF		WCHAR *lfn;	
                    /* Pointer to LFN working buffer */
   550                        ;#define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_
                    MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (
                    fs)->lfnbuf = lfn; }
   551                        ;#define FREE_NAMBUF()	ff_memfree(lfn)
   552                        ;#endif
   553                        ;#define LEAVE_MKFS(res)	{ if (!work) ff_memfree(
                    buf); return res; }
   554                        ;#define MAX_MALLOC	0x8000	/* Must be >=FF_
                    MAX_SS */
   555                        ;
   556                        ;#else
   557                        ;#error Wrong setting of FF_USE_LFN
   558                        ;
   559                        ;#endif	/* FF_USE_LFN == 1 */
   560                        ;#endif	/* FF_USE_LFN == 0 */
   561                        ;
   562                        ;
   563                        ;
   564                        ;/*--------------------------------*/
   565                        ;/* Code conversion tables         */
   566                        ;/*--------------------------------*/
   567                        ;
   568                        ;#if FF_CODE_PAGE == 0	/* Run-time code page co
                    nfiguration */
   569                        ;#define CODEPAGE CodePage
   570                        ;static WORD CodePage;	/* Current code page */
   571                        ;static const BYTE *ExCvt, *DbcTbl;	/* Point
                    er to current SBCS up-case table and DBCS code range table b
                    elow */
   572                        ;
   573                        ;static const BYTE Ct437[] = TBL_CT437;
   574                        ;static const BYTE Ct720[] = TBL_CT720;
   575                        ;static const BYTE Ct737[] = TBL_CT737;
   576                        ;static const BYTE Ct771[] = TBL_CT771;
   577                        ;static const BYTE Ct775[] = TBL_CT775;
   578                        ;static const BYTE Ct850[] = TBL_CT850;
   579                        ;static const BYTE Ct852[] = TBL_CT852;
   580                        ;static const BYTE Ct855[] = TBL_CT855;
   581                        ;static const BYTE Ct857[] = TBL_CT857;
   582                        ;static const BYTE Ct860[] = TBL_CT860;
   583                        ;static const BYTE Ct861[] = TBL_CT861;
   584                        ;static const BYTE Ct862[] = TBL_CT862;
   585                        ;static const BYTE Ct863[] = TBL_CT863;
   586                        ;static const BYTE Ct864[] = TBL_CT864;
  Thu May 20 2021 21:37                                                Page 20


   587                        ;static const BYTE Ct865[] = TBL_CT865;
   588                        ;static const BYTE Ct866[] = TBL_CT866;
   589                        ;static const BYTE Ct869[] = TBL_CT869;
   590                        ;static const BYTE Dc932[] = TBL_DC932;
   591                        ;static const BYTE Dc936[] = TBL_DC936;
   592                        ;static const BYTE Dc949[] = TBL_DC949;
   593                        ;static const BYTE Dc950[] = TBL_DC950;
   594                        ;
   595                        ;#elif FF_CODE_PAGE < 900	/* Static code page conf
                    iguration (SBCS) */
   596                        ;#define CODEPAGE FF_CODE_PAGE
   597                        ;static const BYTE ExCvt[] = MKCVTBL(TBL_CT, FF_CO
                    DE_PAGE);
   598                        	data
   599                        ~~ExCvt:
   600 00:0000: 80 9A 45 41  	db	$80,$9A,$45,$41,$8E,$41,$8F,$80,$45,$45
       00:0004: 8E 41 8F 80 
       00:0008: 45 45 
   601 00:000A: 45 49 49 49  	db	$45,$49,$49,$49,$8E,$8F,$90,$92,$92,$4F
       00:000E: 8E 8F 90 92 
       00:0012: 92 4F 
   602 00:0014: 99 4F 55 55  	db	$99,$4F,$55,$55,$59,$99,$9A,$9B,$9C,$9D
       00:0018: 59 99 9A 9B 
       00:001C: 9C 9D 
   603 00:001E: 9E 9F 41 49  	db	$9E,$9F,$41,$49,$4F,$55,$A5,$A5,$A6,$A7
       00:0022: 4F 55 A5 A5 
       00:0026: A6 A7 
   604 00:0028: A8 A9 AA AB  	db	$A8,$A9,$AA,$AB,$AC,$AD,$AE,$AF,$B0,$B1
       00:002C: AC AD AE AF 
       00:0030: B0 B1 
   605 00:0032: B2 B3 B4 B5  	db	$B2,$B3,$B4,$B5,$B6,$B7,$B8,$B9,$BA,$BB
       00:0036: B6 B7 B8 B9 
       00:003A: BA BB 
   606 00:003C: BC BD BE BF  	db	$BC,$BD,$BE,$BF,$C0,$C1,$C2,$C3,$C4,$C5
       00:0040: C0 C1 C2 C3 
       00:0044: C4 C5 
   607 00:0046: C6 C7 C8 C9  	db	$C6,$C7,$C8,$C9,$CA,$CB,$CC,$CD,$CE,$CF
       00:004A: CA CB CC CD 
       00:004E: CE CF 
   608 00:0050: D0 D1 D2 D3  	db	$D0,$D1,$D2,$D3,$D4,$D5,$D6,$D7,$D8,$D9
       00:0054: D4 D5 D6 D7 
       00:0058: D8 D9 
   609 00:005A: DA DB DC DD  	db	$DA,$DB,$DC,$DD,$DE,$DF,$E0,$E1,$E2,$E3
       00:005E: DE DF E0 E1 
       00:0062: E2 E3 
   610 00:0064: E4 E5 E6 E7  	db	$E4,$E5,$E6,$E7,$E8,$E9,$EA,$EB,$EC,$ED
       00:0068: E8 E9 EA EB 
       00:006C: EC ED 
   611 00:006E: EE EF F0 F1  	db	$EE,$EF,$F0,$F1,$F2,$F3,$F4,$F5,$F6,$F7
       00:0072: F2 F3 F4 F5 
       00:0076: F6 F7 
   612 00:0078: F8 F9 FA FB  	db	$F8,$F9,$FA,$FB,$FC,$FD,$FE,$FF
       00:007C: FC FD FE FF 
   613 00:0080:              	ends
   614                        ;
   615                        ;#else					/* Stati
                    c code page configuration (DBCS) */
   616                        ;#define CODEPAGE FF_CODE_PAGE
  Thu May 20 2021 21:37                                                Page 21


   617                        ;static const BYTE DbcTbl[] = MKCVTBL(TBL_DC, FF_C
                    ODE_PAGE);
   618                        ;
   619                        ;#endif
   620                        ;
   621                        ;
   622                        ;
   623                        ;
   624                        ;/*-----------------------------------------------
                    ---------------------------
   625                        ;
   626                        ;   Module Private Functions
   627                        ;
   628                        ;-------------------------------------------------
                    --------------------------*/
   629                        ;
   630                        ;
   631                        ;/*-----------------------------------------------
                    ------------------------*/
   632                        ;/* Load/Store multi-byte word in the FAT structur
                    e                       */
   633                        ;/*-----------------------------------------------
                    ------------------------*/
   634                        ;
   635                        ;static WORD ld_word (const BYTE* ptr)	/*	
                     Load a 2-byte little-endian word */
   636                        ;{
   637                        	code
   638                        	func
   639                        ~~ld_word:
   640                        	longa	on
   641                        	longi	on
   642 00:0000: 3B           	tsc
   643 00:0001: 38           	sec
   644 00:0002: E9 0A 00     	sbc	#L2
   645 00:0005: 1B           	tcs
   646 00:0006: 0B           	phd
   647 00:0007: 5B           	tcd
   648             00000004   ptr_0	set	4
   649                        ;	WORD rv;
   650                        ;
   651                        ;	rv = ptr[1];
   652             00000000   rv_1	set	0
   653 00:0008: A0 01 00     	ldy	#$1
   654 00:000B: B7 0E        	lda	[<L2+ptr_0],Y
   655 00:000D: 29 FF 00     	and	#$ff
   656 00:0010: 85 09        	sta	<L3+rv_1
   657                        ;	rv = rv << 8 | ptr[0];
   658 00:0012: A5 09        	lda	<L3+rv_1
   659 00:0014: EB           	xba
   660 00:0015: 29 00 FF     	and	#$ff00
   661 00:0018: 85 01        	sta	<R0
   662 00:001A: A7 0E        	lda	[<L2+ptr_0]
   663 00:001C: 29 FF 00     	and	#$ff
   664 00:001F: 85 05        	sta	<R1
   665 00:0021: A5 05        	lda	<R1
   666 00:0023: 05 01        	ora	<R0
   667 00:0025: 85 09        	sta	<L3+rv_1
  Thu May 20 2021 21:37                                                Page 22


   668                        ;	return rv;
   669 00:0027: A5 09        	lda	<L3+rv_1
   670                        L4:
   671 00:0029: A8           	tay
   672 00:002A: A5 0C        	lda	<L2+2
   673 00:002C: 85 10        	sta	<L2+2+4
   674 00:002E: A5 0B        	lda	<L2+1
   675 00:0030: 85 0F        	sta	<L2+1+4
   676 00:0032: 2B           	pld
   677 00:0033: 3B           	tsc
   678 00:0034: 18           	clc
   679 00:0035: 69 0E 00     	adc	#L2+4
   680 00:0038: 1B           	tcs
   681 00:0039: 98           	tya
   682 00:003A: 6B           	rtl
   683                        ;}
   684             0000000A   L2	equ	10
   685             00000009   L3	equ	9
   686                        	ends
   687                        	efunc
   688                        ;
   689                        ;static DWORD ld_dword (const BYTE* ptr)	/* Load 
                    a 4-byte little-endian word */
   690                        ;{
   691                        	code
   692                        	func
   693                        ~~ld_dword:
   694                        	longa	on
   695                        	longi	on
   696 00:003B: 3B           	tsc
   697 00:003C: 38           	sec
   698 00:003D: E9 0C 00     	sbc	#L5
   699 00:0040: 1B           	tcs
   700 00:0041: 0B           	phd
   701 00:0042: 5B           	tcd
   702             00000004   ptr_0	set	4
   703                        ;	DWORD rv;
   704                        ;
   705                        ;	rv = ptr[3];
   706             00000000   rv_1	set	0
   707 00:0043: A0 03 00     	ldy	#$3
   708 00:0046: B7 10        	lda	[<L5+ptr_0],Y
   709 00:0048: 29 FF 00     	and	#$ff
   710 00:004B: 85 09        	sta	<L6+rv_1
   711 00:004D: 64 0B        	stz	<L6+rv_1+2
   712                        ;	rv = rv << 8 | ptr[2];
   713 00:004F: D4 0B        	pei	<L6+rv_1+2
   714 00:0051: D4 09        	pei	<L6+rv_1
   715 00:0053: A9 08 00     	lda	#$8
   716                        	xref	~~~lasl
   717 00:0056: 22 xx xx xx  	jsl	~~~lasl
   718 00:005A: 85 01        	sta	<R0
   719 00:005C: 86 03        	stx	<R0+2
   720 00:005E: A0 02 00     	ldy	#$2
   721 00:0061: B7 10        	lda	[<L5+ptr_0],Y
   722 00:0063: 29 FF 00     	and	#$ff
   723 00:0066: 85 05        	sta	<R1
   724 00:0068: 64 07        	stz	<R1+2
  Thu May 20 2021 21:37                                                Page 23


   725 00:006A: A5 05        	lda	<R1
   726 00:006C: 05 01        	ora	<R0
   727 00:006E: 85 09        	sta	<L6+rv_1
   728 00:0070: A5 07        	lda	<R1+2
   729 00:0072: 05 03        	ora	<R0+2
   730 00:0074: 85 0B        	sta	<L6+rv_1+2
   731                        ;	rv = rv << 8 | ptr[1];
   732 00:0076: D4 0B        	pei	<L6+rv_1+2
   733 00:0078: D4 09        	pei	<L6+rv_1
   734 00:007A: A9 08 00     	lda	#$8
   735                        	xref	~~~lasl
   736 00:007D: 22 xx xx xx  	jsl	~~~lasl
   737 00:0081: 85 01        	sta	<R0
   738 00:0083: 86 03        	stx	<R0+2
   739 00:0085: A0 01 00     	ldy	#$1
   740 00:0088: B7 10        	lda	[<L5+ptr_0],Y
   741 00:008A: 29 FF 00     	and	#$ff
   742 00:008D: 85 05        	sta	<R1
   743 00:008F: 64 07        	stz	<R1+2
   744 00:0091: A5 05        	lda	<R1
   745 00:0093: 05 01        	ora	<R0
   746 00:0095: 85 09        	sta	<L6+rv_1
   747 00:0097: A5 07        	lda	<R1+2
   748 00:0099: 05 03        	ora	<R0+2
   749 00:009B: 85 0B        	sta	<L6+rv_1+2
   750                        ;	rv = rv << 8 | ptr[0];
   751 00:009D: D4 0B        	pei	<L6+rv_1+2
   752 00:009F: D4 09        	pei	<L6+rv_1
   753 00:00A1: A9 08 00     	lda	#$8
   754                        	xref	~~~lasl
   755 00:00A4: 22 xx xx xx  	jsl	~~~lasl
   756 00:00A8: 85 01        	sta	<R0
   757 00:00AA: 86 03        	stx	<R0+2
   758 00:00AC: A7 10        	lda	[<L5+ptr_0]
   759 00:00AE: 29 FF 00     	and	#$ff
   760 00:00B1: 85 05        	sta	<R1
   761 00:00B3: 64 07        	stz	<R1+2
   762 00:00B5: A5 05        	lda	<R1
   763 00:00B7: 05 01        	ora	<R0
   764 00:00B9: 85 09        	sta	<L6+rv_1
   765 00:00BB: A5 07        	lda	<R1+2
   766 00:00BD: 05 03        	ora	<R0+2
   767 00:00BF: 85 0B        	sta	<L6+rv_1+2
   768                        ;	return rv;
   769 00:00C1: A6 0B        	ldx	<L6+rv_1+2
   770 00:00C3: A5 09        	lda	<L6+rv_1
   771                        L7:
   772 00:00C5: A8           	tay
   773 00:00C6: A5 0E        	lda	<L5+2
   774 00:00C8: 85 12        	sta	<L5+2+4
   775 00:00CA: A5 0D        	lda	<L5+1
   776 00:00CC: 85 11        	sta	<L5+1+4
   777 00:00CE: 2B           	pld
   778 00:00CF: 3B           	tsc
   779 00:00D0: 18           	clc
   780 00:00D1: 69 10 00     	adc	#L5+4
   781 00:00D4: 1B           	tcs
   782 00:00D5: 98           	tya
  Thu May 20 2021 21:37                                                Page 24


   783 00:00D6: 6B           	rtl
   784                        ;}
   785             0000000C   L5	equ	12
   786             00000009   L6	equ	9
   787                        	ends
   788                        	efunc
   789                        ;
   790                        ;#if FF_FS_EXFAT
   791                        ;static QWORD ld_qword (const BYTE* ptr)	/* Load 
                    an 8-byte little-endian word */
   792                        ;{
   793                        ;	QWORD rv;
   794                        ;
   795                        ;	rv = ptr[7];
   796                        ;	rv = rv << 8 | ptr[6];
   797                        ;	rv = rv << 8 | ptr[5];
   798                        ;	rv = rv << 8 | ptr[4];
   799                        ;	rv = rv << 8 | ptr[3];
   800                        ;	rv = rv << 8 | ptr[2];
   801                        ;	rv = rv << 8 | ptr[1];
   802                        ;	rv = rv << 8 | ptr[0];
   803                        ;	return rv;
   804                        ;}
   805                        ;#endif
   806                        ;
   807                        ;#if !FF_FS_READONLY
   808                        ;static void st_word (BYTE* ptr, WORD val)	
                    /* Store a 2-byte word in little-endian */
   809                        ;{
   810                        	code
   811                        	func
   812                        ~~st_word:
   813                        	longa	on
   814                        	longi	on
   815 00:00D7: 3B           	tsc
   816 00:00D8: 38           	sec
   817 00:00D9: E9 00 00     	sbc	#L8
   818 00:00DC: 1B           	tcs
   819 00:00DD: 0B           	phd
   820 00:00DE: 5B           	tcd
   821             00000004   ptr_0	set	4
   822             00000008   val_0	set	8
   823                        ;	*ptr++ = (BYTE)val; val >>= 8;
   824 00:00DF: E2 20        	sep	#$20
   825                        	longa	off
   826 00:00E1: A5 08        	lda	<L8+val_0
   827 00:00E3: 87 04        	sta	[<L8+ptr_0]
   828 00:00E5: C2 20        	rep	#$20
   829                        	longa	on
   830 00:00E7: E6 04        	inc	<L8+ptr_0
   831 00:00E9: D0 02        	bne	L10
   832 00:00EB: E6 06        	inc	<L8+ptr_0+2
   833                        L10:
   834 00:00ED: A5 08        	lda	<L8+val_0
   835 00:00EF: EB           	xba
   836 00:00F0: 29 FF 00     	and	#$00ff
   837 00:00F3: 85 08        	sta	<L8+val_0
   838                        ;	*ptr++ = (BYTE)val;
  Thu May 20 2021 21:37                                                Page 25


   839 00:00F5: E2 20        	sep	#$20
   840                        	longa	off
   841 00:00F7: A5 08        	lda	<L8+val_0
   842 00:00F9: 87 04        	sta	[<L8+ptr_0]
   843 00:00FB: C2 20        	rep	#$20
   844                        	longa	on
   845 00:00FD: E6 04        	inc	<L8+ptr_0
   846 00:00FF: D0 02        	bne	L11
   847 00:0101: E6 06        	inc	<L8+ptr_0+2
   848                        L11:
   849                        ;}
   850                        L12:
   851 00:0103: A5 02        	lda	<L8+2
   852 00:0105: 85 08        	sta	<L8+2+6
   853 00:0107: A5 01        	lda	<L8+1
   854 00:0109: 85 07        	sta	<L8+1+6
   855 00:010B: 2B           	pld
   856 00:010C: 3B           	tsc
   857 00:010D: 18           	clc
   858 00:010E: 69 06 00     	adc	#L8+6
   859 00:0111: 1B           	tcs
   860 00:0112: 6B           	rtl
   861             00000000   L8	equ	0
   862             00000001   L9	equ	1
   863                        	ends
   864                        	efunc
   865                        ;
   866                        ;static void st_dword (BYTE* ptr, DWORD val)	
                    /* Store a 4-byte word in little-endian */
   867                        ;{
   868                        	code
   869                        	func
   870                        ~~st_dword:
   871                        	longa	on
   872                        	longi	on
   873 00:0113: 3B           	tsc
   874 00:0114: 38           	sec
   875 00:0115: E9 00 00     	sbc	#L13
   876 00:0118: 1B           	tcs
   877 00:0119: 0B           	phd
   878 00:011A: 5B           	tcd
   879             00000004   ptr_0	set	4
   880             00000008   val_0	set	8
   881                        ;	*ptr++ = (BYTE)val; val >>= 8;
   882 00:011B: E2 20        	sep	#$20
   883                        	longa	off
   884 00:011D: A5 08        	lda	<L13+val_0
   885 00:011F: 87 04        	sta	[<L13+ptr_0]
   886 00:0121: C2 20        	rep	#$20
   887                        	longa	on
   888 00:0123: E6 04        	inc	<L13+ptr_0
   889 00:0125: D0 02        	bne	L15
   890 00:0127: E6 06        	inc	<L13+ptr_0+2
   891                        L15:
   892 00:0129: D4 0A        	pei	<L13+val_0+2
   893 00:012B: D4 08        	pei	<L13+val_0
   894 00:012D: A9 08 00     	lda	#$8
   895                        	xref	~~~llsr
  Thu May 20 2021 21:37                                                Page 26


   896 00:0130: 22 xx xx xx  	jsl	~~~llsr
   897 00:0134: 85 08        	sta	<L13+val_0
   898 00:0136: 86 0A        	stx	<L13+val_0+2
   899                        ;	*ptr++ = (BYTE)val; val >>= 8;
   900 00:0138: E2 20        	sep	#$20
   901                        	longa	off
   902 00:013A: A5 08        	lda	<L13+val_0
   903 00:013C: 87 04        	sta	[<L13+ptr_0]
   904 00:013E: C2 20        	rep	#$20
   905                        	longa	on
   906 00:0140: E6 04        	inc	<L13+ptr_0
   907 00:0142: D0 02        	bne	L16
   908 00:0144: E6 06        	inc	<L13+ptr_0+2
   909                        L16:
   910 00:0146: D4 0A        	pei	<L13+val_0+2
   911 00:0148: D4 08        	pei	<L13+val_0
   912 00:014A: A9 08 00     	lda	#$8
   913                        	xref	~~~llsr
   914 00:014D: 22 xx xx xx  	jsl	~~~llsr
   915 00:0151: 85 08        	sta	<L13+val_0
   916 00:0153: 86 0A        	stx	<L13+val_0+2
   917                        ;	*ptr++ = (BYTE)val; val >>= 8;
   918 00:0155: E2 20        	sep	#$20
   919                        	longa	off
   920 00:0157: A5 08        	lda	<L13+val_0
   921 00:0159: 87 04        	sta	[<L13+ptr_0]
   922 00:015B: C2 20        	rep	#$20
   923                        	longa	on
   924 00:015D: E6 04        	inc	<L13+ptr_0
   925 00:015F: D0 02        	bne	L17
   926 00:0161: E6 06        	inc	<L13+ptr_0+2
   927                        L17:
   928 00:0163: D4 0A        	pei	<L13+val_0+2
   929 00:0165: D4 08        	pei	<L13+val_0
   930 00:0167: A9 08 00     	lda	#$8
   931                        	xref	~~~llsr
   932 00:016A: 22 xx xx xx  	jsl	~~~llsr
   933 00:016E: 85 08        	sta	<L13+val_0
   934 00:0170: 86 0A        	stx	<L13+val_0+2
   935                        ;	*ptr++ = (BYTE)val;
   936 00:0172: E2 20        	sep	#$20
   937                        	longa	off
   938 00:0174: A5 08        	lda	<L13+val_0
   939 00:0176: 87 04        	sta	[<L13+ptr_0]
   940 00:0178: C2 20        	rep	#$20
   941                        	longa	on
   942 00:017A: E6 04        	inc	<L13+ptr_0
   943 00:017C: D0 02        	bne	L18
   944 00:017E: E6 06        	inc	<L13+ptr_0+2
   945                        L18:
   946                        ;}
   947                        L19:
   948 00:0180: A5 02        	lda	<L13+2
   949 00:0182: 85 0A        	sta	<L13+2+8
   950 00:0184: A5 01        	lda	<L13+1
   951 00:0186: 85 09        	sta	<L13+1+8
   952 00:0188: 2B           	pld
   953 00:0189: 3B           	tsc
  Thu May 20 2021 21:37                                                Page 27


   954 00:018A: 18           	clc
   955 00:018B: 69 08 00     	adc	#L13+8
   956 00:018E: 1B           	tcs
   957 00:018F: 6B           	rtl
   958             00000000   L13	equ	0
   959             00000001   L14	equ	1
   960                        	ends
   961                        	efunc
   962                        ;
   963                        ;#if FF_FS_EXFAT
   964                        ;static void st_qword (BYTE* ptr, QWORD val)	
                    /* Store an 8-byte word in little-endian */
   965                        ;{
   966                        ;	*ptr++ = (BYTE)val; val >>= 8;
   967                        ;	*ptr++ = (BYTE)val; val >>= 8;
   968                        ;	*ptr++ = (BYTE)val; val >>= 8;
   969                        ;	*ptr++ = (BYTE)val; val >>= 8;
   970                        ;	*ptr++ = (BYTE)val; val >>= 8;
   971                        ;	*ptr++ = (BYTE)val; val >>= 8;
   972                        ;	*ptr++ = (BYTE)val; val >>= 8;
   973                        ;	*ptr++ = (BYTE)val;
   974                        ;}
   975                        ;#endif
   976                        ;#endif	/* !FF_FS_READONLY */
   977                        ;
   978                        ;
   979                        ;
   980                        ;/*-----------------------------------------------
                    ------------------------*/
   981                        ;/* String functions                              
                                            */
   982                        ;/*-----------------------------------------------
                    ------------------------*/
   983                        ;
   984                        ;/* Test if the byte is DBC 1st byte */
   985                        ;static int dbc_1st (BYTE c)
   986                        ;{
   987                        	code
   988                        	func
   989                        ~~dbc_1st:
   990                        	longa	on
   991                        	longi	on
   992 00:0190: 3B           	tsc
   993 00:0191: 38           	sec
   994 00:0192: E9 00 00     	sbc	#L20
   995 00:0195: 1B           	tcs
   996 00:0196: 0B           	phd
   997 00:0197: 5B           	tcd
   998             00000004   c_0	set	4
   999                        ;#if FF_CODE_PAGE == 0		/* Variable code
                     page */
  1000                        ;	if (DbcTbl && c >= DbcTbl[0]) {
  1001                        ;		if (c <= DbcTbl[1]) return 1;		
                    			/* 1st byte range 1 */
  1002                        ;		if (c >= DbcTbl[2] && c <= DbcTbl[3]) re
                    turn 1;	/* 1st byte range 2 */
  1003                        ;	}
  1004                        ;#elif FF_CODE_PAGE >= 900	/* DBCS fixed co
  Thu May 20 2021 21:37                                                Page 28


                    de page */
  1005                        ;	if (c >= DbcTbl[0]) {
  1006                        ;		if (c <= DbcTbl[1]) return 1;
  1007                        ;		if (c >= DbcTbl[2] && c <= DbcTbl[3]) re
                    turn 1;
  1008                        ;	}
  1009                        ;#else						
                    /* SBCS fixed code page */
  1010                        ;	if (c != 0) return 0;	/* Always false */
  1011 00:0198: A5 04        	lda	<L20+c_0
  1012 00:019A: 29 FF 00     	and	#$ff
  1013 00:019D: D0 03        	bne	L22
  1014 00:019F: 82 15 00     	brl	L10001
  1015                        L22:
  1016 00:01A2: A9 00 00     	lda	#$0
  1017                        L23:
  1018 00:01A5: A8           	tay
  1019 00:01A6: A5 02        	lda	<L20+2
  1020 00:01A8: 85 04        	sta	<L20+2+2
  1021 00:01AA: A5 01        	lda	<L20+1
  1022 00:01AC: 85 03        	sta	<L20+1+2
  1023 00:01AE: 2B           	pld
  1024 00:01AF: 3B           	tsc
  1025 00:01B0: 18           	clc
  1026 00:01B1: 69 02 00     	adc	#L20+2
  1027 00:01B4: 1B           	tcs
  1028 00:01B5: 98           	tya
  1029 00:01B6: 6B           	rtl
  1030                        ;#endif
  1031                        ;	return 0;
  1032                        L10001:
  1033 00:01B7: A9 00 00     	lda	#$0
  1034 00:01BA: 82 E8 FF     	brl	L23
  1035                        ;}
  1036             00000000   L20	equ	0
  1037             00000001   L21	equ	1
  1038                        	ends
  1039                        	efunc
  1040                        ;
  1041                        ;
  1042                        ;/* Test if the byte is DBC 2nd byte */
  1043                        ;static int dbc_2nd (BYTE c)
  1044                        ;{
  1045                        	code
  1046                        	func
  1047                        ~~dbc_2nd:
  1048                        	longa	on
  1049                        	longi	on
  1050 00:01BD: 3B           	tsc
  1051 00:01BE: 38           	sec
  1052 00:01BF: E9 00 00     	sbc	#L24
  1053 00:01C2: 1B           	tcs
  1054 00:01C3: 0B           	phd
  1055 00:01C4: 5B           	tcd
  1056             00000004   c_0	set	4
  1057                        ;#if FF_CODE_PAGE == 0		/* Variable code
                     page */
  1058                        ;	if (DbcTbl && c >= DbcTbl[4]) {
  Thu May 20 2021 21:37                                                Page 29


  1059                        ;		if (c <= DbcTbl[5]) return 1;		
                    			/* 2nd byte range 1 */
  1060                        ;		if (c >= DbcTbl[6] && c <= DbcTbl[7]) re
                    turn 1;	/* 2nd byte range 2 */
  1061                        ;		if (c >= DbcTbl[8] && c <= DbcTbl[9]) re
                    turn 1;	/* 2nd byte range 3 */
  1062                        ;	}
  1063                        ;#elif FF_CODE_PAGE >= 900	/* DBCS fixed co
                    de page */
  1064                        ;	if (c >= DbcTbl[4]) {
  1065                        ;		if (c <= DbcTbl[5]) return 1;
  1066                        ;		if (c >= DbcTbl[6] && c <= DbcTbl[7]) re
                    turn 1;
  1067                        ;		if (c >= DbcTbl[8] && c <= DbcTbl[9]) re
                    turn 1;
  1068                        ;	}
  1069                        ;#else						
                    /* SBCS fixed code page */
  1070                        ;	if (c != 0) return 0;	/* Always false */
  1071 00:01C5: A5 04        	lda	<L24+c_0
  1072 00:01C7: 29 FF 00     	and	#$ff
  1073 00:01CA: D0 03        	bne	L26
  1074 00:01CC: 82 15 00     	brl	L10002
  1075                        L26:
  1076 00:01CF: A9 00 00     	lda	#$0
  1077                        L27:
  1078 00:01D2: A8           	tay
  1079 00:01D3: A5 02        	lda	<L24+2
  1080 00:01D5: 85 04        	sta	<L24+2+2
  1081 00:01D7: A5 01        	lda	<L24+1
  1082 00:01D9: 85 03        	sta	<L24+1+2
  1083 00:01DB: 2B           	pld
  1084 00:01DC: 3B           	tsc
  1085 00:01DD: 18           	clc
  1086 00:01DE: 69 02 00     	adc	#L24+2
  1087 00:01E1: 1B           	tcs
  1088 00:01E2: 98           	tya
  1089 00:01E3: 6B           	rtl
  1090                        ;#endif
  1091                        ;	return 0;
  1092                        L10002:
  1093 00:01E4: A9 00 00     	lda	#$0
  1094 00:01E7: 82 E8 FF     	brl	L27
  1095                        ;}
  1096             00000000   L24	equ	0
  1097             00000001   L25	equ	1
  1098                        	ends
  1099                        	efunc
  1100                        ;
  1101                        ;
  1102                        ;#if FF_USE_LFN
  1103                        ;
  1104                        ;/* Get a Unicode code point from the TCHAR string
                     in defined API encodeing */
  1105                        ;static DWORD tchar2uni (	/* Returns a character i
                    n UTF-16 encoding (>=0x10000 on surrogate pair, 0xFFFFFFFF o
                    n decode error) */
  1106                        ;	const TCHAR** str		/* Pointer to po
  Thu May 20 2021 21:37                                                Page 30


                    inter to TCHAR string in configured encoding */
  1107                        ;)
  1108                        ;{
  1109                        ;	DWORD uc;
  1110                        ;	const TCHAR *p = *str;
  1111                        ;
  1112                        ;#if FF_LFN_UNICODE == 1		/* UTF-16 input 
                    */
  1113                        ;	WCHAR wc;
  1114                        ;
  1115                        ;	uc = *p++;	/* Get a unit */
  1116                        ;	if (IsSurrogate(uc)) {	/* Surrogate? */
  1117                        ;		wc = *p++;		/* Get low surro
                    gate */
  1118                        ;		if (!IsSurrogateH(uc) || !IsSurrogateL(w
                    c)) return 0xFFFFFFFF;	/* Wrong surrogate? */
  1119                        ;		uc = uc << 16 | wc;
  1120                        ;	}
  1121                        ;
  1122                        ;#elif FF_LFN_UNICODE == 2	/* UTF-8 input *
                    /
  1123                        ;	BYTE b;
  1124                        ;	int nf;
  1125                        ;
  1126                        ;	uc = (BYTE)*p++;	/* Get an encoding unit 
                    */
  1127                        ;	if (uc & 0x80) {	/* Multiple byte code? *
                    /
  1128                        ;		if        ((uc & 0xE0) == 0xC0) {	
                    /* 2-byte sequence? */
  1129                        ;			uc &= 0x1F; nf = 1;
  1130                        ;		} else if ((uc & 0xF0) == 0xE0) {	
                    /* 3-byte sequence? */
  1131                        ;			uc &= 0x0F; nf = 2;
  1132                        ;		} else if ((uc & 0xF8) == 0xF0) {	
                    /* 4-byte sequence? */
  1133                        ;			uc &= 0x07; nf = 3;
  1134                        ;		} else {				
                    			/* Wrong sequence */
  1135                        ;			return 0xFFFFFFFF;
  1136                        ;		}
  1137                        ;		do {	/* Get trailing bytes */
  1138                        ;			b = (BYTE)*p++;
  1139                        ;			if ((b & 0xC0) != 0x80) return 0
                    xFFFFFFFF;	/* Wrong sequence? */
  1140                        ;			uc = uc << 6 | (b & 0x3F);
  1141                        ;		} while (--nf != 0);
  1142                        ;		if (uc < 0x80 || IsSurrogate(uc) || uc >
                    = 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
  1143                        ;		if (uc >= 0x010000) uc = 0xD800DC00 | ((
                    uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make 
                    a surrogate pair if needed */
  1144                        ;	}
  1145                        ;
  1146                        ;#elif FF_LFN_UNICODE == 3	/* UTF-32 input 
                    */
  1147                        ;	uc = (TCHAR)*p++;	/* Get a unit */
  1148                        ;	if (uc >= 0x110000 || IsSurrogate(uc)) return 0x
  Thu May 20 2021 21:37                                                Page 31


                    FFFFFFFF;	/* Wrong code? */
  1149                        ;	if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x1
                    0000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrog
                    ate pair if needed */
  1150                        ;
  1151                        ;#else		/* ANSI/OEM input */
  1152                        ;	BYTE b;
  1153                        ;	WCHAR wc;
  1154                        ;
  1155                        ;	wc = (BYTE)*p++;			/* Get a
                     byte */
  1156                        ;	if (dbc_1st((BYTE)wc)) {	/* Is it a DBC 1
                    st byte? */
  1157                        ;		b = (BYTE)*p++;			/* Get 2
                    nd byte */
  1158                        ;		if (!dbc_2nd(b)) return 0xFFFFFFFF;	
                    /* Invalid code? */
  1159                        ;		wc = (wc << 8) + b;		/* Make 
                    a DBC */
  1160                        ;	}
  1161                        ;	if (wc != 0) {
  1162                        ;		wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/
                    OEM ==> Unicode */
  1163                        ;		if (wc == 0) return 0xFFFFFFFF;	/* Inval
                    id code? */
  1164                        ;	}
  1165                        ;	uc = wc;
  1166                        ;
  1167                        ;#endif
  1168                        ;	*str = p;	/* Next read pointer */
  1169                        ;	return uc;
  1170                        ;}
  1171                        ;
  1172                        ;
  1173                        ;/* Store a Unicode char in defined API encoding *
                    /
  1174                        ;static UINT put_utf (	/* Returns number of enc
                    oding units written (0:buffer overflow or wrong encoding) */
  1175                        ;	DWORD chr,	/* UTF-16 encoded character (Sur
                    rogate pair if >=0x10000) */
  1176                        ;	TCHAR* buf,	/* Output buffer */
  1177                        ;	UINT szb	/* Size of the buffer */
  1178                        ;)
  1179                        ;{
  1180                        ;#if FF_LFN_UNICODE == 1	/* UTF-16 output */
  1181                        ;	WCHAR hs, wc;
  1182                        ;
  1183                        ;	hs = (WCHAR)(chr >> 16);
  1184                        ;	wc = (WCHAR)chr;
  1185                        ;	if (hs == 0) {	/* Single encoding unit? */
  1186                        ;		if (szb < 1 || IsSurrogate(wc)) return 0
                    ;	/* Buffer overflow or wrong code? */
  1187                        ;		*buf = wc;
  1188                        ;		return 1;
  1189                        ;	}
  1190                        ;	if (szb < 2 || !IsSurrogateH(hs) || !IsSurrogate
                    L(wc)) return 0;	/* Buffer overflow or wrong surrogate? *
                    /
  Thu May 20 2021 21:37                                                Page 32


  1191                        ;	*buf++ = hs;
  1192                        ;	*buf++ = wc;
  1193                        ;	return 2;
  1194                        ;
  1195                        ;#elif FF_LFN_UNICODE == 2	/* UTF-8 output 
                    */
  1196                        ;	DWORD hc;
  1197                        ;
  1198                        ;	if (chr < 0x80) {	/* Single byte code? */
  1199                        ;		if (szb < 1) return 0;	/* Buffer overfl
                    ow? */
  1200                        ;		*buf = (TCHAR)chr;
  1201                        ;		return 1;
  1202                        ;	}
  1203                        ;	if (chr < 0x800) {	/* 2-byte sequence? */
  1204                        ;		if (szb < 2) return 0;	/* Buffer overfl
                    ow? */
  1205                        ;		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F
                    ));
  1206                        ;		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F
                    ));
  1207                        ;		return 2;
  1208                        ;	}
  1209                        ;	if (chr < 0x10000) {	/* 3-byte sequence? */
  1210                        ;		if (szb < 3 || IsSurrogate(chr)) return 
                    0;	/* Buffer overflow or wrong code? */
  1211                        ;		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0
                    F));
  1212                        ;		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F
                    ));
  1213                        ;		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F
                    ));
  1214                        ;		return 3;
  1215                        ;	}
  1216                        ;	/* 4-byte sequence */
  1217                        ;	if (szb < 4) return 0;	/* Buffer overflow? */
  1218                        ;	hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	
                    /* Get high 10 bits */
  1219                        ;	chr = (chr & 0xFFFF) - 0xDC00;			
                    		/* Get low 10 bits */
  1220                        ;	if (hc >= 0x100000 || chr >= 0x400) return 0;	
                    /* Wrong surrogate? */
  1221                        ;	chr = (hc | chr) + 0x10000;
  1222                        ;	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
  1223                        ;	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
  1224                        ;	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
  1225                        ;	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
  1226                        ;	return 4;
  1227                        ;
  1228                        ;#elif FF_LFN_UNICODE == 3	/* UTF-32 output
                     */
  1229                        ;	DWORD hc;
  1230                        ;
  1231                        ;	if (szb < 1) return 0;	/* Buffer overflow? */
  1232                        ;	if (chr >= 0x10000) {	/* Out of BMP? */
  1233                        ;		hc = ((chr & 0xFFFF0000) - 0xD8000000) >
                    > 6;	/* Get high 10 bits */
  1234                        ;		chr = (chr & 0xFFFF) - 0xDC00;		
  Thu May 20 2021 21:37                                                Page 33


                    			/* Get low 10 bits */
  1235                        ;		if (hc >= 0x100000 || chr >= 0x400) retu
                    rn 0;	/* Wrong surrogate? */
  1236                        ;		chr = (hc | chr) + 0x10000;
  1237                        ;	}
  1238                        ;	*buf++ = (TCHAR)chr;
  1239                        ;	return 1;
  1240                        ;
  1241                        ;#else						
                    /* ANSI/OEM output */
  1242                        ;	WCHAR wc;
  1243                        ;
  1244                        ;	wc = ff_uni2oem(chr, CODEPAGE);
  1245                        ;	if (wc >= 0x100) {	/* Is this a DBC? */
  1246                        ;		if (szb < 2) return 0;
  1247                        ;		*buf++ = (char)(wc >> 8);	/* Store
                     DBC 1st byte */
  1248                        ;		*buf++ = (TCHAR)wc;			
                    /* Store DBC 2nd byte */
  1249                        ;		return 2;
  1250                        ;	}
  1251                        ;	if (wc == 0 || szb < 1) return 0;	/* Inval
                    id char or buffer overflow? */
  1252                        ;	*buf++ = (TCHAR)wc;				
                    	/* Store the character */
  1253                        ;	return 1;
  1254                        ;#endif
  1255                        ;}
  1256                        ;#endif	/* FF_USE_LFN */
  1257                        ;
  1258                        ;
  1259                        ;#if FF_FS_REENTRANT
  1260                        ;/*-----------------------------------------------
                    ------------------------*/
  1261                        ;/* Request/Release grant to access the volume    
                                            */
  1262                        ;/*-----------------------------------------------
                    ------------------------*/
  1263                        ;static int lock_fs (		/* 1:Ok, 0:timeo
                    ut */
  1264                        ;	FATFS* fs		/* Filesystem object */
  1265                        ;)
  1266                        ;{
  1267                        ;	return ff_req_grant(fs->sobj);
  1268                        ;}
  1269                        ;
  1270                        ;
  1271                        ;static void unlock_fs (
  1272                        ;	FATFS* fs,		/* Filesystem object */
  1273                        ;	FRESULT res		/* Result code to be ret
                    urned */
  1274                        ;)
  1275                        ;{
  1276                        ;	if (fs && res != FR_NOT_ENABLED && res != FR_INV
                    ALID_DRIVE && res != FR_TIMEOUT) {
  1277                        ;		ff_rel_grant(fs->sobj);
  1278                        ;	}
  1279                        ;}
  Thu May 20 2021 21:37                                                Page 34


  1280                        ;
  1281                        ;#endif
  1282                        ;
  1283                        ;
  1284                        ;
  1285                        ;#if FF_FS_LOCK != 0
  1286                        ;/*-----------------------------------------------
                    ------------------------*/
  1287                        ;/* File lock control functions                   
                                            */
  1288                        ;/*-----------------------------------------------
                    ------------------------*/
  1289                        ;
  1290                        ;static FRESULT chk_lock (	/* Check if the 
                    file can be accessed */
  1291                        ;	DIR* dp,		/* Directory object poin
                    ting the file to be checked */
  1292                        ;	int acc			/* Desired access type (
                    0:Read mode open, 1:Write mode open, 2:Delete or rename) */
  1293                        ;)
  1294                        ;{
  1295                        ;	UINT i, be;
  1296                        ;
  1297                        ;	/* Search open object table for the object */
  1298                        ;	be = 0;
  1299                        ;	for (i = 0; i < FF_FS_LOCK; i++) {
  1300                        ;		if (Files[i].fs) {	/* Existing entr
                    y */
  1301                        ;			if (Files[i].fs == dp->obj.fs &&
                    	 	/* Check if the object matches with an open obje
                    ct */
  1302                        ;				Files[i].clu == dp->obj.
                    sclust &&
  1303                        ;				Files[i].ofs == dp->dptr
                    ) break;
  1304                        ;		} else {			/* Blank
                     entry */
  1305                        ;			be = 1;
  1306                        ;		}
  1307                        ;	}
  1308                        ;	if (i == FF_FS_LOCK) {	/* The object has not be
                    en opened */
  1309                        ;		return (!be && acc != 2) ? FR_TOO_MANY_O
                    PEN_FILES : FR_OK;	/* Is there a blank entry for new object
                    ? */
  1310                        ;	}
  1311                        ;
  1312                        ;	/* The object was opened. Reject any open agains
                    t writing file and all write mode open */
  1313                        ;	return (acc != 0 || Files[i].ctr == 0x100) ? FR_
                    LOCKED : FR_OK;
  1314                        ;}
  1315                        ;
  1316                        ;
  1317                        ;static int enq_lock (void)	/* Check if an e
                    ntry is available for a new object */
  1318                        ;{
  1319                        ;	UINT i;
  Thu May 20 2021 21:37                                                Page 35


  1320                        ;
  1321                        ;	for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) 
                    ;
  1322                        ;	return (i == FF_FS_LOCK) ? 0 : 1;
  1323                        ;}
  1324                        ;
  1325                        ;
  1326                        ;static UINT inc_lock (	/* Increment object open
                     counter and returns its index (0:Internal error) */
  1327                        ;	DIR* dp,	/* Directory object pointing the
                     file to register or increment */
  1328                        ;	int acc		/* Desired access (0:Read, 1:Wri
                    te, 2:Delete/Rename) */
  1329                        ;)
  1330                        ;{
  1331                        ;	UINT i;
  1332                        ;
  1333                        ;
  1334                        ;	for (i = 0; i < FF_FS_LOCK; i++) {	/* Find 
                    the object */
  1335                        ;		if (Files[i].fs == dp->obj.fs
  1336                        ;		 && Files[i].clu == dp->obj.sclust
  1337                        ;		 && Files[i].ofs == dp->dptr) break;
  1338                        ;	}
  1339                        ;
  1340                        ;	if (i == FF_FS_LOCK) {			/* Not o
                    pened. Register it as new. */
  1341                        ;		for (i = 0; i < FF_FS_LOCK && Files[i].f
                    s; i++) ;
  1342                        ;		if (i == FF_FS_LOCK) return 0;	/* No fr
                    ee entry to register (int err) */
  1343                        ;		Files[i].fs = dp->obj.fs;
  1344                        ;		Files[i].clu = dp->obj.sclust;
  1345                        ;		Files[i].ofs = dp->dptr;
  1346                        ;		Files[i].ctr = 0;
  1347                        ;	}
  1348                        ;
  1349                        ;	if (acc >= 1 && Files[i].ctr) return 0;	/* Acces
                    s violation (int err) */
  1350                        ;
  1351                        ;	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	
                    /* Set semaphore value */
  1352                        ;
  1353                        ;	return i + 1;	/* Index number origin from 1 */
  1354                        ;}
  1355                        ;
  1356                        ;
  1357                        ;static FRESULT dec_lock (	/* Decrement obj
                    ect open counter */
  1358                        ;	UINT i			/* Semaphore index (1..)
                     */
  1359                        ;)
  1360                        ;{
  1361                        ;	WORD n;
  1362                        ;	FRESULT res;
  1363                        ;
  1364                        ;
  1365                        ;	if (--i < FF_FS_LOCK) {	/* Index number origin f
  Thu May 20 2021 21:37                                                Page 36


                    rom 0 */
  1366                        ;		n = Files[i].ctr;
  1367                        ;		if (n == 0x100) n = 0;	/* If write mode
                     open, delete the entry */
  1368                        ;		if (n > 0) n--;			/* Decre
                    ment read mode open count */
  1369                        ;		Files[i].ctr = n;
  1370                        ;		if (n == 0) Files[i].fs = 0;	/* Delet
                    e the entry if open count gets zero */
  1371                        ;		res = FR_OK;
  1372                        ;	} else {
  1373                        ;		res = FR_INT_ERR;		/* Inval
                    id index nunber */
  1374                        ;	}
  1375                        ;	return res;
  1376                        ;}
  1377                        ;
  1378                        ;
  1379                        ;static void clear_lock (	/* Clear lock entries of
                     the volume */
  1380                        ;	FATFS *fs
  1381                        ;)
  1382                        ;{
  1383                        ;	UINT i;
  1384                        ;
  1385                        ;	for (i = 0; i < FF_FS_LOCK; i++) {
  1386                        ;		if (Files[i].fs == fs) Files[i].fs = 0;
  1387                        ;	}
  1388                        ;}
  1389                        ;
  1390                        ;#endif	/* FF_FS_LOCK != 0 */
  1391                        ;
  1392                        ;
  1393                        ;
  1394                        ;/*-----------------------------------------------
                    ------------------------*/
  1395                        ;/* Move/Flush disk access window in the filesyste
                    m object                */
  1396                        ;/*-----------------------------------------------
                    ------------------------*/
  1397                        ;#if !FF_FS_READONLY
  1398                        ;static FRESULT sync_window (	/* Returns FR_OK
                     or FR_DISK_ERR */
  1399                        ;	FATFS* fs			/* Filesystem ob
                    ject */
  1400                        ;)
  1401                        ;{
  1402                        	code
  1403                        	func
  1404                        ~~sync_window:
  1405                        	longa	on
  1406                        	longi	on
  1407 00:01EA: 3B           	tsc
  1408 00:01EB: 38           	sec
  1409 00:01EC: E9 0A 00     	sbc	#L28
  1410 00:01EF: 1B           	tcs
  1411 00:01F0: 0B           	phd
  1412 00:01F1: 5B           	tcd
  Thu May 20 2021 21:37                                                Page 37


  1413             00000004   fs_0	set	4
  1414                        ;	FRESULT res = FR_OK;
  1415                        ;
  1416                        ;
  1417                        ;	if (fs->wflag) {	/* Is the disk access wi
                    ndow dirty? */
  1418             00000000   res_1	set	0
  1419 00:01F2: 64 09        	stz	<L29+res_1
  1420 00:01F4: A0 03 00     	ldy	#$3
  1421 00:01F7: B7 0E        	lda	[<L28+fs_0],Y
  1422 00:01F9: 29 FF 00     	and	#$ff
  1423 00:01FC: D0 03        	bne	L30
  1424 00:01FE: 82 BE 00     	brl	L10003
  1425                        L30:
  1426                        ;		if (disk_write(fs->pdrv, fs->win, fs->wi
                    nsect, 1) == RES_OK) {	/* Write it back into the volume
                     */
  1427 00:0201: F4 01 00     	pea	#<$1
  1428 00:0204: A0 2D 00     	ldy	#$2d
  1429 00:0207: B7 0E        	lda	[<L28+fs_0],Y
  1430 00:0209: 48           	pha
  1431 00:020A: A0 2B 00     	ldy	#$2b
  1432 00:020D: B7 0E        	lda	[<L28+fs_0],Y
  1433 00:020F: 48           	pha
  1434 00:0210: 18           	clc
  1435 00:0211: A9 2F 00     	lda	#$2f
  1436 00:0214: 65 0E        	adc	<L28+fs_0
  1437 00:0216: 85 01        	sta	<R0
  1438 00:0218: A9 00 00     	lda	#$0
  1439 00:021B: 65 10        	adc	<L28+fs_0+2
  1440 00:021D: 85 03        	sta	<R0+2
  1441 00:021F: D4 03        	pei	<R0+2
  1442 00:0221: D4 01        	pei	<R0
  1443 00:0223: A0 01 00     	ldy	#$1
  1444 00:0226: B7 0E        	lda	[<L28+fs_0],Y
  1445 00:0228: 48           	pha
  1446 00:0229: 22 xx xx xx  	jsl	~~disk_write
  1447 00:022D: AA           	tax
  1448 00:022E: F0 03        	beq	L31
  1449 00:0230: 82 87 00     	brl	L10004
  1450                        L31:
  1451                        ;			fs->wflag = 0;	/* Clear window 
                    dirty flag */
  1452 00:0233: E2 20        	sep	#$20
  1453                        	longa	off
  1454 00:0235: A9 00        	lda	#$0
  1455 00:0237: A0 03 00     	ldy	#$3
  1456 00:023A: 97 0E        	sta	[<L28+fs_0],Y
  1457 00:023C: C2 20        	rep	#$20
  1458                        	longa	on
  1459                        ;			if (fs->winsect - fs->fatbase < 
                    fs->fsize) {	/* Is it in the 1st FAT? */
  1460 00:023E: 38           	sec
  1461 00:023F: A0 2B 00     	ldy	#$2b
  1462 00:0242: B7 0E        	lda	[<L28+fs_0],Y
  1463 00:0244: A0 1F 00     	ldy	#$1f
  1464 00:0247: F7 0E        	sbc	[<L28+fs_0],Y
  1465 00:0249: 85 01        	sta	<R0
  Thu May 20 2021 21:37                                                Page 38


  1466 00:024B: A0 2D 00     	ldy	#$2d
  1467 00:024E: B7 0E        	lda	[<L28+fs_0],Y
  1468 00:0250: A0 21 00     	ldy	#$21
  1469 00:0253: F7 0E        	sbc	[<L28+fs_0],Y
  1470 00:0255: 85 03        	sta	<R0+2
  1471 00:0257: A5 01        	lda	<R0
  1472 00:0259: A0 17 00     	ldy	#$17
  1473 00:025C: D7 0E        	cmp	[<L28+fs_0],Y
  1474 00:025E: A5 03        	lda	<R0+2
  1475 00:0260: A0 19 00     	ldy	#$19
  1476 00:0263: F7 0E        	sbc	[<L28+fs_0],Y
  1477 00:0265: 90 03        	bcc	L32
  1478 00:0267: 82 4D 00     	brl	L10005
  1479                        L32:
  1480                        ;				if (fs->n_fats == 2) dis
                    k_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	
                    /* Reflect it to 2nd FAT if needed */
  1481 00:026A: E2 20        	sep	#$20
  1482                        	longa	off
  1483 00:026C: A0 02 00     	ldy	#$2
  1484 00:026F: B7 0E        	lda	[<L28+fs_0],Y
  1485 00:0271: C9 02        	cmp	#<$2
  1486 00:0273: C2 20        	rep	#$20
  1487                        	longa	on
  1488 00:0275: F0 03        	beq	L33
  1489 00:0277: 82 3D 00     	brl	L10006
  1490                        L33:
  1491 00:027A: F4 01 00     	pea	#<$1
  1492 00:027D: 18           	clc
  1493 00:027E: A0 2B 00     	ldy	#$2b
  1494 00:0281: B7 0E        	lda	[<L28+fs_0],Y
  1495 00:0283: A0 17 00     	ldy	#$17
  1496 00:0286: 77 0E        	adc	[<L28+fs_0],Y
  1497 00:0288: 85 01        	sta	<R0
  1498 00:028A: A0 2D 00     	ldy	#$2d
  1499 00:028D: B7 0E        	lda	[<L28+fs_0],Y
  1500 00:028F: A0 19 00     	ldy	#$19
  1501 00:0292: 77 0E        	adc	[<L28+fs_0],Y
  1502 00:0294: 85 03        	sta	<R0+2
  1503 00:0296: D4 03        	pei	<R0+2
  1504 00:0298: D4 01        	pei	<R0
  1505 00:029A: 18           	clc
  1506 00:029B: A9 2F 00     	lda	#$2f
  1507 00:029E: 65 0E        	adc	<L28+fs_0
  1508 00:02A0: 85 05        	sta	<R1
  1509 00:02A2: A9 00 00     	lda	#$0
  1510 00:02A5: 65 10        	adc	<L28+fs_0+2
  1511 00:02A7: 85 07        	sta	<R1+2
  1512 00:02A9: D4 07        	pei	<R1+2
  1513 00:02AB: D4 05        	pei	<R1
  1514 00:02AD: A0 01 00     	ldy	#$1
  1515 00:02B0: B7 0E        	lda	[<L28+fs_0],Y
  1516 00:02B2: 48           	pha
  1517 00:02B3: 22 xx xx xx  	jsl	~~disk_write
  1518                        ;			}
  1519                        L10006:
  1520                        ;		} else {
  1521                        L10005:
  Thu May 20 2021 21:37                                                Page 39


  1522 00:02B7: 82 05 00     	brl	L10007
  1523                        L10004:
  1524                        ;			res = FR_DISK_ERR;
  1525 00:02BA: A9 01 00     	lda	#$1
  1526 00:02BD: 85 09        	sta	<L29+res_1
  1527                        ;		}
  1528                        L10007:
  1529                        ;	}
  1530                        ;	return res;
  1531                        L10003:
  1532 00:02BF: A5 09        	lda	<L29+res_1
  1533                        L34:
  1534 00:02C1: A8           	tay
  1535 00:02C2: A5 0C        	lda	<L28+2
  1536 00:02C4: 85 10        	sta	<L28+2+4
  1537 00:02C6: A5 0B        	lda	<L28+1
  1538 00:02C8: 85 0F        	sta	<L28+1+4
  1539 00:02CA: 2B           	pld
  1540 00:02CB: 3B           	tsc
  1541 00:02CC: 18           	clc
  1542 00:02CD: 69 0E 00     	adc	#L28+4
  1543 00:02D0: 1B           	tcs
  1544 00:02D1: 98           	tya
  1545 00:02D2: 6B           	rtl
  1546                        ;}
  1547             0000000A   L28	equ	10
  1548             00000009   L29	equ	9
  1549                        	ends
  1550                        	efunc
  1551                        ;#endif
  1552                        ;
  1553                        ;
  1554                        ;static FRESULT move_window (	/* Returns FR_OK
                     or FR_DISK_ERR */
  1555                        ;	FATFS* fs,		/* Filesystem object */
  1556                        ;	LBA_t sect		/* Sector LBA to make ap
                    pearance in the fs->win[] */
  1557                        ;)
  1558                        ;{
  1559                        	code
  1560                        	func
  1561                        ~~move_window:
  1562                        	longa	on
  1563                        	longi	on
  1564 00:02D3: 3B           	tsc
  1565 00:02D4: 38           	sec
  1566 00:02D5: E9 06 00     	sbc	#L35
  1567 00:02D8: 1B           	tcs
  1568 00:02D9: 0B           	phd
  1569 00:02DA: 5B           	tcd
  1570             00000004   fs_0	set	4
  1571             00000008   sect_0	set	8
  1572                        ;	FRESULT res = FR_OK;
  1573                        ;
  1574                        ;
  1575                        ;	if (sect != fs->winsect) {	/* Window offset
                     changed? */
  1576             00000000   res_1	set	0
  Thu May 20 2021 21:37                                                Page 40


  1577 00:02DB: 64 05        	stz	<L36+res_1
  1578 00:02DD: A5 0E        	lda	<L35+sect_0
  1579 00:02DF: A0 2B 00     	ldy	#$2b
  1580 00:02E2: D7 0A        	cmp	[<L35+fs_0],Y
  1581 00:02E4: D0 07        	bne	L37
  1582 00:02E6: A5 10        	lda	<L35+sect_0+2
  1583 00:02E8: A0 2D 00     	ldy	#$2d
  1584 00:02EB: D7 0A        	cmp	[<L35+fs_0],Y
  1585                        L37:
  1586 00:02ED: D0 03        	bne	L38
  1587 00:02EF: 82 58 00     	brl	L10008
  1588                        L38:
  1589                        ;#if !FF_FS_READONLY
  1590                        ;		res = sync_window(fs);		/* Flush
                     the window */
  1591 00:02F2: D4 0C        	pei	<L35+fs_0+2
  1592 00:02F4: D4 0A        	pei	<L35+fs_0
  1593 00:02F6: 22 xx xx xx  	jsl	~~sync_window
  1594 00:02FA: 85 05        	sta	<L36+res_1
  1595                        ;#endif
  1596                        ;		if (res == FR_OK) {			
                    /* Fill sector window with new data */
  1597 00:02FC: A5 05        	lda	<L36+res_1
  1598 00:02FE: F0 03        	beq	L39
  1599 00:0300: 82 47 00     	brl	L10009
  1600                        L39:
  1601                        ;			if (disk_read(fs->pdrv, fs->win,
                     sect, 1) != RES_OK) {
  1602 00:0303: F4 01 00     	pea	#<$1
  1603 00:0306: D4 10        	pei	<L35+sect_0+2
  1604 00:0308: D4 0E        	pei	<L35+sect_0
  1605 00:030A: 18           	clc
  1606 00:030B: A9 2F 00     	lda	#$2f
  1607 00:030E: 65 0A        	adc	<L35+fs_0
  1608 00:0310: 85 01        	sta	<R0
  1609 00:0312: A9 00 00     	lda	#$0
  1610 00:0315: 65 0C        	adc	<L35+fs_0+2
  1611 00:0317: 85 03        	sta	<R0+2
  1612 00:0319: D4 03        	pei	<R0+2
  1613 00:031B: D4 01        	pei	<R0
  1614 00:031D: A0 01 00     	ldy	#$1
  1615 00:0320: B7 0A        	lda	[<L35+fs_0],Y
  1616 00:0322: 48           	pha
  1617 00:0323: 22 xx xx xx  	jsl	~~disk_read
  1618 00:0327: AA           	tax
  1619 00:0328: D0 03        	bne	L40
  1620 00:032A: 82 0F 00     	brl	L10010
  1621                        L40:
  1622                        ;				sect = (LBA_t)0 - 1;	
                    /* Invalidate window if read data is not valid */
  1623 00:032D: A9 FF FF     	lda	#$ffff
  1624 00:0330: 85 0E        	sta	<L35+sect_0
  1625 00:0332: A9 FF FF     	lda	#$ffff
  1626 00:0335: 85 10        	sta	<L35+sect_0+2
  1627                        ;				res = FR_DISK_ERR;
  1628 00:0337: A9 01 00     	lda	#$1
  1629 00:033A: 85 05        	sta	<L36+res_1
  1630                        ;			}
  Thu May 20 2021 21:37                                                Page 41


  1631                        ;			fs->winsect = sect;
  1632                        L10010:
  1633 00:033C: A5 0E        	lda	<L35+sect_0
  1634 00:033E: A0 2B 00     	ldy	#$2b
  1635 00:0341: 97 0A        	sta	[<L35+fs_0],Y
  1636 00:0343: A5 10        	lda	<L35+sect_0+2
  1637 00:0345: A0 2D 00     	ldy	#$2d
  1638 00:0348: 97 0A        	sta	[<L35+fs_0],Y
  1639                        ;		}
  1640                        ;	}
  1641                        L10009:
  1642                        ;	return res;
  1643                        L10008:
  1644 00:034A: A5 05        	lda	<L36+res_1
  1645                        L41:
  1646 00:034C: A8           	tay
  1647 00:034D: A5 08        	lda	<L35+2
  1648 00:034F: 85 10        	sta	<L35+2+8
  1649 00:0351: A5 07        	lda	<L35+1
  1650 00:0353: 85 0F        	sta	<L35+1+8
  1651 00:0355: 2B           	pld
  1652 00:0356: 3B           	tsc
  1653 00:0357: 18           	clc
  1654 00:0358: 69 0E 00     	adc	#L35+8
  1655 00:035B: 1B           	tcs
  1656 00:035C: 98           	tya
  1657 00:035D: 6B           	rtl
  1658                        ;}
  1659             00000006   L35	equ	6
  1660             00000005   L36	equ	5
  1661                        	ends
  1662                        	efunc
  1663                        ;
  1664                        ;
  1665                        ;
  1666                        ;
  1667                        ;#if !FF_FS_READONLY
  1668                        ;/*-----------------------------------------------
                    ------------------------*/
  1669                        ;/* Synchronize filesystem and data on the storage
                                            */
  1670                        ;/*-----------------------------------------------
                    ------------------------*/
  1671                        ;
  1672                        ;static FRESULT sync_fs (	/* Returns FR_OK or FR_D
                    ISK_ERR */
  1673                        ;	FATFS* fs		/* Filesystem object */
  1674                        ;)
  1675                        ;{
  1676                        	code
  1677                        	func
  1678                        ~~sync_fs:
  1679                        	longa	on
  1680                        	longi	on
  1681 00:035E: 3B           	tsc
  1682 00:035F: 38           	sec
  1683 00:0360: E9 06 00     	sbc	#L42
  1684 00:0363: 1B           	tcs
  Thu May 20 2021 21:37                                                Page 42


  1685 00:0364: 0B           	phd
  1686 00:0365: 5B           	tcd
  1687             00000004   fs_0	set	4
  1688                        ;	FRESULT res;
  1689                        ;
  1690                        ;
  1691                        ;	res = sync_window(fs);
  1692             00000000   res_1	set	0
  1693 00:0366: D4 0C        	pei	<L42+fs_0+2
  1694 00:0368: D4 0A        	pei	<L42+fs_0
  1695 00:036A: 22 xx xx xx  	jsl	~~sync_window
  1696 00:036E: 85 05        	sta	<L43+res_1
  1697                        ;	if (res == FR_OK) {
  1698 00:0370: A5 05        	lda	<L43+res_1
  1699 00:0372: F0 03        	beq	L44
  1700 00:0374: 82 4C 01     	brl	L10011
  1701                        L44:
  1702                        ;		if (fs->fs_type == FS_FAT32 && fs->fsi_f
                    lag == 1) {	/* FAT32: Update FSInfo sector if needed */
  1703 00:0377: E2 20        	sep	#$20
  1704                        	longa	off
  1705 00:0379: A7 0A        	lda	[<L42+fs_0]
  1706 00:037B: C9 03        	cmp	#<$3
  1707 00:037D: C2 20        	rep	#$20
  1708                        	longa	on
  1709 00:037F: F0 03        	beq	L45
  1710 00:0381: 82 21 01     	brl	L10012
  1711                        L45:
  1712 00:0384: E2 20        	sep	#$20
  1713                        	longa	off
  1714 00:0386: A0 04 00     	ldy	#$4
  1715 00:0389: B7 0A        	lda	[<L42+fs_0],Y
  1716 00:038B: C9 01        	cmp	#<$1
  1717 00:038D: C2 20        	rep	#$20
  1718                        	longa	on
  1719 00:038F: F0 03        	beq	L46
  1720 00:0391: 82 11 01     	brl	L10012
  1721                        L46:
  1722                        ;			/* Create FSInfo structure */
  1723                        ;			memset(fs->win, 0, sizeof fs->wi
                    n);
  1724 00:0394: F4 00 02     	pea	#<$200
  1725 00:0397: F4 00 00     	pea	#<$0
  1726 00:039A: 18           	clc
  1727 00:039B: A9 2F 00     	lda	#$2f
  1728 00:039E: 65 0A        	adc	<L42+fs_0
  1729 00:03A0: 85 01        	sta	<R0
  1730 00:03A2: A9 00 00     	lda	#$0
  1731 00:03A5: 65 0C        	adc	<L42+fs_0+2
  1732 00:03A7: 85 03        	sta	<R0+2
  1733 00:03A9: D4 03        	pei	<R0+2
  1734 00:03AB: D4 01        	pei	<R0
  1735 00:03AD: 22 xx xx xx  	jsl	~~memset
  1736                        ;			st_word(fs->win + BS_55AA, 0xAA5
                    5);					/* Boot signature */
  1737 00:03B1: F4 55 AA     	pea	#<$aa55
  1738 00:03B4: 18           	clc
  1739 00:03B5: A9 2D 02     	lda	#$22d
  Thu May 20 2021 21:37                                                Page 43


  1740 00:03B8: 65 0A        	adc	<L42+fs_0
  1741 00:03BA: 85 01        	sta	<R0
  1742 00:03BC: A9 00 00     	lda	#$0
  1743 00:03BF: 65 0C        	adc	<L42+fs_0+2
  1744 00:03C1: 85 03        	sta	<R0+2
  1745 00:03C3: D4 03        	pei	<R0+2
  1746 00:03C5: D4 01        	pei	<R0
  1747 00:03C7: 22 xx xx xx  	jsl	~~st_word
  1748                        ;			st_dword(fs->win + FSI_LeadSig, 
                    0x41615252);		/* Leading signature */
  1749 00:03CB: F4 61 41     	pea	#^$41615252
  1750 00:03CE: F4 52 52     	pea	#<$41615252
  1751 00:03D1: 18           	clc
  1752 00:03D2: A9 2F 00     	lda	#$2f
  1753 00:03D5: 65 0A        	adc	<L42+fs_0
  1754 00:03D7: 85 01        	sta	<R0
  1755 00:03D9: A9 00 00     	lda	#$0
  1756 00:03DC: 65 0C        	adc	<L42+fs_0+2
  1757 00:03DE: 85 03        	sta	<R0+2
  1758 00:03E0: D4 03        	pei	<R0+2
  1759 00:03E2: D4 01        	pei	<R0
  1760 00:03E4: 22 xx xx xx  	jsl	~~st_dword
  1761                        ;			st_dword(fs->win + FSI_StrucSig,
                     0x61417272);		/* Structure signature */
  1762 00:03E8: F4 41 61     	pea	#^$61417272
  1763 00:03EB: F4 72 72     	pea	#<$61417272
  1764 00:03EE: 18           	clc
  1765 00:03EF: A9 13 02     	lda	#$213
  1766 00:03F2: 65 0A        	adc	<L42+fs_0
  1767 00:03F4: 85 01        	sta	<R0
  1768 00:03F6: A9 00 00     	lda	#$0
  1769 00:03F9: 65 0C        	adc	<L42+fs_0+2
  1770 00:03FB: 85 03        	sta	<R0+2
  1771 00:03FD: D4 03        	pei	<R0+2
  1772 00:03FF: D4 01        	pei	<R0
  1773 00:0401: 22 xx xx xx  	jsl	~~st_dword
  1774                        ;			st_dword(fs->win + FSI_Free_Coun
                    t, fs->free_clst);	/* Number of free clusters */
  1775 00:0405: A0 11 00     	ldy	#$11
  1776 00:0408: B7 0A        	lda	[<L42+fs_0],Y
  1777 00:040A: 48           	pha
  1778 00:040B: A0 0F 00     	ldy	#$f
  1779 00:040E: B7 0A        	lda	[<L42+fs_0],Y
  1780 00:0410: 48           	pha
  1781 00:0411: 18           	clc
  1782 00:0412: A9 17 02     	lda	#$217
  1783 00:0415: 65 0A        	adc	<L42+fs_0
  1784 00:0417: 85 01        	sta	<R0
  1785 00:0419: A9 00 00     	lda	#$0
  1786 00:041C: 65 0C        	adc	<L42+fs_0+2
  1787 00:041E: 85 03        	sta	<R0+2
  1788 00:0420: D4 03        	pei	<R0+2
  1789 00:0422: D4 01        	pei	<R0
  1790 00:0424: 22 xx xx xx  	jsl	~~st_dword
  1791                        ;			st_dword(fs->win + FSI_Nxt_Free,
                     fs->last_clst);	/* Last allocated culuster */
  1792 00:0428: A0 0D 00     	ldy	#$d
  1793 00:042B: B7 0A        	lda	[<L42+fs_0],Y
  Thu May 20 2021 21:37                                                Page 44


  1794 00:042D: 48           	pha
  1795 00:042E: A0 0B 00     	ldy	#$b
  1796 00:0431: B7 0A        	lda	[<L42+fs_0],Y
  1797 00:0433: 48           	pha
  1798 00:0434: 18           	clc
  1799 00:0435: A9 1B 02     	lda	#$21b
  1800 00:0438: 65 0A        	adc	<L42+fs_0
  1801 00:043A: 85 01        	sta	<R0
  1802 00:043C: A9 00 00     	lda	#$0
  1803 00:043F: 65 0C        	adc	<L42+fs_0+2
  1804 00:0441: 85 03        	sta	<R0+2
  1805 00:0443: D4 03        	pei	<R0+2
  1806 00:0445: D4 01        	pei	<R0
  1807 00:0447: 22 xx xx xx  	jsl	~~st_dword
  1808                        ;			fs->winsect = fs->volbase + 1;	
                    					/* Write it into the FSI
                    nfo sector (Next to VBR) */
  1809 00:044B: 18           	clc
  1810 00:044C: A9 01 00     	lda	#$1
  1811 00:044F: A0 1B 00     	ldy	#$1b
  1812 00:0452: 77 0A        	adc	[<L42+fs_0],Y
  1813 00:0454: 85 01        	sta	<R0
  1814 00:0456: A9 00 00     	lda	#$0
  1815 00:0459: A0 1D 00     	ldy	#$1d
  1816 00:045C: 77 0A        	adc	[<L42+fs_0],Y
  1817 00:045E: 85 03        	sta	<R0+2
  1818 00:0460: A5 01        	lda	<R0
  1819 00:0462: A0 2B 00     	ldy	#$2b
  1820 00:0465: 97 0A        	sta	[<L42+fs_0],Y
  1821 00:0467: A5 03        	lda	<R0+2
  1822 00:0469: A0 2D 00     	ldy	#$2d
  1823 00:046C: 97 0A        	sta	[<L42+fs_0],Y
  1824                        ;			disk_write(fs->pdrv, fs->win, fs
                    ->winsect, 1);
  1825 00:046E: F4 01 00     	pea	#<$1
  1826 00:0471: A0 2D 00     	ldy	#$2d
  1827 00:0474: B7 0A        	lda	[<L42+fs_0],Y
  1828 00:0476: 48           	pha
  1829 00:0477: A0 2B 00     	ldy	#$2b
  1830 00:047A: B7 0A        	lda	[<L42+fs_0],Y
  1831 00:047C: 48           	pha
  1832 00:047D: 18           	clc
  1833 00:047E: A9 2F 00     	lda	#$2f
  1834 00:0481: 65 0A        	adc	<L42+fs_0
  1835 00:0483: 85 01        	sta	<R0
  1836 00:0485: A9 00 00     	lda	#$0
  1837 00:0488: 65 0C        	adc	<L42+fs_0+2
  1838 00:048A: 85 03        	sta	<R0+2
  1839 00:048C: D4 03        	pei	<R0+2
  1840 00:048E: D4 01        	pei	<R0
  1841 00:0490: A0 01 00     	ldy	#$1
  1842 00:0493: B7 0A        	lda	[<L42+fs_0],Y
  1843 00:0495: 48           	pha
  1844 00:0496: 22 xx xx xx  	jsl	~~disk_write
  1845                        ;			fs->fsi_flag = 0;
  1846 00:049A: E2 20        	sep	#$20
  1847                        	longa	off
  1848 00:049C: A9 00        	lda	#$0
  Thu May 20 2021 21:37                                                Page 45


  1849 00:049E: A0 04 00     	ldy	#$4
  1850 00:04A1: 97 0A        	sta	[<L42+fs_0],Y
  1851 00:04A3: C2 20        	rep	#$20
  1852                        	longa	on
  1853                        ;		}
  1854                        ;		/* Make sure that no pending write proce
                    ss in the lower layer */
  1855                        ;		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) !
                    = RES_OK) res = FR_DISK_ERR;
  1856                        L10012:
  1857 00:04A5: F4 00 00     	pea	#^$0
  1858 00:04A8: F4 00 00     	pea	#<$0
  1859 00:04AB: F4 00 00     	pea	#<$0
  1860 00:04AE: A0 01 00     	ldy	#$1
  1861 00:04B1: B7 0A        	lda	[<L42+fs_0],Y
  1862 00:04B3: 48           	pha
  1863 00:04B4: 22 xx xx xx  	jsl	~~disk_ioctl
  1864 00:04B8: AA           	tax
  1865 00:04B9: D0 03        	bne	L47
  1866 00:04BB: 82 05 00     	brl	L10013
  1867                        L47:
  1868 00:04BE: A9 01 00     	lda	#$1
  1869 00:04C1: 85 05        	sta	<L43+res_1
  1870                        ;	}
  1871                        L10013:
  1872                        ;
  1873                        ;	return res;
  1874                        L10011:
  1875 00:04C3: A5 05        	lda	<L43+res_1
  1876                        L48:
  1877 00:04C5: A8           	tay
  1878 00:04C6: A5 08        	lda	<L42+2
  1879 00:04C8: 85 0C        	sta	<L42+2+4
  1880 00:04CA: A5 07        	lda	<L42+1
  1881 00:04CC: 85 0B        	sta	<L42+1+4
  1882 00:04CE: 2B           	pld
  1883 00:04CF: 3B           	tsc
  1884 00:04D0: 18           	clc
  1885 00:04D1: 69 0A 00     	adc	#L42+4
  1886 00:04D4: 1B           	tcs
  1887 00:04D5: 98           	tya
  1888 00:04D6: 6B           	rtl
  1889                        ;}
  1890             00000006   L42	equ	6
  1891             00000005   L43	equ	5
  1892                        	ends
  1893                        	efunc
  1894                        ;
  1895                        ;#endif
  1896                        ;
  1897                        ;
  1898                        ;
  1899                        ;/*-----------------------------------------------
                    ------------------------*/
  1900                        ;/* Get physical sector number from cluster number
                                            */
  1901                        ;/*-----------------------------------------------
                    ------------------------*/
  Thu May 20 2021 21:37                                                Page 46


  1902                        ;
  1903                        ;static LBA_t clst2sect (	/* !=0:Sector number, 0:
                    Failed (invalid cluster#) */
  1904                        ;	FATFS* fs,		/* Filesystem object */
  1905                        ;	DWORD clst		/* Cluster# to be conver
                    ted */
  1906                        ;)
  1907                        ;{
  1908                        	code
  1909                        	func
  1910                        ~~clst2sect:
  1911                        	longa	on
  1912                        	longi	on
  1913 00:04D7: 3B           	tsc
  1914 00:04D8: 38           	sec
  1915 00:04D9: E9 08 00     	sbc	#L49
  1916 00:04DC: 1B           	tcs
  1917 00:04DD: 0B           	phd
  1918 00:04DE: 5B           	tcd
  1919             00000004   fs_0	set	4
  1920             00000008   clst_0	set	8
  1921                        ;	clst -= 2;		/* Cluster number is ori
                    gin from 2 */
  1922 00:04DF: 18           	clc
  1923 00:04E0: A9 FE FF     	lda	#$fffe
  1924 00:04E3: 65 10        	adc	<L49+clst_0
  1925 00:04E5: 85 10        	sta	<L49+clst_0
  1926 00:04E7: A9 FF FF     	lda	#$ffff
  1927 00:04EA: 65 12        	adc	<L49+clst_0+2
  1928 00:04EC: 85 12        	sta	<L49+clst_0+2
  1929                        ;	if (clst >= fs->n_fatent - 2) return 0;		
                    /* Is it invalid cluster number? */
  1930 00:04EE: 18           	clc
  1931 00:04EF: A9 FE FF     	lda	#$fffe
  1932 00:04F2: A0 13 00     	ldy	#$13
  1933 00:04F5: 77 0C        	adc	[<L49+fs_0],Y
  1934 00:04F7: 85 01        	sta	<R0
  1935 00:04F9: A9 FF FF     	lda	#$ffff
  1936 00:04FC: A0 15 00     	ldy	#$15
  1937 00:04FF: 77 0C        	adc	[<L49+fs_0],Y
  1938 00:0501: 85 03        	sta	<R0+2
  1939 00:0503: A5 10        	lda	<L49+clst_0
  1940 00:0505: C5 01        	cmp	<R0
  1941 00:0507: A5 12        	lda	<L49+clst_0+2
  1942 00:0509: E5 03        	sbc	<R0+2
  1943 00:050B: B0 03        	bcs	L51
  1944 00:050D: 82 19 00     	brl	L10014
  1945                        L51:
  1946 00:0510: A9 00 00     	lda	#$0
  1947 00:0513: AA           	tax
  1948 00:0514: A9 00 00     	lda	#$0
  1949                        L52:
  1950 00:0517: A8           	tay
  1951 00:0518: A5 0A        	lda	<L49+2
  1952 00:051A: 85 12        	sta	<L49+2+8
  1953 00:051C: A5 09        	lda	<L49+1
  1954 00:051E: 85 11        	sta	<L49+1+8
  1955 00:0520: 2B           	pld
  Thu May 20 2021 21:37                                                Page 47


  1956 00:0521: 3B           	tsc
  1957 00:0522: 18           	clc
  1958 00:0523: 69 10 00     	adc	#L49+8
  1959 00:0526: 1B           	tcs
  1960 00:0527: 98           	tya
  1961 00:0528: 6B           	rtl
  1962                        ;	return fs->database + (LBA_t)fs->csize * clst;	
                    /* Start sector number of the cluster */
  1963                        L10014:
  1964 00:0529: A0 09 00     	ldy	#$9
  1965 00:052C: B7 0C        	lda	[<L49+fs_0],Y
  1966 00:052E: 85 01        	sta	<R0
  1967 00:0530: 64 03        	stz	<R0+2
  1968 00:0532: D4 12        	pei	<L49+clst_0+2
  1969 00:0534: D4 10        	pei	<L49+clst_0
  1970 00:0536: D4 03        	pei	<R0+2
  1971 00:0538: D4 01        	pei	<R0
  1972                        	xref	~~~lmul
  1973 00:053A: 22 xx xx xx  	jsl	~~~lmul
  1974 00:053E: 85 01        	sta	<R0
  1975 00:0540: 86 03        	stx	<R0+2
  1976 00:0542: 18           	clc
  1977 00:0543: A5 01        	lda	<R0
  1978 00:0545: A0 27 00     	ldy	#$27
  1979 00:0548: 77 0C        	adc	[<L49+fs_0],Y
  1980 00:054A: 85 05        	sta	<R1
  1981 00:054C: A5 03        	lda	<R0+2
  1982 00:054E: A0 29 00     	ldy	#$29
  1983 00:0551: 77 0C        	adc	[<L49+fs_0],Y
  1984 00:0553: 85 07        	sta	<R1+2
  1985 00:0555: A6 07        	ldx	<R1+2
  1986 00:0557: A5 05        	lda	<R1
  1987 00:0559: 82 BB FF     	brl	L52
  1988                        ;}
  1989             00000008   L49	equ	8
  1990             00000009   L50	equ	9
  1991                        	ends
  1992                        	efunc
  1993                        ;
  1994                        ;
  1995                        ;
  1996                        ;
  1997                        ;/*-----------------------------------------------
                    ------------------------*/
  1998                        ;/* FAT access - Read value of an FAT entry       
                                            */
  1999                        ;/*-----------------------------------------------
                    ------------------------*/
  2000                        ;
  2001                        ;static DWORD get_fat (		/* 0xFFFFFFFF:Di
                    sk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
  2002                        ;	FFOBJID* obj,	/* Corresponding object */
  2003                        ;	DWORD clst		/* Cluster number to get
                     the value */
  2004                        ;)
  2005                        ;{
  2006                        	code
  2007                        	func
  Thu May 20 2021 21:37                                                Page 48


  2008                        ~~get_fat:
  2009                        	longa	on
  2010                        	longi	on
  2011 00:055C: 3B           	tsc
  2012 00:055D: 38           	sec
  2013 00:055E: E9 18 00     	sbc	#L53
  2014 00:0561: 1B           	tcs
  2015 00:0562: 0B           	phd
  2016 00:0563: 5B           	tcd
  2017             00000004   obj_0	set	4
  2018             00000008   clst_0	set	8
  2019                        ;	UINT wc, bc;
  2020                        ;	DWORD val;
  2021                        ;	FATFS *fs = obj->fs;
  2022                        ;
  2023                        ;
  2024                        ;	if (clst < 2 || clst >= fs->n_fatent) {	/* Check
                     if in valid range */
  2025             00000000   wc_1	set	0
  2026             00000002   bc_1	set	2
  2027             00000004   val_1	set	4
  2028             00000008   fs_1	set	8
  2029 00:0564: A7 1C        	lda	[<L53+obj_0]
  2030 00:0566: 85 15        	sta	<L54+fs_1
  2031 00:0568: A0 02 00     	ldy	#$2
  2032 00:056B: B7 1C        	lda	[<L53+obj_0],Y
  2033 00:056D: 85 17        	sta	<L54+fs_1+2
  2034 00:056F: A5 20        	lda	<L53+clst_0
  2035 00:0571: C9 02 00     	cmp	#<$2
  2036 00:0574: A5 22        	lda	<L53+clst_0+2
  2037 00:0576: E9 00 00     	sbc	#^$2
  2038 00:0579: B0 03        	bcs	L56
  2039 00:057B: 82 13 00     	brl	L55
  2040                        L56:
  2041 00:057E: A5 20        	lda	<L53+clst_0
  2042 00:0580: A0 13 00     	ldy	#$13
  2043 00:0583: D7 15        	cmp	[<L54+fs_1],Y
  2044 00:0585: A5 22        	lda	<L53+clst_0+2
  2045 00:0587: A0 15 00     	ldy	#$15
  2046 00:058A: F7 15        	sbc	[<L54+fs_1],Y
  2047 00:058C: B0 03        	bcs	L57
  2048 00:058E: 82 0D 00     	brl	L10015
  2049                        L57:
  2050                        L55:
  2051                        ;		val = 1;	/* Internal error */
  2052 00:0591: A9 01 00     	lda	#$1
  2053 00:0594: 85 11        	sta	<L54+val_1
  2054 00:0596: A9 00 00     	lda	#$0
  2055 00:0599: 85 13        	sta	<L54+val_1+2
  2056                        ;
  2057                        ;	} else {
  2058 00:059B: 82 12 02     	brl	L10016
  2059                        L10015:
  2060                        ;		val = 0xFFFFFFFF;	/* Default value
                     falls on disk error */
  2061 00:059E: A9 FF FF     	lda	#$ffff
  2062 00:05A1: 85 11        	sta	<L54+val_1
  2063 00:05A3: A9 FF FF     	lda	#$ffff
  Thu May 20 2021 21:37                                                Page 49


  2064 00:05A6: 85 13        	sta	<L54+val_1+2
  2065                        ;
  2066                        ;		switch (fs->fs_type) {
  2067 00:05A8: A7 15        	lda	[<L54+fs_1]
  2068 00:05AA: 29 FF 00     	and	#$ff
  2069 00:05AD: 82 EC 01     	brl	L10017
  2070                        ;		case FS_FAT12 :
  2071                        L10019:
  2072                        ;			bc = (UINT)clst; bc += bc / 2;
  2073 00:05B0: A5 20        	lda	<L53+clst_0
  2074 00:05B2: 85 0F        	sta	<L54+bc_1
  2075 00:05B4: A5 0F        	lda	<L54+bc_1
  2076 00:05B6: 4A           	lsr	A
  2077 00:05B7: 85 01        	sta	<R0
  2078 00:05B9: 18           	clc
  2079 00:05BA: A5 01        	lda	<R0
  2080 00:05BC: 65 0F        	adc	<L54+bc_1
  2081 00:05BE: 85 0F        	sta	<L54+bc_1
  2082                        ;			if (move_window(fs, fs->fatbase 
                    + (bc / SS(fs))) != FR_OK) break;
  2083 00:05C0: A5 0F        	lda	<L54+bc_1
  2084 00:05C2: A2 09 00     	ldx	#<$9
  2085                        	xref	~~~lsr
  2086 00:05C5: 22 xx xx xx  	jsl	~~~lsr
  2087 00:05C9: 85 01        	sta	<R0
  2088 00:05CB: A5 01        	lda	<R0
  2089 00:05CD: 85 01        	sta	<R0
  2090 00:05CF: 64 03        	stz	<R0+2
  2091 00:05D1: 18           	clc
  2092 00:05D2: A5 01        	lda	<R0
  2093 00:05D4: A0 1F 00     	ldy	#$1f
  2094 00:05D7: 77 15        	adc	[<L54+fs_1],Y
  2095 00:05D9: 85 05        	sta	<R1
  2096 00:05DB: A5 03        	lda	<R0+2
  2097 00:05DD: A0 21 00     	ldy	#$21
  2098 00:05E0: 77 15        	adc	[<L54+fs_1],Y
  2099 00:05E2: 85 07        	sta	<R1+2
  2100 00:05E4: D4 07        	pei	<R1+2
  2101 00:05E6: D4 05        	pei	<R1
  2102 00:05E8: D4 17        	pei	<L54+fs_1+2
  2103 00:05EA: D4 15        	pei	<L54+fs_1
  2104 00:05EC: 22 xx xx xx  	jsl	~~move_window
  2105 00:05F0: AA           	tax
  2106 00:05F1: F0 03        	beq	L58
  2107 00:05F3: 82 BA 01     	brl	L10018
  2108                        L58:
  2109                        ;			wc = fs->win[bc++ % SS(fs)];	
                    	/* Get 1st byte of the entry */
  2110 00:05F6: A5 0F        	lda	<L54+bc_1
  2111 00:05F8: 29 FF 01     	and	#<$1ff
  2112 00:05FB: 85 01        	sta	<R0
  2113 00:05FD: 18           	clc
  2114 00:05FE: A9 2F 00     	lda	#$2f
  2115 00:0601: 65 01        	adc	<R0
  2116 00:0603: 85 05        	sta	<R1
  2117 00:0605: A4 05        	ldy	<R1
  2118 00:0607: B7 15        	lda	[<L54+fs_1],Y
  2119 00:0609: 29 FF 00     	and	#$ff
  Thu May 20 2021 21:37                                                Page 50


  2120 00:060C: 85 0D        	sta	<L54+wc_1
  2121 00:060E: E6 0F        	inc	<L54+bc_1
  2122                        ;			if (move_window(fs, fs->fatbase 
                    + (bc / SS(fs))) != FR_OK) break;
  2123 00:0610: A5 0F        	lda	<L54+bc_1
  2124 00:0612: A2 09 00     	ldx	#<$9
  2125                        	xref	~~~lsr
  2126 00:0615: 22 xx xx xx  	jsl	~~~lsr
  2127 00:0619: 85 01        	sta	<R0
  2128 00:061B: A5 01        	lda	<R0
  2129 00:061D: 85 01        	sta	<R0
  2130 00:061F: 64 03        	stz	<R0+2
  2131 00:0621: 18           	clc
  2132 00:0622: A5 01        	lda	<R0
  2133 00:0624: A0 1F 00     	ldy	#$1f
  2134 00:0627: 77 15        	adc	[<L54+fs_1],Y
  2135 00:0629: 85 05        	sta	<R1
  2136 00:062B: A5 03        	lda	<R0+2
  2137 00:062D: A0 21 00     	ldy	#$21
  2138 00:0630: 77 15        	adc	[<L54+fs_1],Y
  2139 00:0632: 85 07        	sta	<R1+2
  2140 00:0634: D4 07        	pei	<R1+2
  2141 00:0636: D4 05        	pei	<R1
  2142 00:0638: D4 17        	pei	<L54+fs_1+2
  2143 00:063A: D4 15        	pei	<L54+fs_1
  2144 00:063C: 22 xx xx xx  	jsl	~~move_window
  2145 00:0640: AA           	tax
  2146 00:0641: F0 03        	beq	L59
  2147 00:0643: 82 6A 01     	brl	L10018
  2148                        L59:
  2149                        ;			wc |= fs->win[bc % SS(fs)] << 8;
                    	/* Merge 2nd byte of the entry */
  2150 00:0646: A5 0F        	lda	<L54+bc_1
  2151 00:0648: 29 FF 01     	and	#<$1ff
  2152 00:064B: 85 05        	sta	<R1
  2153 00:064D: 18           	clc
  2154 00:064E: A9 2F 00     	lda	#$2f
  2155 00:0651: 65 05        	adc	<R1
  2156 00:0653: 85 09        	sta	<R2
  2157 00:0655: A4 09        	ldy	<R2
  2158 00:0657: B7 15        	lda	[<L54+fs_1],Y
  2159 00:0659: 29 FF 00     	and	#$ff
  2160 00:065C: 85 05        	sta	<R1
  2161 00:065E: A5 05        	lda	<R1
  2162 00:0660: EB           	xba
  2163 00:0661: 29 00 FF     	and	#$ff00
  2164 00:0664: 85 01        	sta	<R0
  2165 00:0666: A5 01        	lda	<R0
  2166 00:0668: 04 0D        	tsb	<L54+wc_1
  2167                        ;			val = (clst & 1) ? (wc >> 4) : (
                    wc & 0xFFF);	/* Adjust bit position */
  2168 00:066A: A5 20        	lda	<L53+clst_0
  2169 00:066C: 29 01 00     	and	#<$1
  2170 00:066F: D0 03        	bne	L61
  2171 00:0671: 82 0C 00     	brl	L60
  2172                        L61:
  2173 00:0674: A5 0D        	lda	<L54+wc_1
  2174 00:0676: 4A           	lsr	A
  Thu May 20 2021 21:37                                                Page 51


  2175 00:0677: 4A           	lsr	A
  2176 00:0678: 4A           	lsr	A
  2177 00:0679: 4A           	lsr	A
  2178 00:067A: 85 01        	sta	<R0
  2179 00:067C: A5 01        	lda	<R0
  2180 00:067E: 80 09        	bra	L62
  2181                        L60:
  2182 00:0680: A5 0D        	lda	<L54+wc_1
  2183 00:0682: 29 FF 0F     	and	#<$fff
  2184 00:0685: 85 01        	sta	<R0
  2185 00:0687: A5 01        	lda	<R0
  2186                        L62:
  2187 00:0689: 85 01        	sta	<R0
  2188 00:068B: A5 01        	lda	<R0
  2189 00:068D: 85 11        	sta	<L54+val_1
  2190 00:068F: 64 13        	stz	<L54+val_1+2
  2191                        ;			break;
  2192 00:0691: 82 1C 01     	brl	L10018
  2193                        ;
  2194                        ;		case FS_FAT16 :
  2195                        L10020:
  2196                        ;			if (move_window(fs, fs->fatbase 
                    + (clst / (SS(fs) / 2))) != FR_OK) break;
  2197 00:0694: D4 22        	pei	<L53+clst_0+2
  2198 00:0696: D4 20        	pei	<L53+clst_0
  2199 00:0698: A9 08 00     	lda	#$8
  2200                        	xref	~~~llsr
  2201 00:069B: 22 xx xx xx  	jsl	~~~llsr
  2202 00:069F: 85 01        	sta	<R0
  2203 00:06A1: 86 03        	stx	<R0+2
  2204 00:06A3: 18           	clc
  2205 00:06A4: A5 01        	lda	<R0
  2206 00:06A6: A0 1F 00     	ldy	#$1f
  2207 00:06A9: 77 15        	adc	[<L54+fs_1],Y
  2208 00:06AB: 85 05        	sta	<R1
  2209 00:06AD: A5 03        	lda	<R0+2
  2210 00:06AF: A0 21 00     	ldy	#$21
  2211 00:06B2: 77 15        	adc	[<L54+fs_1],Y
  2212 00:06B4: 85 07        	sta	<R1+2
  2213 00:06B6: D4 07        	pei	<R1+2
  2214 00:06B8: D4 05        	pei	<R1
  2215 00:06BA: D4 17        	pei	<L54+fs_1+2
  2216 00:06BC: D4 15        	pei	<L54+fs_1
  2217 00:06BE: 22 xx xx xx  	jsl	~~move_window
  2218 00:06C2: AA           	tax
  2219 00:06C3: F0 03        	beq	L63
  2220 00:06C5: 82 E8 00     	brl	L10018
  2221                        L63:
  2222                        ;			val = ld_word(fs->win + clst * 2
                     % SS(fs));		/* Simple WORD array */
  2223 00:06C8: A5 20        	lda	<L53+clst_0
  2224 00:06CA: 85 01        	sta	<R0
  2225 00:06CC: A5 22        	lda	<L53+clst_0+2
  2226 00:06CE: 85 03        	sta	<R0+2
  2227 00:06D0: 06 01        	asl	<R0
  2228 00:06D2: 26 03        	rol	<R0+2
  2229 00:06D4: A5 01        	lda	<R0
  2230 00:06D6: 29 FF 01     	and	#<$1ff
  Thu May 20 2021 21:37                                                Page 52


  2231 00:06D9: 85 05        	sta	<R1
  2232 00:06DB: 64 07        	stz	<R1+2
  2233 00:06DD: 18           	clc
  2234 00:06DE: A9 2F 00     	lda	#$2f
  2235 00:06E1: 65 05        	adc	<R1
  2236 00:06E3: 85 01        	sta	<R0
  2237 00:06E5: A9 00 00     	lda	#$0
  2238 00:06E8: 65 07        	adc	<R1+2
  2239 00:06EA: 85 03        	sta	<R0+2
  2240 00:06EC: 18           	clc
  2241 00:06ED: A5 15        	lda	<L54+fs_1
  2242 00:06EF: 65 01        	adc	<R0
  2243 00:06F1: 85 05        	sta	<R1
  2244 00:06F3: A5 17        	lda	<L54+fs_1+2
  2245 00:06F5: 65 03        	adc	<R0+2
  2246 00:06F7: 85 07        	sta	<R1+2
  2247 00:06F9: D4 07        	pei	<R1+2
  2248 00:06FB: D4 05        	pei	<R1
  2249 00:06FD: 22 xx xx xx  	jsl	~~ld_word
  2250 00:0701: 85 09        	sta	<R2
  2251 00:0703: A5 09        	lda	<R2
  2252 00:0705: 85 11        	sta	<L54+val_1
  2253 00:0707: 64 13        	stz	<L54+val_1+2
  2254                        ;			break;
  2255 00:0709: 82 A4 00     	brl	L10018
  2256                        ;
  2257                        ;		case FS_FAT32 :
  2258                        L10021:
  2259                        ;			if (move_window(fs, fs->fatbase 
                    + (clst / (SS(fs) / 4))) != FR_OK) break;
  2260 00:070C: D4 22        	pei	<L53+clst_0+2
  2261 00:070E: D4 20        	pei	<L53+clst_0
  2262 00:0710: A9 07 00     	lda	#$7
  2263                        	xref	~~~llsr
  2264 00:0713: 22 xx xx xx  	jsl	~~~llsr
  2265 00:0717: 85 01        	sta	<R0
  2266 00:0719: 86 03        	stx	<R0+2
  2267 00:071B: 18           	clc
  2268 00:071C: A5 01        	lda	<R0
  2269 00:071E: A0 1F 00     	ldy	#$1f
  2270 00:0721: 77 15        	adc	[<L54+fs_1],Y
  2271 00:0723: 85 05        	sta	<R1
  2272 00:0725: A5 03        	lda	<R0+2
  2273 00:0727: A0 21 00     	ldy	#$21
  2274 00:072A: 77 15        	adc	[<L54+fs_1],Y
  2275 00:072C: 85 07        	sta	<R1+2
  2276 00:072E: D4 07        	pei	<R1+2
  2277 00:0730: D4 05        	pei	<R1
  2278 00:0732: D4 17        	pei	<L54+fs_1+2
  2279 00:0734: D4 15        	pei	<L54+fs_1
  2280 00:0736: 22 xx xx xx  	jsl	~~move_window
  2281 00:073A: AA           	tax
  2282 00:073B: F0 03        	beq	L64
  2283 00:073D: 82 70 00     	brl	L10018
  2284                        L64:
  2285                        ;			val = ld_dword(fs->win + clst * 
                    4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask o
                    ut upper 4 bits */
  Thu May 20 2021 21:37                                                Page 53


  2286 00:0740: A5 20        	lda	<L53+clst_0
  2287 00:0742: 85 01        	sta	<R0
  2288 00:0744: A5 22        	lda	<L53+clst_0+2
  2289 00:0746: 85 03        	sta	<R0+2
  2290 00:0748: 06 01        	asl	<R0
  2291 00:074A: 26 03        	rol	<R0+2
  2292 00:074C: 06 01        	asl	<R0
  2293 00:074E: 26 03        	rol	<R0+2
  2294 00:0750: A5 01        	lda	<R0
  2295 00:0752: 29 FF 01     	and	#<$1ff
  2296 00:0755: 85 05        	sta	<R1
  2297 00:0757: 64 07        	stz	<R1+2
  2298 00:0759: 18           	clc
  2299 00:075A: A9 2F 00     	lda	#$2f
  2300 00:075D: 65 05        	adc	<R1
  2301 00:075F: 85 01        	sta	<R0
  2302 00:0761: A9 00 00     	lda	#$0
  2303 00:0764: 65 07        	adc	<R1+2
  2304 00:0766: 85 03        	sta	<R0+2
  2305 00:0768: 18           	clc
  2306 00:0769: A5 15        	lda	<L54+fs_1
  2307 00:076B: 65 01        	adc	<R0
  2308 00:076D: 85 05        	sta	<R1
  2309 00:076F: A5 17        	lda	<L54+fs_1+2
  2310 00:0771: 65 03        	adc	<R0+2
  2311 00:0773: 85 07        	sta	<R1+2
  2312 00:0775: D4 07        	pei	<R1+2
  2313 00:0777: D4 05        	pei	<R1
  2314 00:0779: 22 xx xx xx  	jsl	~~ld_dword
  2315 00:077D: 85 09        	sta	<R2
  2316 00:077F: 86 0B        	stx	<R2+2
  2317 00:0781: A5 09        	lda	<R2
  2318 00:0783: 85 11        	sta	<L54+val_1
  2319 00:0785: A5 0B        	lda	<R2+2
  2320 00:0787: 29 FF 0F     	and	#^$fffffff
  2321 00:078A: 85 13        	sta	<L54+val_1+2
  2322                        ;			break;
  2323 00:078C: 82 21 00     	brl	L10018
  2324                        ;#if FF_FS_EXFAT
  2325                        ;		case FS_EXFAT :
  2326                        ;			if ((obj->objsize != 0 && obj->s
                    clust != 0) || obj->stat == 0) {	/* Object except root di
                    r must have valid data length */
  2327                        ;				DWORD cofs = clst - obj-
                    >sclust;	/* Offset from start cluster */
  2328                        ;				DWORD clen = (DWORD)((LB
                    A_t)((obj->objsize - 1) / SS(fs)) / fs->csize);	/* Numbe
                    r of clusters - 1 */
  2329                        ;
  2330                        ;				if (obj->stat == 2 && co
                    fs <= clen) {	/* Is it a contiguous chain? */
  2331                        ;					val = (cofs == c
                    len) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, g
                    enerate the value */
  2332                        ;					break;
  2333                        ;				}
  2334                        ;				if (obj->stat == 3 && co
                    fs < obj->n_cont) {	/* Is it in the 1st fragment? */
  Thu May 20 2021 21:37                                                Page 54


  2335                        ;					val = clst + 1; 
                    	/* Generate the value */
  2336                        ;					break;
  2337                        ;				}
  2338                        ;				if (obj->stat != 2) {	
                    /* Get value from FAT if FAT chain is valid */
  2339                        ;					if (obj->n_frag 
                    != 0) {	/* Is it on the growing edge? */
  2340                        ;						val = 0x
                    7FFFFFFF;	/* Generate EOC */
  2341                        ;					} else {
  2342                        ;						if (move
                    _window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) b
                    reak;
  2343                        ;						val = ld
                    _dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
  2344                        ;					}
  2345                        ;					break;
  2346                        ;				}
  2347                        ;			}
  2348                        ;			val = 1;	/* Internal erro
                    r */
  2349                        ;			break;
  2350                        ;#endif
  2351                        ;		default:
  2352                        L10022:
  2353                        ;			val = 1;	/* Internal erro
                    r */
  2354 00:078F: A9 01 00     	lda	#$1
  2355 00:0792: 85 11        	sta	<L54+val_1
  2356 00:0794: A9 00 00     	lda	#$0
  2357 00:0797: 85 13        	sta	<L54+val_1+2
  2358                        ;		}
  2359 00:0799: 82 14 00     	brl	L10018
  2360                        L10017:
  2361                        	xref	~~~swt
  2362 00:079C: 22 xx xx xx  	jsl	~~~swt
  2363 00:07A0: 03 00        	dw	3
  2364 00:07A2: 01 00        	dw	1
  2365 00:07A4: xx xx        	dw	L10019-1
  2366 00:07A6: 02 00        	dw	2
  2367 00:07A8: xx xx        	dw	L10020-1
  2368 00:07AA: 03 00        	dw	3
  2369 00:07AC: xx xx        	dw	L10021-1
  2370 00:07AE: xx xx        	dw	L10022-1
  2371                        L10018:
  2372                        ;	}
  2373                        L10016:
  2374                        ;
  2375                        ;	return val;
  2376 00:07B0: A6 13        	ldx	<L54+val_1+2
  2377 00:07B2: A5 11        	lda	<L54+val_1
  2378                        L65:
  2379 00:07B4: A8           	tay
  2380 00:07B5: A5 1A        	lda	<L53+2
  2381 00:07B7: 85 22        	sta	<L53+2+8
  2382 00:07B9: A5 19        	lda	<L53+1
  2383 00:07BB: 85 21        	sta	<L53+1+8
  Thu May 20 2021 21:37                                                Page 55


  2384 00:07BD: 2B           	pld
  2385 00:07BE: 3B           	tsc
  2386 00:07BF: 18           	clc
  2387 00:07C0: 69 20 00     	adc	#L53+8
  2388 00:07C3: 1B           	tcs
  2389 00:07C4: 98           	tya
  2390 00:07C5: 6B           	rtl
  2391                        ;}
  2392             00000018   L53	equ	24
  2393             0000000D   L54	equ	13
  2394                        	ends
  2395                        	efunc
  2396                        ;
  2397                        ;
  2398                        ;
  2399                        ;
  2400                        ;#if !FF_FS_READONLY
  2401                        ;/*-----------------------------------------------
                    ------------------------*/
  2402                        ;/* FAT access - Change value of an FAT entry     
                                            */
  2403                        ;/*-----------------------------------------------
                    ------------------------*/
  2404                        ;
  2405                        ;static FRESULT put_fat (	/* FR_OK(0):succeeded, !
                    =0:error */
  2406                        ;	FATFS* fs,		/* Corresponding filesys
                    tem object */
  2407                        ;	DWORD clst,		/* FAT index number (clu
                    ster number) to be changed */
  2408                        ;	DWORD val		/* New value to be set t
                    o the entry */
  2409                        ;)
  2410                        ;{
  2411                        	code
  2412                        	func
  2413                        ~~put_fat:
  2414                        	longa	on
  2415                        	longi	on
  2416 00:07C6: 3B           	tsc
  2417 00:07C7: 38           	sec
  2418 00:07C8: E9 18 00     	sbc	#L66
  2419 00:07CB: 1B           	tcs
  2420 00:07CC: 0B           	phd
  2421 00:07CD: 5B           	tcd
  2422             00000004   fs_0	set	4
  2423             00000008   clst_0	set	8
  2424             0000000C   val_0	set	12
  2425                        ;	UINT bc;
  2426                        ;	BYTE *p;
  2427                        ;	FRESULT res = FR_INT_ERR;
  2428                        ;
  2429                        ;
  2430                        ;	if (clst >= 2 && clst < fs->n_fatent) {	/* Check
                     if in valid range */
  2431             00000000   bc_1	set	0
  2432             00000002   p_1	set	2
  2433             00000006   res_1	set	6
  Thu May 20 2021 21:37                                                Page 56


  2434 00:07CE: A9 02 00     	lda	#$2
  2435 00:07D1: 85 17        	sta	<L67+res_1
  2436 00:07D3: A5 20        	lda	<L66+clst_0
  2437 00:07D5: C9 02 00     	cmp	#<$2
  2438 00:07D8: A5 22        	lda	<L66+clst_0+2
  2439 00:07DA: E9 00 00     	sbc	#^$2
  2440 00:07DD: B0 03        	bcs	L68
  2441 00:07DF: 82 16 03     	brl	L10023
  2442                        L68:
  2443 00:07E2: A5 20        	lda	<L66+clst_0
  2444 00:07E4: A0 13 00     	ldy	#$13
  2445 00:07E7: D7 1C        	cmp	[<L66+fs_0],Y
  2446 00:07E9: A5 22        	lda	<L66+clst_0+2
  2447 00:07EB: A0 15 00     	ldy	#$15
  2448 00:07EE: F7 1C        	sbc	[<L66+fs_0],Y
  2449 00:07F0: 90 03        	bcc	L69
  2450 00:07F2: 82 03 03     	brl	L10023
  2451                        L69:
  2452                        ;		switch (fs->fs_type) {
  2453 00:07F5: A7 1C        	lda	[<L66+fs_0]
  2454 00:07F7: 29 FF 00     	and	#$ff
  2455 00:07FA: 82 E7 02     	brl	L10024
  2456                        ;		case FS_FAT12:
  2457                        L10026:
  2458                        ;			bc = (UINT)clst; bc += bc / 2;	
                    /* bc: byte offset of the entry */
  2459 00:07FD: A5 20        	lda	<L66+clst_0
  2460 00:07FF: 85 11        	sta	<L67+bc_1
  2461 00:0801: A5 11        	lda	<L67+bc_1
  2462 00:0803: 4A           	lsr	A
  2463 00:0804: 85 01        	sta	<R0
  2464 00:0806: 18           	clc
  2465 00:0807: A5 01        	lda	<R0
  2466 00:0809: 65 11        	adc	<L67+bc_1
  2467 00:080B: 85 11        	sta	<L67+bc_1
  2468                        ;			res = move_window(fs, fs->fatbas
                    e + (bc / SS(fs)));
  2469 00:080D: A5 11        	lda	<L67+bc_1
  2470 00:080F: A2 09 00     	ldx	#<$9
  2471                        	xref	~~~lsr
  2472 00:0812: 22 xx xx xx  	jsl	~~~lsr
  2473 00:0816: 85 01        	sta	<R0
  2474 00:0818: A5 01        	lda	<R0
  2475 00:081A: 85 01        	sta	<R0
  2476 00:081C: 64 03        	stz	<R0+2
  2477 00:081E: 18           	clc
  2478 00:081F: A5 01        	lda	<R0
  2479 00:0821: A0 1F 00     	ldy	#$1f
  2480 00:0824: 77 1C        	adc	[<L66+fs_0],Y
  2481 00:0826: 85 05        	sta	<R1
  2482 00:0828: A5 03        	lda	<R0+2
  2483 00:082A: A0 21 00     	ldy	#$21
  2484 00:082D: 77 1C        	adc	[<L66+fs_0],Y
  2485 00:082F: 85 07        	sta	<R1+2
  2486 00:0831: D4 07        	pei	<R1+2
  2487 00:0833: D4 05        	pei	<R1
  2488 00:0835: D4 1E        	pei	<L66+fs_0+2
  2489 00:0837: D4 1C        	pei	<L66+fs_0
  Thu May 20 2021 21:37                                                Page 57


  2490 00:0839: 22 xx xx xx  	jsl	~~move_window
  2491 00:083D: 85 17        	sta	<L67+res_1
  2492                        ;			if (res != FR_OK) break;
  2493 00:083F: A5 17        	lda	<L67+res_1
  2494 00:0841: F0 03        	beq	L70
  2495 00:0843: 82 B2 02     	brl	L10025
  2496                        L70:
  2497                        ;			p = fs->win + bc++ % SS(fs);
  2498 00:0846: A5 11        	lda	<L67+bc_1
  2499 00:0848: 29 FF 01     	and	#<$1ff
  2500 00:084B: 85 01        	sta	<R0
  2501 00:084D: A5 01        	lda	<R0
  2502 00:084F: 85 01        	sta	<R0
  2503 00:0851: 64 03        	stz	<R0+2
  2504 00:0853: 18           	clc
  2505 00:0854: A9 2F 00     	lda	#$2f
  2506 00:0857: 65 01        	adc	<R0
  2507 00:0859: 85 05        	sta	<R1
  2508 00:085B: A9 00 00     	lda	#$0
  2509 00:085E: 65 03        	adc	<R0+2
  2510 00:0860: 85 07        	sta	<R1+2
  2511 00:0862: 18           	clc
  2512 00:0863: A5 1C        	lda	<L66+fs_0
  2513 00:0865: 65 05        	adc	<R1
  2514 00:0867: 85 13        	sta	<L67+p_1
  2515 00:0869: A5 1E        	lda	<L66+fs_0+2
  2516 00:086B: 65 07        	adc	<R1+2
  2517 00:086D: 85 15        	sta	<L67+p_1+2
  2518 00:086F: E6 11        	inc	<L67+bc_1
  2519                        ;			*p = (clst & 1) ? ((*p & 0x0F) |
                     ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
  2520 00:0871: A5 20        	lda	<L66+clst_0
  2521 00:0873: 29 01 00     	and	#<$1
  2522 00:0876: D0 03        	bne	L72
  2523 00:0878: 82 1C 00     	brl	L71
  2524                        L72:
  2525 00:087B: A7 13        	lda	[<L67+p_1]
  2526 00:087D: 29 0F 00     	and	#<$f
  2527 00:0880: 85 01        	sta	<R0
  2528 00:0882: A5 24        	lda	<L66+val_0
  2529 00:0884: 29 FF 00     	and	#$ff
  2530 00:0887: 85 09        	sta	<R2
  2531 00:0889: A5 09        	lda	<R2
  2532 00:088B: 0A           	asl	A
  2533 00:088C: 0A           	asl	A
  2534 00:088D: 0A           	asl	A
  2535 00:088E: 0A           	asl	A
  2536 00:088F: 85 05        	sta	<R1
  2537 00:0891: A5 05        	lda	<R1
  2538 00:0893: 05 01        	ora	<R0
  2539 00:0895: 80 05        	bra	L73
  2540                        L71:
  2541 00:0897: A5 24        	lda	<L66+val_0
  2542 00:0899: 29 FF 00     	and	#$ff
  2543                        L73:
  2544 00:089C: E2 20        	sep	#$20
  2545                        	longa	off
  2546 00:089E: 87 13        	sta	[<L67+p_1]
  Thu May 20 2021 21:37                                                Page 58


  2547 00:08A0: C2 20        	rep	#$20
  2548                        	longa	on
  2549                        ;			fs->wflag = 1;
  2550 00:08A2: E2 20        	sep	#$20
  2551                        	longa	off
  2552 00:08A4: A9 01        	lda	#$1
  2553 00:08A6: A0 03 00     	ldy	#$3
  2554 00:08A9: 97 1C        	sta	[<L66+fs_0],Y
  2555 00:08AB: C2 20        	rep	#$20
  2556                        	longa	on
  2557                        ;			res = move_window(fs, fs->fatbas
                    e + (bc / SS(fs)));
  2558 00:08AD: A5 11        	lda	<L67+bc_1
  2559 00:08AF: A2 09 00     	ldx	#<$9
  2560                        	xref	~~~lsr
  2561 00:08B2: 22 xx xx xx  	jsl	~~~lsr
  2562 00:08B6: 85 01        	sta	<R0
  2563 00:08B8: A5 01        	lda	<R0
  2564 00:08BA: 85 01        	sta	<R0
  2565 00:08BC: 64 03        	stz	<R0+2
  2566 00:08BE: 18           	clc
  2567 00:08BF: A5 01        	lda	<R0
  2568 00:08C1: A0 1F 00     	ldy	#$1f
  2569 00:08C4: 77 1C        	adc	[<L66+fs_0],Y
  2570 00:08C6: 85 05        	sta	<R1
  2571 00:08C8: A5 03        	lda	<R0+2
  2572 00:08CA: A0 21 00     	ldy	#$21
  2573 00:08CD: 77 1C        	adc	[<L66+fs_0],Y
  2574 00:08CF: 85 07        	sta	<R1+2
  2575 00:08D1: D4 07        	pei	<R1+2
  2576 00:08D3: D4 05        	pei	<R1
  2577 00:08D5: D4 1E        	pei	<L66+fs_0+2
  2578 00:08D7: D4 1C        	pei	<L66+fs_0
  2579 00:08D9: 22 xx xx xx  	jsl	~~move_window
  2580 00:08DD: 85 17        	sta	<L67+res_1
  2581                        ;			if (res != FR_OK) break;
  2582 00:08DF: A5 17        	lda	<L67+res_1
  2583 00:08E1: F0 03        	beq	L74
  2584 00:08E3: 82 12 02     	brl	L10025
  2585                        L74:
  2586                        ;			p = fs->win + bc % SS(fs);
  2587 00:08E6: A5 11        	lda	<L67+bc_1
  2588 00:08E8: 29 FF 01     	and	#<$1ff
  2589 00:08EB: 85 01        	sta	<R0
  2590 00:08ED: A5 01        	lda	<R0
  2591 00:08EF: 85 01        	sta	<R0
  2592 00:08F1: 64 03        	stz	<R0+2
  2593 00:08F3: 18           	clc
  2594 00:08F4: A9 2F 00     	lda	#$2f
  2595 00:08F7: 65 01        	adc	<R0
  2596 00:08F9: 85 05        	sta	<R1
  2597 00:08FB: A9 00 00     	lda	#$0
  2598 00:08FE: 65 03        	adc	<R0+2
  2599 00:0900: 85 07        	sta	<R1+2
  2600 00:0902: 18           	clc
  2601 00:0903: A5 1C        	lda	<L66+fs_0
  2602 00:0905: 65 05        	adc	<R1
  2603 00:0907: 85 13        	sta	<L67+p_1
  Thu May 20 2021 21:37                                                Page 59


  2604 00:0909: A5 1E        	lda	<L66+fs_0+2
  2605 00:090B: 65 07        	adc	<R1+2
  2606 00:090D: 85 15        	sta	<L67+p_1+2
  2607                        ;			*p = (clst & 1) ? (BYTE)(val >> 
                    4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Updat
                    e 2nd byte */
  2608 00:090F: A5 20        	lda	<L66+clst_0
  2609 00:0911: 29 01 00     	and	#<$1
  2610 00:0914: D0 03        	bne	L76
  2611 00:0916: 82 1F 00     	brl	L75
  2612                        L76:
  2613 00:0919: A5 24        	lda	<L66+val_0
  2614 00:091B: 85 01        	sta	<R0
  2615 00:091D: A5 26        	lda	<L66+val_0+2
  2616 00:091F: 85 03        	sta	<R0+2
  2617 00:0921: 46 03        	lsr	<R0+2
  2618 00:0923: 66 01        	ror	<R0
  2619 00:0925: 46 03        	lsr	<R0+2
  2620 00:0927: 66 01        	ror	<R0
  2621 00:0929: 46 03        	lsr	<R0+2
  2622 00:092B: 66 01        	ror	<R0
  2623 00:092D: 46 03        	lsr	<R0+2
  2624 00:092F: 66 01        	ror	<R0
  2625 00:0931: A5 01        	lda	<R0
  2626 00:0933: 29 FF 00     	and	#$ff
  2627 00:0936: 80 21        	bra	L77
  2628                        L75:
  2629 00:0938: D4 26        	pei	<L66+val_0+2
  2630 00:093A: D4 24        	pei	<L66+val_0
  2631 00:093C: A9 08 00     	lda	#$8
  2632                        	xref	~~~llsr
  2633 00:093F: 22 xx xx xx  	jsl	~~~llsr
  2634 00:0943: 85 01        	sta	<R0
  2635 00:0945: 86 03        	stx	<R0+2
  2636 00:0947: A5 01        	lda	<R0
  2637 00:0949: 29 0F 00     	and	#<$f
  2638 00:094C: 85 05        	sta	<R1
  2639 00:094E: A7 13        	lda	[<L67+p_1]
  2640 00:0950: 29 F0 00     	and	#<$f0
  2641 00:0953: 85 01        	sta	<R0
  2642 00:0955: A5 01        	lda	<R0
  2643 00:0957: 05 05        	ora	<R1
  2644                        L77:
  2645 00:0959: E2 20        	sep	#$20
  2646                        	longa	off
  2647 00:095B: 87 13        	sta	[<L67+p_1]
  2648 00:095D: C2 20        	rep	#$20
  2649                        	longa	on
  2650                        ;			fs->wflag = 1;
  2651 00:095F: E2 20        	sep	#$20
  2652                        	longa	off
  2653 00:0961: A9 01        	lda	#$1
  2654 00:0963: A0 03 00     	ldy	#$3
  2655 00:0966: 97 1C        	sta	[<L66+fs_0],Y
  2656 00:0968: C2 20        	rep	#$20
  2657                        	longa	on
  2658                        ;			break;
  2659 00:096A: 82 8B 01     	brl	L10025
  Thu May 20 2021 21:37                                                Page 60


  2660                        ;
  2661                        ;		case FS_FAT16:
  2662                        L10027:
  2663                        ;			res = move_window(fs, fs->fatbas
                    e + (clst / (SS(fs) / 2)));
  2664 00:096D: D4 22        	pei	<L66+clst_0+2
  2665 00:096F: D4 20        	pei	<L66+clst_0
  2666 00:0971: A9 08 00     	lda	#$8
  2667                        	xref	~~~llsr
  2668 00:0974: 22 xx xx xx  	jsl	~~~llsr
  2669 00:0978: 85 01        	sta	<R0
  2670 00:097A: 86 03        	stx	<R0+2
  2671 00:097C: 18           	clc
  2672 00:097D: A5 01        	lda	<R0
  2673 00:097F: A0 1F 00     	ldy	#$1f
  2674 00:0982: 77 1C        	adc	[<L66+fs_0],Y
  2675 00:0984: 85 05        	sta	<R1
  2676 00:0986: A5 03        	lda	<R0+2
  2677 00:0988: A0 21 00     	ldy	#$21
  2678 00:098B: 77 1C        	adc	[<L66+fs_0],Y
  2679 00:098D: 85 07        	sta	<R1+2
  2680 00:098F: D4 07        	pei	<R1+2
  2681 00:0991: D4 05        	pei	<R1
  2682 00:0993: D4 1E        	pei	<L66+fs_0+2
  2683 00:0995: D4 1C        	pei	<L66+fs_0
  2684 00:0997: 22 xx xx xx  	jsl	~~move_window
  2685 00:099B: 85 17        	sta	<L67+res_1
  2686                        ;			if (res != FR_OK) break;
  2687 00:099D: A5 17        	lda	<L67+res_1
  2688 00:099F: F0 03        	beq	L78
  2689 00:09A1: 82 54 01     	brl	L10025
  2690                        L78:
  2691                        ;			st_word(fs->win + clst * 2 % SS(
                    fs), (WORD)val);	/* Simple WORD array */
  2692 00:09A4: D4 24        	pei	<L66+val_0
  2693 00:09A6: A5 20        	lda	<L66+clst_0
  2694 00:09A8: 85 01        	sta	<R0
  2695 00:09AA: A5 22        	lda	<L66+clst_0+2
  2696 00:09AC: 85 03        	sta	<R0+2
  2697 00:09AE: 06 01        	asl	<R0
  2698 00:09B0: 26 03        	rol	<R0+2
  2699 00:09B2: A5 01        	lda	<R0
  2700 00:09B4: 29 FF 01     	and	#<$1ff
  2701 00:09B7: 85 05        	sta	<R1
  2702 00:09B9: 64 07        	stz	<R1+2
  2703 00:09BB: 18           	clc
  2704 00:09BC: A9 2F 00     	lda	#$2f
  2705 00:09BF: 65 05        	adc	<R1
  2706 00:09C1: 85 01        	sta	<R0
  2707 00:09C3: A9 00 00     	lda	#$0
  2708 00:09C6: 65 07        	adc	<R1+2
  2709 00:09C8: 85 03        	sta	<R0+2
  2710 00:09CA: 18           	clc
  2711 00:09CB: A5 1C        	lda	<L66+fs_0
  2712 00:09CD: 65 01        	adc	<R0
  2713 00:09CF: 85 05        	sta	<R1
  2714 00:09D1: A5 1E        	lda	<L66+fs_0+2
  2715 00:09D3: 65 03        	adc	<R0+2
  Thu May 20 2021 21:37                                                Page 61


  2716 00:09D5: 85 07        	sta	<R1+2
  2717 00:09D7: D4 07        	pei	<R1+2
  2718 00:09D9: D4 05        	pei	<R1
  2719 00:09DB: 22 xx xx xx  	jsl	~~st_word
  2720                        ;			fs->wflag = 1;
  2721 00:09DF: E2 20        	sep	#$20
  2722                        	longa	off
  2723 00:09E1: A9 01        	lda	#$1
  2724 00:09E3: A0 03 00     	ldy	#$3
  2725 00:09E6: 97 1C        	sta	[<L66+fs_0],Y
  2726 00:09E8: C2 20        	rep	#$20
  2727                        	longa	on
  2728                        ;			break;
  2729 00:09EA: 82 0B 01     	brl	L10025
  2730                        ;
  2731                        ;		case FS_FAT32:
  2732                        L10028:
  2733                        ;#if FF_FS_EXFAT
  2734                        ;		case FS_EXFAT:
  2735                        ;#endif
  2736                        ;			res = move_window(fs, fs->fatbas
                    e + (clst / (SS(fs) / 4)));
  2737 00:09ED: D4 22        	pei	<L66+clst_0+2
  2738 00:09EF: D4 20        	pei	<L66+clst_0
  2739 00:09F1: A9 07 00     	lda	#$7
  2740                        	xref	~~~llsr
  2741 00:09F4: 22 xx xx xx  	jsl	~~~llsr
  2742 00:09F8: 85 01        	sta	<R0
  2743 00:09FA: 86 03        	stx	<R0+2
  2744 00:09FC: 18           	clc
  2745 00:09FD: A5 01        	lda	<R0
  2746 00:09FF: A0 1F 00     	ldy	#$1f
  2747 00:0A02: 77 1C        	adc	[<L66+fs_0],Y
  2748 00:0A04: 85 05        	sta	<R1
  2749 00:0A06: A5 03        	lda	<R0+2
  2750 00:0A08: A0 21 00     	ldy	#$21
  2751 00:0A0B: 77 1C        	adc	[<L66+fs_0],Y
  2752 00:0A0D: 85 07        	sta	<R1+2
  2753 00:0A0F: D4 07        	pei	<R1+2
  2754 00:0A11: D4 05        	pei	<R1
  2755 00:0A13: D4 1E        	pei	<L66+fs_0+2
  2756 00:0A15: D4 1C        	pei	<L66+fs_0
  2757 00:0A17: 22 xx xx xx  	jsl	~~move_window
  2758 00:0A1B: 85 17        	sta	<L67+res_1
  2759                        ;			if (res != FR_OK) break;
  2760 00:0A1D: A5 17        	lda	<L67+res_1
  2761 00:0A1F: F0 03        	beq	L79
  2762 00:0A21: 82 D4 00     	brl	L10025
  2763                        L79:
  2764                        ;			if (!FF_FS_EXFAT || fs->fs_type 
                    != FS_EXFAT) {
  2765 00:0A24: 82 0D 00     	brl	L80
  2766 00:0A27: E2 20        	sep	#$20
  2767                        	longa	off
  2768 00:0A29: A7 1C        	lda	[<L66+fs_0]
  2769 00:0A2B: C9 04        	cmp	#<$4
  2770 00:0A2D: C2 20        	rep	#$20
  2771                        	longa	on
  Thu May 20 2021 21:37                                                Page 62


  2772 00:0A2F: D0 03        	bne	L81
  2773 00:0A31: 82 61 00     	brl	L10029
  2774                        L81:
  2775                        L80:
  2776                        ;				val = (val & 0x0FFFFFFF)
                     | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
  2777 00:0A34: A5 20        	lda	<L66+clst_0
  2778 00:0A36: 85 01        	sta	<R0
  2779 00:0A38: A5 22        	lda	<L66+clst_0+2
  2780 00:0A3A: 85 03        	sta	<R0+2
  2781 00:0A3C: 06 01        	asl	<R0
  2782 00:0A3E: 26 03        	rol	<R0+2
  2783 00:0A40: 06 01        	asl	<R0
  2784 00:0A42: 26 03        	rol	<R0+2
  2785 00:0A44: A5 01        	lda	<R0
  2786 00:0A46: 29 FF 01     	and	#<$1ff
  2787 00:0A49: 85 05        	sta	<R1
  2788 00:0A4B: 64 07        	stz	<R1+2
  2789 00:0A4D: 18           	clc
  2790 00:0A4E: A9 2F 00     	lda	#$2f
  2791 00:0A51: 65 05        	adc	<R1
  2792 00:0A53: 85 01        	sta	<R0
  2793 00:0A55: A9 00 00     	lda	#$0
  2794 00:0A58: 65 07        	adc	<R1+2
  2795 00:0A5A: 85 03        	sta	<R0+2
  2796 00:0A5C: 18           	clc
  2797 00:0A5D: A5 1C        	lda	<L66+fs_0
  2798 00:0A5F: 65 01        	adc	<R0
  2799 00:0A61: 85 05        	sta	<R1
  2800 00:0A63: A5 1E        	lda	<L66+fs_0+2
  2801 00:0A65: 65 03        	adc	<R0+2
  2802 00:0A67: 85 07        	sta	<R1+2
  2803 00:0A69: D4 07        	pei	<R1+2
  2804 00:0A6B: D4 05        	pei	<R1
  2805 00:0A6D: 22 xx xx xx  	jsl	~~ld_dword
  2806 00:0A71: 85 09        	sta	<R2
  2807 00:0A73: 86 0B        	stx	<R2+2
  2808 00:0A75: 64 0D        	stz	<R3
  2809 00:0A77: A5 0B        	lda	<R2+2
  2810 00:0A79: 29 00 F0     	and	#^$f0000000
  2811 00:0A7C: 85 0F        	sta	<R3+2
  2812 00:0A7E: A5 24        	lda	<L66+val_0
  2813 00:0A80: 85 09        	sta	<R2
  2814 00:0A82: A5 26        	lda	<L66+val_0+2
  2815 00:0A84: 29 FF 0F     	and	#^$fffffff
  2816 00:0A87: 85 0B        	sta	<R2+2
  2817 00:0A89: A5 09        	lda	<R2
  2818 00:0A8B: 05 0D        	ora	<R3
  2819 00:0A8D: 85 24        	sta	<L66+val_0
  2820 00:0A8F: A5 0B        	lda	<R2+2
  2821 00:0A91: 05 0F        	ora	<R3+2
  2822 00:0A93: 85 26        	sta	<L66+val_0+2
  2823                        ;			}
  2824                        ;			st_dword(fs->win + clst * 4 % SS
                    (fs), val);
  2825                        L10029:
  2826 00:0A95: D4 26        	pei	<L66+val_0+2
  2827 00:0A97: D4 24        	pei	<L66+val_0
  Thu May 20 2021 21:37                                                Page 63


  2828 00:0A99: A5 20        	lda	<L66+clst_0
  2829 00:0A9B: 85 01        	sta	<R0
  2830 00:0A9D: A5 22        	lda	<L66+clst_0+2
  2831 00:0A9F: 85 03        	sta	<R0+2
  2832 00:0AA1: 06 01        	asl	<R0
  2833 00:0AA3: 26 03        	rol	<R0+2
  2834 00:0AA5: 06 01        	asl	<R0
  2835 00:0AA7: 26 03        	rol	<R0+2
  2836 00:0AA9: A5 01        	lda	<R0
  2837 00:0AAB: 29 FF 01     	and	#<$1ff
  2838 00:0AAE: 85 05        	sta	<R1
  2839 00:0AB0: 64 07        	stz	<R1+2
  2840 00:0AB2: 18           	clc
  2841 00:0AB3: A9 2F 00     	lda	#$2f
  2842 00:0AB6: 65 05        	adc	<R1
  2843 00:0AB8: 85 01        	sta	<R0
  2844 00:0ABA: A9 00 00     	lda	#$0
  2845 00:0ABD: 65 07        	adc	<R1+2
  2846 00:0ABF: 85 03        	sta	<R0+2
  2847 00:0AC1: 18           	clc
  2848 00:0AC2: A5 1C        	lda	<L66+fs_0
  2849 00:0AC4: 65 01        	adc	<R0
  2850 00:0AC6: 85 05        	sta	<R1
  2851 00:0AC8: A5 1E        	lda	<L66+fs_0+2
  2852 00:0ACA: 65 03        	adc	<R0+2
  2853 00:0ACC: 85 07        	sta	<R1+2
  2854 00:0ACE: D4 07        	pei	<R1+2
  2855 00:0AD0: D4 05        	pei	<R1
  2856 00:0AD2: 22 xx xx xx  	jsl	~~st_dword
  2857                        ;			fs->wflag = 1;
  2858 00:0AD6: E2 20        	sep	#$20
  2859                        	longa	off
  2860 00:0AD8: A9 01        	lda	#$1
  2861 00:0ADA: A0 03 00     	ldy	#$3
  2862 00:0ADD: 97 1C        	sta	[<L66+fs_0],Y
  2863 00:0ADF: C2 20        	rep	#$20
  2864                        	longa	on
  2865                        ;			break;
  2866 00:0AE1: 82 14 00     	brl	L10025
  2867                        ;		}
  2868                        L10024:
  2869                        	xref	~~~swt
  2870 00:0AE4: 22 xx xx xx  	jsl	~~~swt
  2871 00:0AE8: 03 00        	dw	3
  2872 00:0AEA: 01 00        	dw	1
  2873 00:0AEC: xx xx        	dw	L10026-1
  2874 00:0AEE: 02 00        	dw	2
  2875 00:0AF0: xx xx        	dw	L10027-1
  2876 00:0AF2: 03 00        	dw	3
  2877 00:0AF4: xx xx        	dw	L10028-1
  2878 00:0AF6: xx xx        	dw	L10025-1
  2879                        L10025:
  2880                        ;	}
  2881                        ;	return res;
  2882                        L10023:
  2883 00:0AF8: A5 17        	lda	<L67+res_1
  2884                        L82:
  2885 00:0AFA: A8           	tay
  Thu May 20 2021 21:37                                                Page 64


  2886 00:0AFB: A5 1A        	lda	<L66+2
  2887 00:0AFD: 85 26        	sta	<L66+2+12
  2888 00:0AFF: A5 19        	lda	<L66+1
  2889 00:0B01: 85 25        	sta	<L66+1+12
  2890 00:0B03: 2B           	pld
  2891 00:0B04: 3B           	tsc
  2892 00:0B05: 18           	clc
  2893 00:0B06: 69 24 00     	adc	#L66+12
  2894 00:0B09: 1B           	tcs
  2895 00:0B0A: 98           	tya
  2896 00:0B0B: 6B           	rtl
  2897                        ;}
  2898             00000018   L66	equ	24
  2899             00000011   L67	equ	17
  2900                        	ends
  2901                        	efunc
  2902                        ;
  2903                        ;#endif /* !FF_FS_READONLY */
  2904                        ;
  2905                        ;
  2906                        ;
  2907                        ;
  2908                        ;#if FF_FS_EXFAT && !FF_FS_READONLY
  2909                        ;/*-----------------------------------------------
                    ------------------------*/
  2910                        ;/* exFAT: Accessing FAT and Allocation Bitmap    
                                            */
  2911                        ;/*-----------------------------------------------
                    ------------------------*/
  2912                        ;
  2913                        ;/*--------------------------------------*/
  2914                        ;/* Find a contiguous free cluster block */
  2915                        ;/*--------------------------------------*/
  2916                        ;
  2917                        ;static DWORD find_bitmap (	/* 0:Not found, 
                    2..:Cluster block found, 0xFFFFFFFF:Disk error */
  2918                        ;	FATFS* fs,	/* Filesystem object */
  2919                        ;	DWORD clst,	/* Cluster number to scan from *
                    /
  2920                        ;	DWORD ncl	/* Number of contiguous clusters
                     to find (1..) */
  2921                        ;)
  2922                        ;{
  2923                        ;	BYTE bm, bv;
  2924                        ;	UINT i;
  2925                        ;	DWORD val, scl, ctr;
  2926                        ;
  2927                        ;
  2928                        ;	clst -= 2;	/* The first bit in the bitmap c
                    orresponds to cluster #2 */
  2929                        ;	if (clst >= fs->n_fatent - 2) clst = 0;
  2930                        ;	scl = val = clst; ctr = 0;
  2931                        ;	for (;;) {
  2932                        ;		if (move_window(fs, fs->bitbase + val / 
                    8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
  2933                        ;		i = val / 8 % SS(fs); bm = 1 << (val % 8
                    );
  2934                        ;		do {
  Thu May 20 2021 21:37                                                Page 65


  2935                        ;			do {
  2936                        ;				bv = fs->win[i] & bm; bm
                     <<= 1;		/* Get bit value */
  2937                        ;				if (++val >= fs->n_faten
                    t - 2) {	/* Next cluster (with wrap-around) */
  2938                        ;					val = 0; bm = 0;
                     i = SS(fs);
  2939                        ;				}
  2940                        ;				if (bv == 0) {	/* Is it
                     a free cluster? */
  2941                        ;					if (++ctr == ncl
                    ) return scl + 2;	/* Check if run length is sufficient for
                     required */
  2942                        ;				} else {
  2943                        ;					scl = val; ctr =
                     0;		/* Encountered a cluster in-use, restart to scan
                     */
  2944                        ;				}
  2945                        ;				if (val == clst) return 
                    0;	/* All cluster scanned? */
  2946                        ;			} while (bm != 0);
  2947                        ;			bm = 1;
  2948                        ;		} while (++i < SS(fs));
  2949                        ;	}
  2950                        ;}
  2951                        ;
  2952                        ;
  2953                        ;/*----------------------------------------*/
  2954                        ;/* Set/Clear a block of allocation bitmap */
  2955                        ;/*----------------------------------------*/
  2956                        ;
  2957                        ;static FRESULT change_bitmap (
  2958                        ;	FATFS* fs,	/* Filesystem object */
  2959                        ;	DWORD clst,	/* Cluster number to change from
                     */
  2960                        ;	DWORD ncl,	/* Number of clusters to be chan
                    ged */
  2961                        ;	int bv		/* bit value to be set (0 or 1) 
                    */
  2962                        ;)
  2963                        ;{
  2964                        ;	BYTE bm;
  2965                        ;	UINT i;
  2966                        ;	LBA_t sect;
  2967                        ;
  2968                        ;
  2969                        ;	clst -= 2;	/* The first bit corresponds to 
                    cluster #2 */
  2970                        ;	sect = fs->bitbase + clst / 8 / SS(fs);	/* Secto
                    r address */
  2971                        ;	i = clst / 8 % SS(fs);				
                    	/* Byte offset in the sector */
  2972                        ;	bm = 1 << (clst % 8);				
                    	/* Bit mask in the byte */
  2973                        ;	for (;;) {
  2974                        ;		if (move_window(fs, sect++) != FR_OK) re
                    turn FR_DISK_ERR;
  2975                        ;		do {
  Thu May 20 2021 21:37                                                Page 66


  2976                        ;			do {
  2977                        ;				if (bv == (int)((fs->win
                    [i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected v
                    alue? */
  2978                        ;				fs->win[i] ^= bm;	
                    /* Flip the bit */
  2979                        ;				fs->wflag = 1;
  2980                        ;				if (--ncl == 0) return F
                    R_OK;	/* All bits processed? */
  2981                        ;			} while (bm <<= 1);		
                    /* Next bit */
  2982                        ;			bm = 1;
  2983                        ;		} while (++i < SS(fs));		/* Next 
                    byte */
  2984                        ;		i = 0;
  2985                        ;	}
  2986                        ;}
  2987                        ;
  2988                        ;
  2989                        ;/*---------------------------------------------*/
  2990                        ;/* Fill the first fragment of the FAT chain    */
  2991                        ;/*---------------------------------------------*/
  2992                        ;
  2993                        ;static FRESULT fill_first_frag (
  2994                        ;	FFOBJID* obj	/* Pointer to the corresponding 
                    object */
  2995                        ;)
  2996                        ;{
  2997                        ;	FRESULT res;
  2998                        ;	DWORD cl, n;
  2999                        ;
  3000                        ;
  3001                        ;	if (obj->stat == 3) {	/* Has the object been c
                    hanged 'fragmented' in this session? */
  3002                        ;		for (cl = obj->sclust, n = obj->n_cont; 
                    n; cl++, n--) {	/* Create cluster chain on the FAT */
  3003                        ;			res = put_fat(obj->fs, cl, cl + 
                    1);
  3004                        ;			if (res != FR_OK) return res;
  3005                        ;		}
  3006                        ;		obj->stat = 0;	/* Change status 'FAT ch
                    ain is valid' */
  3007                        ;	}
  3008                        ;	return FR_OK;
  3009                        ;}
  3010                        ;
  3011                        ;
  3012                        ;/*---------------------------------------------*/
  3013                        ;/* Fill the last fragment of the FAT chain     */
  3014                        ;/*---------------------------------------------*/
  3015                        ;
  3016                        ;static FRESULT fill_last_frag (
  3017                        ;	FFOBJID* obj,	/* Pointer to the corresponding 
                    object */
  3018                        ;	DWORD lcl,		/* Last cluster of the f
                    ragment */
  3019                        ;	DWORD term		/* Value to set the last
                     FAT entry */
  Thu May 20 2021 21:37                                                Page 67


  3020                        ;)
  3021                        ;{
  3022                        ;	FRESULT res;
  3023                        ;
  3024                        ;
  3025                        ;	while (obj->n_frag > 0) {	/* Create the ch
                    ain of last fragment */
  3026                        ;		res = put_fat(obj->fs, lcl - obj->n_frag
                     + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
  3027                        ;		if (res != FR_OK) return res;
  3028                        ;		obj->n_frag--;
  3029                        ;	}
  3030                        ;	return FR_OK;
  3031                        ;}
  3032                        ;
  3033                        ;#endif	/* FF_FS_EXFAT && !FF_FS_READONLY */
  3034                        ;
  3035                        ;
  3036                        ;
  3037                        ;#if !FF_FS_READONLY
  3038                        ;/*-----------------------------------------------
                    ------------------------*/
  3039                        ;/* FAT handling - Remove a cluster chain         
                                            */
  3040                        ;/*-----------------------------------------------
                    ------------------------*/
  3041                        ;
  3042                        ;static FRESULT remove_chain (	/* FR_OK(0):succ
                    eeded, !=0:error */
  3043                        ;	FFOBJID* obj,		/* Corresponding object 
                    */
  3044                        ;	DWORD clst,			/* Cluster to re
                    move a chain from */
  3045                        ;	DWORD pclst			/* Previous clus
                    ter of clst (0 if entire chain) */
  3046                        ;)
  3047                        ;{
  3048                        	code
  3049                        	func
  3050                        ~~remove_chain:
  3051                        	longa	on
  3052                        	longi	on
  3053 00:0B0C: 3B           	tsc
  3054 00:0B0D: 38           	sec
  3055 00:0B0E: E9 0E 00     	sbc	#L83
  3056 00:0B11: 1B           	tcs
  3057 00:0B12: 0B           	phd
  3058 00:0B13: 5B           	tcd
  3059             00000004   obj_0	set	4
  3060             00000008   clst_0	set	8
  3061             0000000C   pclst_0	set	12
  3062                        ;	FRESULT res = FR_OK;
  3063                        ;	DWORD nxt;
  3064                        ;	FATFS *fs = obj->fs;
  3065                        ;#if FF_FS_EXFAT || FF_USE_TRIM
  3066                        ;	DWORD scl = clst, ecl = clst;
  3067                        ;#endif
  3068                        ;#if FF_USE_TRIM
  Thu May 20 2021 21:37                                                Page 68


  3069                        ;	LBA_t rt[2];
  3070                        ;#endif
  3071                        ;
  3072                        ;	if (clst < 2 || clst >= fs->n_fatent) return FR_
                    INT_ERR;	/* Check if in valid range */
  3073             00000000   res_1	set	0
  3074             00000002   nxt_1	set	2
  3075             00000006   fs_1	set	6
  3076 00:0B14: 64 05        	stz	<L84+res_1
  3077 00:0B16: A7 12        	lda	[<L83+obj_0]
  3078 00:0B18: 85 0B        	sta	<L84+fs_1
  3079 00:0B1A: A0 02 00     	ldy	#$2
  3080 00:0B1D: B7 12        	lda	[<L83+obj_0],Y
  3081 00:0B1F: 85 0D        	sta	<L84+fs_1+2
  3082 00:0B21: A5 16        	lda	<L83+clst_0
  3083 00:0B23: C9 02 00     	cmp	#<$2
  3084 00:0B26: A5 18        	lda	<L83+clst_0+2
  3085 00:0B28: E9 00 00     	sbc	#^$2
  3086 00:0B2B: B0 03        	bcs	L86
  3087 00:0B2D: 82 13 00     	brl	L85
  3088                        L86:
  3089 00:0B30: A5 16        	lda	<L83+clst_0
  3090 00:0B32: A0 13 00     	ldy	#$13
  3091 00:0B35: D7 0B        	cmp	[<L84+fs_1],Y
  3092 00:0B37: A5 18        	lda	<L83+clst_0+2
  3093 00:0B39: A0 15 00     	ldy	#$15
  3094 00:0B3C: F7 0B        	sbc	[<L84+fs_1],Y
  3095 00:0B3E: B0 03        	bcs	L87
  3096 00:0B40: 82 15 00     	brl	L10030
  3097                        L87:
  3098                        L85:
  3099 00:0B43: A9 02 00     	lda	#$2
  3100                        L88:
  3101 00:0B46: A8           	tay
  3102 00:0B47: A5 10        	lda	<L83+2
  3103 00:0B49: 85 1C        	sta	<L83+2+12
  3104 00:0B4B: A5 0F        	lda	<L83+1
  3105 00:0B4D: 85 1B        	sta	<L83+1+12
  3106 00:0B4F: 2B           	pld
  3107 00:0B50: 3B           	tsc
  3108 00:0B51: 18           	clc
  3109 00:0B52: 69 1A 00     	adc	#L83+12
  3110 00:0B55: 1B           	tcs
  3111 00:0B56: 98           	tya
  3112 00:0B57: 6B           	rtl
  3113                        ;
  3114                        ;	/* Mark the previous cluster 'EOC' on the FAT if
                     it exists */
  3115                        ;	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type !
                    = FS_EXFAT || obj->stat != 2)) {
  3116                        L10030:
  3117 00:0B58: A5 1A        	lda	<L83+pclst_0
  3118 00:0B5A: 05 1C        	ora	<L83+pclst_0+2
  3119 00:0B5C: D0 03        	bne	L89
  3120 00:0B5E: 82 40 00     	brl	L10031
  3121                        L89:
  3122 00:0B61: 82 1D 00     	brl	L90
  3123 00:0B64: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 69


  3124                        	longa	off
  3125 00:0B66: A7 0B        	lda	[<L84+fs_1]
  3126 00:0B68: C9 04        	cmp	#<$4
  3127 00:0B6A: C2 20        	rep	#$20
  3128                        	longa	on
  3129 00:0B6C: F0 03        	beq	L91
  3130 00:0B6E: 82 10 00     	brl	L90
  3131                        L91:
  3132 00:0B71: E2 20        	sep	#$20
  3133                        	longa	off
  3134 00:0B73: A0 07 00     	ldy	#$7
  3135 00:0B76: B7 12        	lda	[<L83+obj_0],Y
  3136 00:0B78: C9 02        	cmp	#<$2
  3137 00:0B7A: C2 20        	rep	#$20
  3138                        	longa	on
  3139 00:0B7C: D0 03        	bne	L92
  3140 00:0B7E: 82 20 00     	brl	L10031
  3141                        L92:
  3142                        L90:
  3143                        ;		res = put_fat(fs, pclst, 0xFFFFFFFF);
  3144 00:0B81: F4 FF FF     	pea	#^$ffffffff
  3145 00:0B84: F4 FF FF     	pea	#<$ffffffff
  3146 00:0B87: D4 1C        	pei	<L83+pclst_0+2
  3147 00:0B89: D4 1A        	pei	<L83+pclst_0
  3148 00:0B8B: D4 0D        	pei	<L84+fs_1+2
  3149 00:0B8D: D4 0B        	pei	<L84+fs_1
  3150 00:0B8F: 22 xx xx xx  	jsl	~~put_fat
  3151 00:0B93: 85 05        	sta	<L84+res_1
  3152                        ;		if (res != FR_OK) return res;
  3153 00:0B95: A5 05        	lda	<L84+res_1
  3154 00:0B97: D0 03        	bne	L93
  3155 00:0B99: 82 05 00     	brl	L10032
  3156                        L93:
  3157 00:0B9C: A5 05        	lda	<L84+res_1
  3158 00:0B9E: 82 A5 FF     	brl	L88
  3159                        ;	}
  3160                        L10032:
  3161                        ;
  3162                        ;	/* Remove the chain */
  3163                        ;	do {
  3164                        L10031:
  3165                        L10035:
  3166                        ;		nxt = get_fat(obj, clst);		
                    	/* Get cluster status */
  3167 00:0BA1: D4 18        	pei	<L83+clst_0+2
  3168 00:0BA3: D4 16        	pei	<L83+clst_0
  3169 00:0BA5: D4 14        	pei	<L83+obj_0+2
  3170 00:0BA7: D4 12        	pei	<L83+obj_0
  3171 00:0BA9: 22 xx xx xx  	jsl	~~get_fat
  3172 00:0BAD: 85 07        	sta	<L84+nxt_1
  3173 00:0BAF: 86 09        	stx	<L84+nxt_1+2
  3174                        ;		if (nxt == 0) break;			
                    	/* Empty cluster? */
  3175 00:0BB1: A5 07        	lda	<L84+nxt_1
  3176 00:0BB3: 05 09        	ora	<L84+nxt_1+2
  3177 00:0BB5: D0 03        	bne	L94
  3178 00:0BB7: 82 D5 00     	brl	L10034
  3179                        L94:
  Thu May 20 2021 21:37                                                Page 70


  3180                        ;		if (nxt == 1) return FR_INT_ERR;	
                    /* Internal error? */
  3181 00:0BBA: A5 07        	lda	<L84+nxt_1
  3182 00:0BBC: C9 01 00     	cmp	#<$1
  3183 00:0BBF: D0 05        	bne	L95
  3184 00:0BC1: A5 09        	lda	<L84+nxt_1+2
  3185 00:0BC3: C9 00 00     	cmp	#^$1
  3186                        L95:
  3187 00:0BC6: F0 03        	beq	L96
  3188 00:0BC8: 82 06 00     	brl	L10036
  3189                        L96:
  3190 00:0BCB: A9 02 00     	lda	#$2
  3191 00:0BCE: 82 75 FF     	brl	L88
  3192                        ;		if (nxt == 0xFFFFFFFF) return FR_DISK_ER
                    R;	/* Disk error? */
  3193                        L10036:
  3194 00:0BD1: A5 07        	lda	<L84+nxt_1
  3195 00:0BD3: C9 FF FF     	cmp	#<$ffffffff
  3196 00:0BD6: D0 05        	bne	L97
  3197 00:0BD8: A5 09        	lda	<L84+nxt_1+2
  3198 00:0BDA: C9 FF FF     	cmp	#^$ffffffff
  3199                        L97:
  3200 00:0BDD: F0 03        	beq	L98
  3201 00:0BDF: 82 06 00     	brl	L10037
  3202                        L98:
  3203 00:0BE2: A9 01 00     	lda	#$1
  3204 00:0BE5: 82 5E FF     	brl	L88
  3205                        ;		if (!FF_FS_EXFAT || fs->fs_type != FS_EX
                    FAT) {
  3206                        L10037:
  3207 00:0BE8: 82 0D 00     	brl	L99
  3208 00:0BEB: E2 20        	sep	#$20
  3209                        	longa	off
  3210 00:0BED: A7 0B        	lda	[<L84+fs_1]
  3211 00:0BEF: C9 04        	cmp	#<$4
  3212 00:0BF1: C2 20        	rep	#$20
  3213                        	longa	on
  3214 00:0BF3: D0 03        	bne	L100
  3215 00:0BF5: 82 20 00     	brl	L10038
  3216                        L100:
  3217                        L99:
  3218                        ;			res = put_fat(fs, clst, 0);	
                    	/* Mark the cluster 'free' on the FAT */
  3219 00:0BF8: F4 00 00     	pea	#^$0
  3220 00:0BFB: F4 00 00     	pea	#<$0
  3221 00:0BFE: D4 18        	pei	<L83+clst_0+2
  3222 00:0C00: D4 16        	pei	<L83+clst_0
  3223 00:0C02: D4 0D        	pei	<L84+fs_1+2
  3224 00:0C04: D4 0B        	pei	<L84+fs_1
  3225 00:0C06: 22 xx xx xx  	jsl	~~put_fat
  3226 00:0C0A: 85 05        	sta	<L84+res_1
  3227                        ;			if (res != FR_OK) return res;
  3228 00:0C0C: A5 05        	lda	<L84+res_1
  3229 00:0C0E: D0 03        	bne	L101
  3230 00:0C10: 82 05 00     	brl	L10039
  3231                        L101:
  3232 00:0C13: A5 05        	lda	<L84+res_1
  3233 00:0C15: 82 2E FF     	brl	L88
  Thu May 20 2021 21:37                                                Page 71


  3234                        ;		}
  3235                        L10039:
  3236                        ;		if (fs->free_clst < fs->n_fatent - 2) {	
                    /* Update FSINFO */
  3237                        L10038:
  3238 00:0C18: 18           	clc
  3239 00:0C19: A9 FE FF     	lda	#$fffe
  3240 00:0C1C: A0 13 00     	ldy	#$13
  3241 00:0C1F: 77 0B        	adc	[<L84+fs_1],Y
  3242 00:0C21: 85 01        	sta	<R0
  3243 00:0C23: A9 FF FF     	lda	#$ffff
  3244 00:0C26: A0 15 00     	ldy	#$15
  3245 00:0C29: 77 0B        	adc	[<L84+fs_1],Y
  3246 00:0C2B: 85 03        	sta	<R0+2
  3247 00:0C2D: A0 0F 00     	ldy	#$f
  3248 00:0C30: B7 0B        	lda	[<L84+fs_1],Y
  3249 00:0C32: C5 01        	cmp	<R0
  3250 00:0C34: A0 11 00     	ldy	#$11
  3251 00:0C37: B7 0B        	lda	[<L84+fs_1],Y
  3252 00:0C39: E5 03        	sbc	<R0+2
  3253 00:0C3B: 90 03        	bcc	L102
  3254 00:0C3D: 82 34 00     	brl	L10040
  3255                        L102:
  3256                        ;			fs->free_clst++;
  3257 00:0C40: 18           	clc
  3258 00:0C41: A9 01 00     	lda	#$1
  3259 00:0C44: A0 0F 00     	ldy	#$f
  3260 00:0C47: 77 0B        	adc	[<L84+fs_1],Y
  3261 00:0C49: A0 0F 00     	ldy	#$f
  3262 00:0C4C: 97 0B        	sta	[<L84+fs_1],Y
  3263 00:0C4E: A9 00 00     	lda	#$0
  3264 00:0C51: A0 11 00     	ldy	#$11
  3265 00:0C54: 77 0B        	adc	[<L84+fs_1],Y
  3266 00:0C56: A0 11 00     	ldy	#$11
  3267 00:0C59: 97 0B        	sta	[<L84+fs_1],Y
  3268                        ;			fs->fsi_flag |= 1;
  3269 00:0C5B: 18           	clc
  3270 00:0C5C: A9 04 00     	lda	#$4
  3271 00:0C5F: 65 0B        	adc	<L84+fs_1
  3272 00:0C61: 85 01        	sta	<R0
  3273 00:0C63: A9 00 00     	lda	#$0
  3274 00:0C66: 65 0D        	adc	<L84+fs_1+2
  3275 00:0C68: 85 03        	sta	<R0+2
  3276 00:0C6A: E2 20        	sep	#$20
  3277                        	longa	off
  3278 00:0C6C: A7 01        	lda	[<R0]
  3279 00:0C6E: 09 01        	ora	#<$1
  3280 00:0C70: 87 01        	sta	[<R0]
  3281 00:0C72: C2 20        	rep	#$20
  3282                        	longa	on
  3283                        ;		}
  3284                        ;#if FF_FS_EXFAT || FF_USE_TRIM
  3285                        ;		if (ecl + 1 == nxt) {	/* Is next clust
                    er contiguous? */
  3286                        ;			ecl = nxt;
  3287                        ;		} else {				
                    /* End of contiguous cluster block */
  3288                        ;#if FF_FS_EXFAT
  Thu May 20 2021 21:37                                                Page 72


  3289                        ;			if (fs->fs_type == FS_EXFAT) {
  3290                        ;				res = change_bitmap(fs, 
                    scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free'
                     on the bitmap */
  3291                        ;				if (res != FR_OK) return
                     res;
  3292                        ;			}
  3293                        ;#endif
  3294                        ;#if FF_USE_TRIM
  3295                        ;			rt[0] = clst2sect(fs, scl);	
                    				/* Start of data area to be free
                    d */
  3296                        ;			rt[1] = clst2sect(fs, ecl) + fs-
                    >csize - 1;	/* End of data area to be freed */
  3297                        ;			disk_ioctl(fs->pdrv, CTRL_TRIM, 
                    rt);		/* Inform storage device that the data i
                    n the block may be erased */
  3298                        ;#endif
  3299                        ;			scl = ecl = nxt;
  3300                        ;		}
  3301                        ;#endif
  3302                        ;		clst = nxt;				
                    	/* Next cluster */
  3303                        L10040:
  3304 00:0C74: A5 07        	lda	<L84+nxt_1
  3305 00:0C76: 85 16        	sta	<L83+clst_0
  3306 00:0C78: A5 09        	lda	<L84+nxt_1+2
  3307 00:0C7A: 85 18        	sta	<L83+clst_0+2
  3308                        ;	} while (clst < fs->n_fatent);	/* Repeat while 
                    not the last link */
  3309                        L10033:
  3310 00:0C7C: A5 16        	lda	<L83+clst_0
  3311 00:0C7E: A0 13 00     	ldy	#$13
  3312 00:0C81: D7 0B        	cmp	[<L84+fs_1],Y
  3313 00:0C83: A5 18        	lda	<L83+clst_0+2
  3314 00:0C85: A0 15 00     	ldy	#$15
  3315 00:0C88: F7 0B        	sbc	[<L84+fs_1],Y
  3316 00:0C8A: B0 03        	bcs	L103
  3317 00:0C8C: 82 12 FF     	brl	L10035
  3318                        L103:
  3319                        L10034:
  3320                        ;
  3321                        ;#if FF_FS_EXFAT
  3322                        ;	/* Some post processes for chain status */
  3323                        ;	if (fs->fs_type == FS_EXFAT) {
  3324                        ;		if (pclst == 0) {	/* Has the entir
                    e chain been removed? */
  3325                        ;			obj->stat = 0;		/* Chang
                    e the chain status 'initial' */
  3326                        ;		} else {
  3327                        ;			if (obj->stat == 0) {	/* Is it
                     a fragmented chain from the beginning of this session? */
  3328                        ;				clst = obj->sclust;	
                    	/* Follow the chain to check if it gets contiguous */
  3329                        ;				while (clst != pclst) {
  3330                        ;					nxt = get_fat(ob
                    j, clst);
  3331                        ;					if (nxt < 2) ret
  Thu May 20 2021 21:37                                                Page 73


                    urn FR_INT_ERR;
  3332                        ;					if (nxt == 0xFFF
                    FFFFF) return FR_DISK_ERR;
  3333                        ;					if (nxt != clst 
                    + 1) break;	/* Not contiguous? */
  3334                        ;					clst++;
  3335                        ;				}
  3336                        ;				if (clst == pclst) {	
                    /* Has the chain got contiguous again? */
  3337                        ;					obj->stat = 2;	
                    	/* Change the chain status 'contiguous' */
  3338                        ;				}
  3339                        ;			} else {
  3340                        ;				if (obj->stat == 3 && pc
                    lst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	
                    /* Was the chain fragmented in this session and got contiguo
                    us again? */
  3341                        ;					obj->stat = 2;	
                    /* Change the chain status 'contiguous' */
  3342                        ;				}
  3343                        ;			}
  3344                        ;		}
  3345                        ;	}
  3346                        ;#endif
  3347                        ;	return FR_OK;
  3348 00:0C8F: A9 00 00     	lda	#$0
  3349 00:0C92: 82 B1 FE     	brl	L88
  3350                        ;}
  3351             0000000E   L83	equ	14
  3352             00000005   L84	equ	5
  3353                        	ends
  3354                        	efunc
  3355                        ;
  3356                        ;
  3357                        ;
  3358                        ;
  3359                        ;/*-----------------------------------------------
                    ------------------------*/
  3360                        ;/* FAT handling - Stretch a chain or Create a new
                     chain                  */
  3361                        ;/*-----------------------------------------------
                    ------------------------*/
  3362                        ;
  3363                        ;static DWORD create_chain (	/* 0:No free clu
                    ster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New clust
                    er# */
  3364                        ;	FFOBJID* obj,		/* Corresponding object 
                    */
  3365                        ;	DWORD clst			/* Cluster# to s
                    tretch, 0:Create a new chain */
  3366                        ;)
  3367                        ;{
  3368                        	code
  3369                        	func
  3370                        ~~create_chain:
  3371                        	longa	on
  3372                        	longi	on
  3373 00:0C95: 3B           	tsc
  Thu May 20 2021 21:37                                                Page 74


  3374 00:0C96: 38           	sec
  3375 00:0C97: E9 16 00     	sbc	#L104
  3376 00:0C9A: 1B           	tcs
  3377 00:0C9B: 0B           	phd
  3378 00:0C9C: 5B           	tcd
  3379             00000004   obj_0	set	4
  3380             00000008   clst_0	set	8
  3381                        ;	DWORD cs, ncl, scl;
  3382                        ;	FRESULT res;
  3383                        ;	FATFS *fs = obj->fs;
  3384                        ;
  3385                        ;
  3386                        ;	if (clst == 0) {	/* Create a new chain */
  3387             00000000   cs_1	set	0
  3388             00000004   ncl_1	set	4
  3389             00000008   scl_1	set	8
  3390             0000000C   res_1	set	12
  3391             0000000E   fs_1	set	14
  3392 00:0C9D: A7 1A        	lda	[<L104+obj_0]
  3393 00:0C9F: 85 13        	sta	<L105+fs_1
  3394 00:0CA1: A0 02 00     	ldy	#$2
  3395 00:0CA4: B7 1A        	lda	[<L104+obj_0],Y
  3396 00:0CA6: 85 15        	sta	<L105+fs_1+2
  3397 00:0CA8: A5 1E        	lda	<L104+clst_0
  3398 00:0CAA: 05 20        	ora	<L104+clst_0+2
  3399 00:0CAC: F0 03        	beq	L106
  3400 00:0CAE: 82 37 00     	brl	L10041
  3401                        L106:
  3402                        ;		scl = fs->last_clst;			
                    	/* Suggested cluster to start to find */
  3403 00:0CB1: A0 0B 00     	ldy	#$b
  3404 00:0CB4: B7 13        	lda	[<L105+fs_1],Y
  3405 00:0CB6: 85 0D        	sta	<L105+scl_1
  3406 00:0CB8: A0 0D 00     	ldy	#$d
  3407 00:0CBB: B7 13        	lda	[<L105+fs_1],Y
  3408 00:0CBD: 85 0F        	sta	<L105+scl_1+2
  3409                        ;		if (scl == 0 || scl >= fs->n_fatent) scl
                     = 1;
  3410 00:0CBF: A5 0D        	lda	<L105+scl_1
  3411 00:0CC1: 05 0F        	ora	<L105+scl_1+2
  3412 00:0CC3: D0 03        	bne	L108
  3413 00:0CC5: 82 13 00     	brl	L107
  3414                        L108:
  3415 00:0CC8: A5 0D        	lda	<L105+scl_1
  3416 00:0CCA: A0 13 00     	ldy	#$13
  3417 00:0CCD: D7 13        	cmp	[<L105+fs_1],Y
  3418 00:0CCF: A5 0F        	lda	<L105+scl_1+2
  3419 00:0CD1: A0 15 00     	ldy	#$15
  3420 00:0CD4: F7 13        	sbc	[<L105+fs_1],Y
  3421 00:0CD6: B0 03        	bcs	L109
  3422 00:0CD8: 82 0A 00     	brl	L10042
  3423                        L109:
  3424                        L107:
  3425 00:0CDB: A9 01 00     	lda	#$1
  3426 00:0CDE: 85 0D        	sta	<L105+scl_1
  3427 00:0CE0: A9 00 00     	lda	#$0
  3428 00:0CE3: 85 0F        	sta	<L105+scl_1+2
  3429                        ;	}
  Thu May 20 2021 21:37                                                Page 75


  3430                        L10042:
  3431                        ;	else {				/* Stretch a cha
                    in */
  3432 00:0CE5: 82 72 00     	brl	L10043
  3433                        L10041:
  3434                        ;		cs = get_fat(obj, clst);		
                    	/* Check the cluster status */
  3435 00:0CE8: D4 20        	pei	<L104+clst_0+2
  3436 00:0CEA: D4 1E        	pei	<L104+clst_0
  3437 00:0CEC: D4 1C        	pei	<L104+obj_0+2
  3438 00:0CEE: D4 1A        	pei	<L104+obj_0
  3439 00:0CF0: 22 xx xx xx  	jsl	~~get_fat
  3440 00:0CF4: 85 05        	sta	<L105+cs_1
  3441 00:0CF6: 86 07        	stx	<L105+cs_1+2
  3442                        ;		if (cs < 2) return 1;			
                    	/* Test for insanity */
  3443 00:0CF8: A5 05        	lda	<L105+cs_1
  3444 00:0CFA: C9 02 00     	cmp	#<$2
  3445 00:0CFD: A5 07        	lda	<L105+cs_1+2
  3446 00:0CFF: E9 00 00     	sbc	#^$2
  3447 00:0D02: 90 03        	bcc	L110
  3448 00:0D04: 82 19 00     	brl	L10044
  3449                        L110:
  3450 00:0D07: A9 00 00     	lda	#$0
  3451 00:0D0A: AA           	tax
  3452 00:0D0B: A9 01 00     	lda	#$1
  3453                        L111:
  3454 00:0D0E: A8           	tay
  3455 00:0D0F: A5 18        	lda	<L104+2
  3456 00:0D11: 85 20        	sta	<L104+2+8
  3457 00:0D13: A5 17        	lda	<L104+1
  3458 00:0D15: 85 1F        	sta	<L104+1+8
  3459 00:0D17: 2B           	pld
  3460 00:0D18: 3B           	tsc
  3461 00:0D19: 18           	clc
  3462 00:0D1A: 69 1E 00     	adc	#L104+8
  3463 00:0D1D: 1B           	tcs
  3464 00:0D1E: 98           	tya
  3465 00:0D1F: 6B           	rtl
  3466                        ;		if (cs == 0xFFFFFFFF) return cs;	
                    /* Test for disk error */
  3467                        L10044:
  3468 00:0D20: A5 05        	lda	<L105+cs_1
  3469 00:0D22: C9 FF FF     	cmp	#<$ffffffff
  3470 00:0D25: D0 05        	bne	L112
  3471 00:0D27: A5 07        	lda	<L105+cs_1+2
  3472 00:0D29: C9 FF FF     	cmp	#^$ffffffff
  3473                        L112:
  3474 00:0D2C: F0 03        	beq	L113
  3475 00:0D2E: 82 07 00     	brl	L10045
  3476                        L113:
  3477 00:0D31: A6 07        	ldx	<L105+cs_1+2
  3478 00:0D33: A5 05        	lda	<L105+cs_1
  3479 00:0D35: 82 D6 FF     	brl	L111
  3480                        ;		if (cs < fs->n_fatent) return cs;	
                    /* It is already followed by next cluster */
  3481                        L10045:
  3482 00:0D38: A5 05        	lda	<L105+cs_1
  Thu May 20 2021 21:37                                                Page 76


  3483 00:0D3A: A0 13 00     	ldy	#$13
  3484 00:0D3D: D7 13        	cmp	[<L105+fs_1],Y
  3485 00:0D3F: A5 07        	lda	<L105+cs_1+2
  3486 00:0D41: A0 15 00     	ldy	#$15
  3487 00:0D44: F7 13        	sbc	[<L105+fs_1],Y
  3488 00:0D46: 90 03        	bcc	L114
  3489 00:0D48: 82 07 00     	brl	L10046
  3490                        L114:
  3491 00:0D4B: A6 07        	ldx	<L105+cs_1+2
  3492 00:0D4D: A5 05        	lda	<L105+cs_1
  3493 00:0D4F: 82 BC FF     	brl	L111
  3494                        ;		scl = clst;				
                    			/* Cluster to start to find */
  3495                        L10046:
  3496 00:0D52: A5 1E        	lda	<L104+clst_0
  3497 00:0D54: 85 0D        	sta	<L105+scl_1
  3498 00:0D56: A5 20        	lda	<L104+clst_0+2
  3499 00:0D58: 85 0F        	sta	<L105+scl_1+2
  3500                        ;	}
  3501                        L10043:
  3502                        ;	if (fs->free_clst == 0) return 0;		
                    /* No free cluster */
  3503 00:0D5A: A0 0F 00     	ldy	#$f
  3504 00:0D5D: B7 13        	lda	[<L105+fs_1],Y
  3505 00:0D5F: A0 11 00     	ldy	#$11
  3506 00:0D62: 17 13        	ora	[<L105+fs_1],Y
  3507 00:0D64: F0 03        	beq	L115
  3508 00:0D66: 82 0A 00     	brl	L10047
  3509                        L115:
  3510 00:0D69: A9 00 00     	lda	#$0
  3511 00:0D6C: AA           	tax
  3512 00:0D6D: A9 00 00     	lda	#$0
  3513 00:0D70: 82 9B FF     	brl	L111
  3514                        ;
  3515                        ;#if FF_FS_EXFAT
  3516                        ;	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT 
                    volume */
  3517                        ;		ncl = find_bitmap(fs, scl, 1);		
                    		/* Find a free cluster */
  3518                        ;		if (ncl == 0 || ncl == 0xFFFFFFFF) retur
                    n ncl;	/* No free cluster or hard error? */
  3519                        ;		res = change_bitmap(fs, ncl, 1, 1);	
                    		/* Mark the cluster 'in use' */
  3520                        ;		if (res == FR_INT_ERR) return 1;
  3521                        ;		if (res == FR_DISK_ERR) return 0xFFFFFFF
                    F;
  3522                        ;		if (clst == 0) {			
                    				/* Is it a new chain? */
  3523                        ;			obj->stat = 2;			
                    				/* Set status 'contiguous' */
  3524                        ;		} else {				
                    					/* It is a stretched cha
                    in */
  3525                        ;			if (obj->stat == 2 && ncl != scl
                     + 1) {	/* Is the chain got fragmented? */
  3526                        ;				obj->n_cont = scl - obj-
                    >sclust;	/* Set size of the contiguous part */
  3527                        ;				obj->stat = 3;		
  Thu May 20 2021 21:37                                                Page 77


                    				/* Change status 'just fragmente
                    d' */
  3528                        ;			}
  3529                        ;		}
  3530                        ;		if (obj->stat != 2) {	/* Is the file n
                    on-contiguous? */
  3531                        ;			if (ncl == clst + 1) {	/* Is th
                    e cluster next to previous one? */
  3532                        ;				obj->n_frag = obj->n_fra
                    g ? obj->n_frag + 1 : 2;	/* Increment size of last framge
                    nt */
  3533                        ;			} else {			
                    	/* New fragment */
  3534                        ;				if (obj->n_frag == 0) ob
                    j->n_frag = 1;
  3535                        ;				res = fill_last_frag(obj
                    , clst, ncl);	/* Fill last fragment on the FAT and lin
                    k it to new one */
  3536                        ;				if (res == FR_OK) obj->n
                    _frag = 1;
  3537                        ;			}
  3538                        ;		}
  3539                        ;	} else
  3540                        ;#endif
  3541                        ;	{	/* On the FAT/FAT32 volume */
  3542                        L10047:
  3543                        ;		ncl = 0;
  3544 00:0D73: 64 09        	stz	<L105+ncl_1
  3545 00:0D75: 64 0B        	stz	<L105+ncl_1+2
  3546                        ;		if (scl == clst) {			
                    			/* Stretching an existing chain? */
  3547 00:0D77: A5 0D        	lda	<L105+scl_1
  3548 00:0D79: C5 1E        	cmp	<L104+clst_0
  3549 00:0D7B: D0 04        	bne	L116
  3550 00:0D7D: A5 0F        	lda	<L105+scl_1+2
  3551 00:0D7F: C5 20        	cmp	<L104+clst_0+2
  3552                        L116:
  3553 00:0D81: F0 03        	beq	L117
  3554 00:0D83: 82 AA 00     	brl	L10048
  3555                        L117:
  3556                        ;			ncl = scl + 1;			
                    			/* Test if next cluster is free */
  3557 00:0D86: 18           	clc
  3558 00:0D87: A9 01 00     	lda	#$1
  3559 00:0D8A: 65 0D        	adc	<L105+scl_1
  3560 00:0D8C: 85 09        	sta	<L105+ncl_1
  3561 00:0D8E: A9 00 00     	lda	#$0
  3562 00:0D91: 65 0F        	adc	<L105+scl_1+2
  3563 00:0D93: 85 0B        	sta	<L105+ncl_1+2
  3564                        ;			if (ncl >= fs->n_fatent) ncl = 2
                    ;
  3565 00:0D95: A5 09        	lda	<L105+ncl_1
  3566 00:0D97: A0 13 00     	ldy	#$13
  3567 00:0D9A: D7 13        	cmp	[<L105+fs_1],Y
  3568 00:0D9C: A5 0B        	lda	<L105+ncl_1+2
  3569 00:0D9E: A0 15 00     	ldy	#$15
  3570 00:0DA1: F7 13        	sbc	[<L105+fs_1],Y
  3571 00:0DA3: B0 03        	bcs	L118
  Thu May 20 2021 21:37                                                Page 78


  3572 00:0DA5: 82 0A 00     	brl	L10049
  3573                        L118:
  3574 00:0DA8: A9 02 00     	lda	#$2
  3575 00:0DAB: 85 09        	sta	<L105+ncl_1
  3576 00:0DAD: A9 00 00     	lda	#$0
  3577 00:0DB0: 85 0B        	sta	<L105+ncl_1+2
  3578                        ;			cs = get_fat(obj, ncl);		
                    		/* Get next cluster status */
  3579                        L10049:
  3580 00:0DB2: D4 0B        	pei	<L105+ncl_1+2
  3581 00:0DB4: D4 09        	pei	<L105+ncl_1
  3582 00:0DB6: D4 1C        	pei	<L104+obj_0+2
  3583 00:0DB8: D4 1A        	pei	<L104+obj_0
  3584 00:0DBA: 22 xx xx xx  	jsl	~~get_fat
  3585 00:0DBE: 85 05        	sta	<L105+cs_1
  3586 00:0DC0: 86 07        	stx	<L105+cs_1+2
  3587                        ;			if (cs == 1 || cs == 0xFFFFFFFF)
                     return cs;	/* Test for error */
  3588 00:0DC2: A5 05        	lda	<L105+cs_1
  3589 00:0DC4: C9 01 00     	cmp	#<$1
  3590 00:0DC7: D0 05        	bne	L120
  3591 00:0DC9: A5 07        	lda	<L105+cs_1+2
  3592 00:0DCB: C9 00 00     	cmp	#^$1
  3593                        L120:
  3594 00:0DCE: D0 03        	bne	L121
  3595 00:0DD0: 82 11 00     	brl	L119
  3596                        L121:
  3597 00:0DD3: A5 05        	lda	<L105+cs_1
  3598 00:0DD5: C9 FF FF     	cmp	#<$ffffffff
  3599 00:0DD8: D0 05        	bne	L122
  3600 00:0DDA: A5 07        	lda	<L105+cs_1+2
  3601 00:0DDC: C9 FF FF     	cmp	#^$ffffffff
  3602                        L122:
  3603 00:0DDF: F0 03        	beq	L123
  3604 00:0DE1: 82 07 00     	brl	L10050
  3605                        L123:
  3606                        L119:
  3607 00:0DE4: A6 07        	ldx	<L105+cs_1+2
  3608 00:0DE6: A5 05        	lda	<L105+cs_1
  3609 00:0DE8: 82 23 FF     	brl	L111
  3610                        ;			if (cs != 0) {			
                    			/* Not free? */
  3611                        L10050:
  3612 00:0DEB: A5 05        	lda	<L105+cs_1
  3613 00:0DED: 05 07        	ora	<L105+cs_1+2
  3614 00:0DEF: D0 03        	bne	L124
  3615 00:0DF1: 82 3C 00     	brl	L10051
  3616                        L124:
  3617                        ;				cs = fs->last_clst;	
                    			/* Start at suggested cluster if it is v
                    alid */
  3618 00:0DF4: A0 0B 00     	ldy	#$b
  3619 00:0DF7: B7 13        	lda	[<L105+fs_1],Y
  3620 00:0DF9: 85 05        	sta	<L105+cs_1
  3621 00:0DFB: A0 0D 00     	ldy	#$d
  3622 00:0DFE: B7 13        	lda	[<L105+fs_1],Y
  3623 00:0E00: 85 07        	sta	<L105+cs_1+2
  3624                        ;				if (cs >= 2 && cs < fs->
  Thu May 20 2021 21:37                                                Page 79


                    n_fatent) scl = cs;
  3625 00:0E02: A5 05        	lda	<L105+cs_1
  3626 00:0E04: C9 02 00     	cmp	#<$2
  3627 00:0E07: A5 07        	lda	<L105+cs_1+2
  3628 00:0E09: E9 00 00     	sbc	#^$2
  3629 00:0E0C: B0 03        	bcs	L125
  3630 00:0E0E: 82 1B 00     	brl	L10052
  3631                        L125:
  3632 00:0E11: A5 05        	lda	<L105+cs_1
  3633 00:0E13: A0 13 00     	ldy	#$13
  3634 00:0E16: D7 13        	cmp	[<L105+fs_1],Y
  3635 00:0E18: A5 07        	lda	<L105+cs_1+2
  3636 00:0E1A: A0 15 00     	ldy	#$15
  3637 00:0E1D: F7 13        	sbc	[<L105+fs_1],Y
  3638 00:0E1F: 90 03        	bcc	L126
  3639 00:0E21: 82 08 00     	brl	L10052
  3640                        L126:
  3641 00:0E24: A5 05        	lda	<L105+cs_1
  3642 00:0E26: 85 0D        	sta	<L105+scl_1
  3643 00:0E28: A5 07        	lda	<L105+cs_1+2
  3644 00:0E2A: 85 0F        	sta	<L105+scl_1+2
  3645                        ;				ncl = 0;
  3646                        L10052:
  3647 00:0E2C: 64 09        	stz	<L105+ncl_1
  3648 00:0E2E: 64 0B        	stz	<L105+ncl_1+2
  3649                        ;			}
  3650                        ;		}
  3651                        L10051:
  3652                        ;		if (ncl == 0) {	/* The new cluster canno
                    t be contiguous and find another fragment */
  3653                        L10048:
  3654 00:0E30: A5 09        	lda	<L105+ncl_1
  3655 00:0E32: 05 0B        	ora	<L105+ncl_1+2
  3656 00:0E34: F0 03        	beq	L127
  3657 00:0E36: 82 A0 00     	brl	L10053
  3658                        L127:
  3659                        ;			ncl = scl;	/* Start cluster
                     */
  3660 00:0E39: A5 0D        	lda	<L105+scl_1
  3661 00:0E3B: 85 09        	sta	<L105+ncl_1
  3662 00:0E3D: A5 0F        	lda	<L105+scl_1+2
  3663 00:0E3F: 85 0B        	sta	<L105+ncl_1+2
  3664                        ;			for (;;) {
  3665                        L10054:
  3666                        ;				ncl++;			
                    				/* Next cluster */
  3667 00:0E41: E6 09        	inc	<L105+ncl_1
  3668 00:0E43: D0 02        	bne	L128
  3669 00:0E45: E6 0B        	inc	<L105+ncl_1+2
  3670                        L128:
  3671                        ;				if (ncl >= fs->n_fatent)
                     {		/* Check wrap-around */
  3672 00:0E47: A5 09        	lda	<L105+ncl_1
  3673 00:0E49: A0 13 00     	ldy	#$13
  3674 00:0E4C: D7 13        	cmp	[<L105+fs_1],Y
  3675 00:0E4E: A5 0B        	lda	<L105+ncl_1+2
  3676 00:0E50: A0 15 00     	ldy	#$15
  3677 00:0E53: F7 13        	sbc	[<L105+fs_1],Y
  Thu May 20 2021 21:37                                                Page 80


  3678 00:0E55: B0 03        	bcs	L129
  3679 00:0E57: 82 21 00     	brl	L10056
  3680                        L129:
  3681                        ;					ncl = 2;
  3682 00:0E5A: A9 02 00     	lda	#$2
  3683 00:0E5D: 85 09        	sta	<L105+ncl_1
  3684 00:0E5F: A9 00 00     	lda	#$0
  3685 00:0E62: 85 0B        	sta	<L105+ncl_1+2
  3686                        ;					if (ncl > scl) r
                    eturn 0;	/* No free cluster found? */
  3687 00:0E64: A5 0D        	lda	<L105+scl_1
  3688 00:0E66: C5 09        	cmp	<L105+ncl_1
  3689 00:0E68: A5 0F        	lda	<L105+scl_1+2
  3690 00:0E6A: E5 0B        	sbc	<L105+ncl_1+2
  3691 00:0E6C: 90 03        	bcc	L130
  3692 00:0E6E: 82 0A 00     	brl	L10057
  3693                        L130:
  3694 00:0E71: A9 00 00     	lda	#$0
  3695 00:0E74: AA           	tax
  3696 00:0E75: A9 00 00     	lda	#$0
  3697 00:0E78: 82 93 FE     	brl	L111
  3698                        ;				}
  3699                        L10057:
  3700                        ;				cs = get_fat(obj, ncl);	
                    		/* Get the cluster status */
  3701                        L10056:
  3702 00:0E7B: D4 0B        	pei	<L105+ncl_1+2
  3703 00:0E7D: D4 09        	pei	<L105+ncl_1
  3704 00:0E7F: D4 1C        	pei	<L104+obj_0+2
  3705 00:0E81: D4 1A        	pei	<L104+obj_0
  3706 00:0E83: 22 xx xx xx  	jsl	~~get_fat
  3707 00:0E87: 85 05        	sta	<L105+cs_1
  3708 00:0E89: 86 07        	stx	<L105+cs_1+2
  3709                        ;				if (cs == 0) break;	
                    			/* Found a free cluster? */
  3710 00:0E8B: A5 05        	lda	<L105+cs_1
  3711 00:0E8D: 05 07        	ora	<L105+cs_1+2
  3712 00:0E8F: D0 03        	bne	L131
  3713 00:0E91: 82 45 00     	brl	L10055
  3714                        L131:
  3715                        ;				if (cs == 1 || cs == 0xF
                    FFFFFFF) return cs;	/* Test for error */
  3716 00:0E94: A5 05        	lda	<L105+cs_1
  3717 00:0E96: C9 01 00     	cmp	#<$1
  3718 00:0E99: D0 05        	bne	L133
  3719 00:0E9B: A5 07        	lda	<L105+cs_1+2
  3720 00:0E9D: C9 00 00     	cmp	#^$1
  3721                        L133:
  3722 00:0EA0: D0 03        	bne	L134
  3723 00:0EA2: 82 11 00     	brl	L132
  3724                        L134:
  3725 00:0EA5: A5 05        	lda	<L105+cs_1
  3726 00:0EA7: C9 FF FF     	cmp	#<$ffffffff
  3727 00:0EAA: D0 05        	bne	L135
  3728 00:0EAC: A5 07        	lda	<L105+cs_1+2
  3729 00:0EAE: C9 FF FF     	cmp	#^$ffffffff
  3730                        L135:
  3731 00:0EB1: F0 03        	beq	L136
  Thu May 20 2021 21:37                                                Page 81


  3732 00:0EB3: 82 07 00     	brl	L10058
  3733                        L136:
  3734                        L132:
  3735 00:0EB6: A6 07        	ldx	<L105+cs_1+2
  3736 00:0EB8: A5 05        	lda	<L105+cs_1
  3737 00:0EBA: 82 51 FE     	brl	L111
  3738                        ;				if (ncl == scl) return 0
                    ;		/* No free cluster found? */
  3739                        L10058:
  3740 00:0EBD: A5 09        	lda	<L105+ncl_1
  3741 00:0EBF: C5 0D        	cmp	<L105+scl_1
  3742 00:0EC1: D0 04        	bne	L137
  3743 00:0EC3: A5 0B        	lda	<L105+ncl_1+2
  3744 00:0EC5: C5 0F        	cmp	<L105+scl_1+2
  3745                        L137:
  3746 00:0EC7: F0 03        	beq	L138
  3747 00:0EC9: 82 0A 00     	brl	L10059
  3748                        L138:
  3749 00:0ECC: A9 00 00     	lda	#$0
  3750 00:0ECF: AA           	tax
  3751 00:0ED0: A9 00 00     	lda	#$0
  3752 00:0ED3: 82 38 FE     	brl	L111
  3753                        ;			}
  3754                        L10059:
  3755 00:0ED6: 82 68 FF     	brl	L10054
  3756                        L10055:
  3757                        ;		}
  3758                        ;		res = put_fat(fs, ncl, 0xFFFFFFFF);	
                    	/* Mark the new cluster 'EOC' */
  3759                        L10053:
  3760 00:0ED9: F4 FF FF     	pea	#^$ffffffff
  3761 00:0EDC: F4 FF FF     	pea	#<$ffffffff
  3762 00:0EDF: D4 0B        	pei	<L105+ncl_1+2
  3763 00:0EE1: D4 09        	pei	<L105+ncl_1
  3764 00:0EE3: D4 15        	pei	<L105+fs_1+2
  3765 00:0EE5: D4 13        	pei	<L105+fs_1
  3766 00:0EE7: 22 xx xx xx  	jsl	~~put_fat
  3767 00:0EEB: 85 11        	sta	<L105+res_1
  3768                        ;		if (res == FR_OK && clst != 0) {
  3769 00:0EED: A5 11        	lda	<L105+res_1
  3770 00:0EEF: F0 03        	beq	L139
  3771 00:0EF1: 82 1B 00     	brl	L10060
  3772                        L139:
  3773 00:0EF4: A5 1E        	lda	<L104+clst_0
  3774 00:0EF6: 05 20        	ora	<L104+clst_0+2
  3775 00:0EF8: D0 03        	bne	L140
  3776 00:0EFA: 82 12 00     	brl	L10060
  3777                        L140:
  3778                        ;			res = put_fat(fs, clst, ncl);	
                    	/* Link it from the previous one if needed */
  3779 00:0EFD: D4 0B        	pei	<L105+ncl_1+2
  3780 00:0EFF: D4 09        	pei	<L105+ncl_1
  3781 00:0F01: D4 20        	pei	<L104+clst_0+2
  3782 00:0F03: D4 1E        	pei	<L104+clst_0
  3783 00:0F05: D4 15        	pei	<L105+fs_1+2
  3784 00:0F07: D4 13        	pei	<L105+fs_1
  3785 00:0F09: 22 xx xx xx  	jsl	~~put_fat
  3786 00:0F0D: 85 11        	sta	<L105+res_1
  Thu May 20 2021 21:37                                                Page 82


  3787                        ;		}
  3788                        ;	}
  3789                        L10060:
  3790                        ;
  3791                        ;	if (res == FR_OK) {			/* Updat
                    e FSINFO if function succeeded. */
  3792 00:0F0F: A5 11        	lda	<L105+res_1
  3793 00:0F11: F0 03        	beq	L141
  3794 00:0F13: 82 6D 00     	brl	L10061
  3795                        L141:
  3796                        ;		fs->last_clst = ncl;
  3797 00:0F16: A5 09        	lda	<L105+ncl_1
  3798 00:0F18: A0 0B 00     	ldy	#$b
  3799 00:0F1B: 97 13        	sta	[<L105+fs_1],Y
  3800 00:0F1D: A5 0B        	lda	<L105+ncl_1+2
  3801 00:0F1F: A0 0D 00     	ldy	#$d
  3802 00:0F22: 97 13        	sta	[<L105+fs_1],Y
  3803                        ;		if (fs->free_clst <= fs->n_fatent - 2) f
                    s->free_clst--;
  3804 00:0F24: 18           	clc
  3805 00:0F25: A9 FE FF     	lda	#$fffe
  3806 00:0F28: A0 13 00     	ldy	#$13
  3807 00:0F2B: 77 13        	adc	[<L105+fs_1],Y
  3808 00:0F2D: 85 01        	sta	<R0
  3809 00:0F2F: A9 FF FF     	lda	#$ffff
  3810 00:0F32: A0 15 00     	ldy	#$15
  3811 00:0F35: 77 13        	adc	[<L105+fs_1],Y
  3812 00:0F37: 85 03        	sta	<R0+2
  3813 00:0F39: A5 01        	lda	<R0
  3814 00:0F3B: A0 0F 00     	ldy	#$f
  3815 00:0F3E: D7 13        	cmp	[<L105+fs_1],Y
  3816 00:0F40: A5 03        	lda	<R0+2
  3817 00:0F42: A0 11 00     	ldy	#$11
  3818 00:0F45: F7 13        	sbc	[<L105+fs_1],Y
  3819 00:0F47: B0 03        	bcs	L142
  3820 00:0F49: 82 1B 00     	brl	L10062
  3821                        L142:
  3822 00:0F4C: 18           	clc
  3823 00:0F4D: A9 FF FF     	lda	#$ffff
  3824 00:0F50: A0 0F 00     	ldy	#$f
  3825 00:0F53: 77 13        	adc	[<L105+fs_1],Y
  3826 00:0F55: A0 0F 00     	ldy	#$f
  3827 00:0F58: 97 13        	sta	[<L105+fs_1],Y
  3828 00:0F5A: A9 FF FF     	lda	#$ffff
  3829 00:0F5D: A0 11 00     	ldy	#$11
  3830 00:0F60: 77 13        	adc	[<L105+fs_1],Y
  3831 00:0F62: A0 11 00     	ldy	#$11
  3832 00:0F65: 97 13        	sta	[<L105+fs_1],Y
  3833                        ;		fs->fsi_flag |= 1;
  3834                        L10062:
  3835 00:0F67: 18           	clc
  3836 00:0F68: A9 04 00     	lda	#$4
  3837 00:0F6B: 65 13        	adc	<L105+fs_1
  3838 00:0F6D: 85 01        	sta	<R0
  3839 00:0F6F: A9 00 00     	lda	#$0
  3840 00:0F72: 65 15        	adc	<L105+fs_1+2
  3841 00:0F74: 85 03        	sta	<R0+2
  3842 00:0F76: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 83


  3843                        	longa	off
  3844 00:0F78: A7 01        	lda	[<R0]
  3845 00:0F7A: 09 01        	ora	#<$1
  3846 00:0F7C: 87 01        	sta	[<R0]
  3847 00:0F7E: C2 20        	rep	#$20
  3848                        	longa	on
  3849                        ;	} else {
  3850 00:0F80: 82 26 00     	brl	L10063
  3851                        L10061:
  3852                        ;		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF 
                    : 1;	/* Failed. Generate error status */
  3853 00:0F83: A5 11        	lda	<L105+res_1
  3854 00:0F85: C9 01 00     	cmp	#<$1
  3855 00:0F88: F0 03        	beq	L144
  3856 00:0F8A: 82 09 00     	brl	L143
  3857                        L144:
  3858 00:0F8D: A9 FF FF     	lda	#$ffff
  3859 00:0F90: AA           	tax
  3860 00:0F91: A9 FF FF     	lda	#$ffff
  3861 00:0F94: 80 07        	bra	L145
  3862                        L143:
  3863 00:0F96: A9 00 00     	lda	#$0
  3864 00:0F99: AA           	tax
  3865 00:0F9A: A9 01 00     	lda	#$1
  3866                        L145:
  3867 00:0F9D: 85 01        	sta	<R0
  3868 00:0F9F: 86 03        	stx	<R0+2
  3869 00:0FA1: A5 01        	lda	<R0
  3870 00:0FA3: 85 09        	sta	<L105+ncl_1
  3871 00:0FA5: A5 03        	lda	<R0+2
  3872 00:0FA7: 85 0B        	sta	<L105+ncl_1+2
  3873                        ;	}
  3874                        L10063:
  3875                        ;
  3876                        ;	return ncl;		/* Return new cluster nu
                    mber or error status */
  3877 00:0FA9: A6 0B        	ldx	<L105+ncl_1+2
  3878 00:0FAB: A5 09        	lda	<L105+ncl_1
  3879 00:0FAD: 82 5E FD     	brl	L111
  3880                        ;}
  3881             00000016   L104	equ	22
  3882             00000005   L105	equ	5
  3883                        	ends
  3884                        	efunc
  3885                        ;
  3886                        ;#endif /* !FF_FS_READONLY */
  3887                        ;
  3888                        ;
  3889                        ;
  3890                        ;
  3891                        ;#if FF_USE_FASTSEEK
  3892                        ;/*-----------------------------------------------
                    ------------------------*/
  3893                        ;/* FAT handling - Convert offset into cluster wit
                    h link map table        */
  3894                        ;/*-----------------------------------------------
                    ------------------------*/
  3895                        ;
  Thu May 20 2021 21:37                                                Page 84


  3896                        ;static DWORD clmt_clust (	/* <2:Error, >=2
                    :Cluster number */
  3897                        ;	FIL* fp,		/* Pointer to the file o
                    bject */
  3898                        ;	FSIZE_t ofs		/* File offset to be con
                    verted to cluster# */
  3899                        ;)
  3900                        ;{
  3901                        ;	DWORD cl, ncl, *tbl;
  3902                        ;	FATFS *fs = fp->obj.fs;
  3903                        ;
  3904                        ;
  3905                        ;	tbl = fp->cltbl + 1;	/* Top of CLMT */
  3906                        ;	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Clust
                    er order from top of the file */
  3907                        ;	for (;;) {
  3908                        ;		ncl = *tbl++;			/* Numbe
                    r of cluters in the fragment */
  3909                        ;		if (ncl == 0) return 0;	/* End of table?
                     (error) */
  3910                        ;		if (cl < ncl) break;	/* In this fragm
                    ent? */
  3911                        ;		cl -= ncl; tbl++;		/* Next 
                    fragment */
  3912                        ;	}
  3913                        ;	return cl + *tbl;	/* Return the cluster nu
                    mber */
  3914                        ;}
  3915                        ;
  3916                        ;#endif	/* FF_USE_FASTSEEK */
  3917                        ;
  3918                        ;
  3919                        ;
  3920                        ;
  3921                        ;/*-----------------------------------------------
                    ------------------------*/
  3922                        ;/* Directory handling - Fill a cluster with zeros
                                            */
  3923                        ;/*-----------------------------------------------
                    ------------------------*/
  3924                        ;
  3925                        ;#if !FF_FS_READONLY
  3926                        ;static FRESULT dir_clear (	/* Returns FR_OK
                     or FR_DISK_ERR */
  3927                        ;	FATFS *fs,		/* Filesystem object */
  3928                        ;	DWORD clst		/* Directory table to cl
                    ear */
  3929                        ;)
  3930                        ;{
  3931                        	code
  3932                        	func
  3933                        ~~dir_clear:
  3934                        	longa	on
  3935                        	longi	on
  3936 00:0FB0: 3B           	tsc
  3937 00:0FB1: 38           	sec
  3938 00:0FB2: E9 14 00     	sbc	#L146
  3939 00:0FB5: 1B           	tcs
  Thu May 20 2021 21:37                                                Page 85


  3940 00:0FB6: 0B           	phd
  3941 00:0FB7: 5B           	tcd
  3942             00000004   fs_0	set	4
  3943             00000008   clst_0	set	8
  3944                        ;	LBA_t sect;
  3945                        ;	UINT n, szb;
  3946                        ;	BYTE *ibuf;
  3947                        ;
  3948                        ;
  3949                        ;	if (sync_window(fs) != FR_OK) return FR_DISK_ERR
                    ;	/* Flush disk access window */
  3950             00000000   sect_1	set	0
  3951             00000004   n_1	set	4
  3952             00000006   szb_1	set	6
  3953             00000008   ibuf_1	set	8
  3954 00:0FB8: D4 1A        	pei	<L146+fs_0+2
  3955 00:0FBA: D4 18        	pei	<L146+fs_0
  3956 00:0FBC: 22 xx xx xx  	jsl	~~sync_window
  3957 00:0FC0: AA           	tax
  3958 00:0FC1: D0 03        	bne	L148
  3959 00:0FC3: 82 15 00     	brl	L10064
  3960                        L148:
  3961 00:0FC6: A9 01 00     	lda	#$1
  3962                        L149:
  3963 00:0FC9: A8           	tay
  3964 00:0FCA: A5 16        	lda	<L146+2
  3965 00:0FCC: 85 1E        	sta	<L146+2+8
  3966 00:0FCE: A5 15        	lda	<L146+1
  3967 00:0FD0: 85 1D        	sta	<L146+1+8
  3968 00:0FD2: 2B           	pld
  3969 00:0FD3: 3B           	tsc
  3970 00:0FD4: 18           	clc
  3971 00:0FD5: 69 1C 00     	adc	#L146+8
  3972 00:0FD8: 1B           	tcs
  3973 00:0FD9: 98           	tya
  3974 00:0FDA: 6B           	rtl
  3975                        ;	sect = clst2sect(fs, clst);		/* Top o
                    f the cluster */
  3976                        L10064:
  3977 00:0FDB: D4 1E        	pei	<L146+clst_0+2
  3978 00:0FDD: D4 1C        	pei	<L146+clst_0
  3979 00:0FDF: D4 1A        	pei	<L146+fs_0+2
  3980 00:0FE1: D4 18        	pei	<L146+fs_0
  3981 00:0FE3: 22 xx xx xx  	jsl	~~clst2sect
  3982 00:0FE7: 85 09        	sta	<L147+sect_1
  3983 00:0FE9: 86 0B        	stx	<L147+sect_1+2
  3984                        ;	fs->winsect = sect;				
                    /* Set window to top of the cluster */
  3985 00:0FEB: A5 09        	lda	<L147+sect_1
  3986 00:0FED: A0 2B 00     	ldy	#$2b
  3987 00:0FF0: 97 18        	sta	[<L146+fs_0],Y
  3988 00:0FF2: A5 0B        	lda	<L147+sect_1+2
  3989 00:0FF4: A0 2D 00     	ldy	#$2d
  3990 00:0FF7: 97 18        	sta	[<L146+fs_0],Y
  3991                        ;	memset(fs->win, 0, sizeof fs->win);	/* Clear
                     window buffer */
  3992 00:0FF9: F4 00 02     	pea	#<$200
  3993 00:0FFC: F4 00 00     	pea	#<$0
  Thu May 20 2021 21:37                                                Page 86


  3994 00:0FFF: 18           	clc
  3995 00:1000: A9 2F 00     	lda	#$2f
  3996 00:1003: 65 18        	adc	<L146+fs_0
  3997 00:1005: 85 01        	sta	<R0
  3998 00:1007: A9 00 00     	lda	#$0
  3999 00:100A: 65 1A        	adc	<L146+fs_0+2
  4000 00:100C: 85 03        	sta	<R0+2
  4001 00:100E: D4 03        	pei	<R0+2
  4002 00:1010: D4 01        	pei	<R0
  4003 00:1012: 22 xx xx xx  	jsl	~~memset
  4004                        ;#if FF_USE_LFN == 3		/* Quick table c
                    lear by using multi-secter write */
  4005                        ;	/* Allocate a temporary buffer */
  4006                        ;	for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MAL
                    LOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(f
                    s) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
  4007                        ;	if (szb > SS(fs)) {		/* Buffer alloca
                    ted? */
  4008                        ;		memset(ibuf, 0, szb);
  4009                        ;		szb /= SS(fs);		/* Bytes -> Sect
                    ors */
  4010                        ;		for (n = 0; n < fs->csize && disk_write(
                    fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	
                    /* Fill the cluster with 0 */
  4011                        ;		ff_memfree(ibuf);
  4012                        ;	} else
  4013                        ;#endif
  4014                        ;	{
  4015                        ;		ibuf = fs->win; szb = 1;	/* Use w
                    indow buffer (many single-sector writes may take a time) */
  4016 00:1016: 18           	clc
  4017 00:1017: A9 2F 00     	lda	#$2f
  4018 00:101A: 65 18        	adc	<L146+fs_0
  4019 00:101C: 85 11        	sta	<L147+ibuf_1
  4020 00:101E: A9 00 00     	lda	#$0
  4021 00:1021: 65 1A        	adc	<L146+fs_0+2
  4022 00:1023: 85 13        	sta	<L147+ibuf_1+2
  4023 00:1025: A9 01 00     	lda	#$1
  4024 00:1028: 85 0F        	sta	<L147+szb_1
  4025                        ;		for (n = 0; n < fs->csize && disk_write(
                    fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	
                    /* Fill the cluster with 0 */
  4026 00:102A: 64 0D        	stz	<L147+n_1
  4027 00:102C: 82 07 00     	brl	L10066
  4028                        L10065:
  4029 00:102F: 18           	clc
  4030 00:1030: A5 0D        	lda	<L147+n_1
  4031 00:1032: 65 0F        	adc	<L147+szb_1
  4032 00:1034: 85 0D        	sta	<L147+n_1
  4033                        L10066:
  4034 00:1036: A5 0D        	lda	<L147+n_1
  4035 00:1038: A0 09 00     	ldy	#$9
  4036 00:103B: D7 18        	cmp	[<L146+fs_0],Y
  4037 00:103D: 90 03        	bcc	L150
  4038 00:103F: 82 30 00     	brl	L10067
  4039                        L150:
  4040 00:1042: D4 0F        	pei	<L147+szb_1
  4041 00:1044: A5 0D        	lda	<L147+n_1
  Thu May 20 2021 21:37                                                Page 87


  4042 00:1046: 85 01        	sta	<R0
  4043 00:1048: 64 03        	stz	<R0+2
  4044 00:104A: 18           	clc
  4045 00:104B: A5 01        	lda	<R0
  4046 00:104D: 65 09        	adc	<L147+sect_1
  4047 00:104F: 85 05        	sta	<R1
  4048 00:1051: A5 03        	lda	<R0+2
  4049 00:1053: 65 0B        	adc	<L147+sect_1+2
  4050 00:1055: 85 07        	sta	<R1+2
  4051 00:1057: D4 07        	pei	<R1+2
  4052 00:1059: D4 05        	pei	<R1
  4053 00:105B: D4 13        	pei	<L147+ibuf_1+2
  4054 00:105D: D4 11        	pei	<L147+ibuf_1
  4055 00:105F: A0 01 00     	ldy	#$1
  4056 00:1062: B7 18        	lda	[<L146+fs_0],Y
  4057 00:1064: 48           	pha
  4058 00:1065: 22 xx xx xx  	jsl	~~disk_write
  4059 00:1069: AA           	tax
  4060 00:106A: F0 03        	beq	L151
  4061 00:106C: 82 03 00     	brl	L10067
  4062                        L151:
  4063 00:106F: 82 BD FF     	brl	L10065
  4064                        L10067:
  4065                        ;	}
  4066                        ;	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
  4067 00:1072: A5 0D        	lda	<L147+n_1
  4068 00:1074: A0 09 00     	ldy	#$9
  4069 00:1077: D7 18        	cmp	[<L146+fs_0],Y
  4070 00:1079: F0 03        	beq	L153
  4071 00:107B: 82 05 00     	brl	L152
  4072                        L153:
  4073 00:107E: A9 00 00     	lda	#$0
  4074 00:1081: 80 03        	bra	L154
  4075                        L152:
  4076 00:1083: A9 01 00     	lda	#$1
  4077                        L154:
  4078 00:1086: 82 40 FF     	brl	L149
  4079                        ;}
  4080             00000014   L146	equ	20
  4081             00000009   L147	equ	9
  4082                        	ends
  4083                        	efunc
  4084                        ;#endif	/* !FF_FS_READONLY */
  4085                        ;
  4086                        ;
  4087                        ;
  4088                        ;
  4089                        ;/*-----------------------------------------------
                    ------------------------*/
  4090                        ;/* Directory handling - Set directory index      
                                            */
  4091                        ;/*-----------------------------------------------
                    ------------------------*/
  4092                        ;
  4093                        ;static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !
                    =0:error */
  4094                        ;	DIR* dp,		/* Pointer to directory 
                    object */
  Thu May 20 2021 21:37                                                Page 88


  4095                        ;	DWORD ofs		/* Offset of directory t
                    able */
  4096                        ;)
  4097                        ;{
  4098                        	code
  4099                        	func
  4100                        ~~dir_sdi:
  4101                        	longa	on
  4102                        	longi	on
  4103 00:1089: 3B           	tsc
  4104 00:108A: 38           	sec
  4105 00:108B: E9 14 00     	sbc	#L155
  4106 00:108E: 1B           	tcs
  4107 00:108F: 0B           	phd
  4108 00:1090: 5B           	tcd
  4109             00000004   dp_0	set	4
  4110             00000008   ofs_0	set	8
  4111                        ;	DWORD csz, clst;
  4112                        ;	FATFS *fs = dp->obj.fs;
  4113                        ;
  4114                        ;
  4115                        ;	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type =
                    = FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	
                    /* Check range of offset and alignment */
  4116             00000000   csz_1	set	0
  4117             00000004   clst_1	set	4
  4118             00000008   fs_1	set	8
  4119 00:1091: A7 18        	lda	[<L155+dp_0]
  4120 00:1093: 85 11        	sta	<L156+fs_1
  4121 00:1095: A0 02 00     	ldy	#$2
  4122 00:1098: B7 18        	lda	[<L155+dp_0],Y
  4123 00:109A: 85 13        	sta	<L156+fs_1+2
  4124 00:109C: 82 16 00     	brl	L158
  4125 00:109F: E2 20        	sep	#$20
  4126                        	longa	off
  4127 00:10A1: A7 11        	lda	[<L156+fs_1]
  4128 00:10A3: C9 04        	cmp	#<$4
  4129 00:10A5: C2 20        	rep	#$20
  4130                        	longa	on
  4131 00:10A7: F0 03        	beq	L159
  4132 00:10A9: 82 09 00     	brl	L158
  4133                        L159:
  4134 00:10AC: A9 00 10     	lda	#$1000
  4135 00:10AF: AA           	tax
  4136 00:10B0: A9 00 00     	lda	#$0
  4137 00:10B3: 80 07        	bra	L160
  4138                        L158:
  4139 00:10B5: A9 20 00     	lda	#$20
  4140 00:10B8: AA           	tax
  4141 00:10B9: A9 00 00     	lda	#$0
  4142                        L160:
  4143 00:10BC: 85 01        	sta	<R0
  4144 00:10BE: 86 03        	stx	<R0+2
  4145 00:10C0: A5 1C        	lda	<L155+ofs_0
  4146 00:10C2: C5 01        	cmp	<R0
  4147 00:10C4: A5 1E        	lda	<L155+ofs_0+2
  4148 00:10C6: E5 03        	sbc	<R0+2
  4149 00:10C8: 90 03        	bcc	L161
  Thu May 20 2021 21:37                                                Page 89


  4150 00:10CA: 82 0A 00     	brl	L157
  4151                        L161:
  4152 00:10CD: A5 1C        	lda	<L155+ofs_0
  4153 00:10CF: 29 1F 00     	and	#<$1f
  4154 00:10D2: D0 03        	bne	L162
  4155 00:10D4: 82 15 00     	brl	L10068
  4156                        L162:
  4157                        L157:
  4158                        ;		return FR_INT_ERR;
  4159 00:10D7: A9 02 00     	lda	#$2
  4160                        L163:
  4161 00:10DA: A8           	tay
  4162 00:10DB: A5 16        	lda	<L155+2
  4163 00:10DD: 85 1E        	sta	<L155+2+8
  4164 00:10DF: A5 15        	lda	<L155+1
  4165 00:10E1: 85 1D        	sta	<L155+1+8
  4166 00:10E3: 2B           	pld
  4167 00:10E4: 3B           	tsc
  4168 00:10E5: 18           	clc
  4169 00:10E6: 69 1C 00     	adc	#L155+8
  4170 00:10E9: 1B           	tcs
  4171 00:10EA: 98           	tya
  4172 00:10EB: 6B           	rtl
  4173                        ;	}
  4174                        ;	dp->dptr = ofs;				/* Set c
                    urrent offset */
  4175                        L10068:
  4176 00:10EC: A5 1C        	lda	<L155+ofs_0
  4177 00:10EE: A0 10 00     	ldy	#$10
  4178 00:10F1: 97 18        	sta	[<L155+dp_0],Y
  4179 00:10F3: A5 1E        	lda	<L155+ofs_0+2
  4180 00:10F5: A0 12 00     	ldy	#$12
  4181 00:10F8: 97 18        	sta	[<L155+dp_0],Y
  4182                        ;	clst = dp->obj.sclust;		/* Table start c
                    luster (0:root) */
  4183 00:10FA: A0 08 00     	ldy	#$8
  4184 00:10FD: B7 18        	lda	[<L155+dp_0],Y
  4185 00:10FF: 85 0D        	sta	<L156+clst_1
  4186 00:1101: A0 0A 00     	ldy	#$a
  4187 00:1104: B7 18        	lda	[<L155+dp_0],Y
  4188 00:1106: 85 0F        	sta	<L156+clst_1+2
  4189                        ;	if (clst == 0 && fs->fs_type >= FS_FAT32) {	
                    /* Replace cluster# 0 with root cluster# */
  4190 00:1108: A5 0D        	lda	<L156+clst_1
  4191 00:110A: 05 0F        	ora	<L156+clst_1+2
  4192 00:110C: F0 03        	beq	L164
  4193 00:110E: 82 29 00     	brl	L10069
  4194                        L164:
  4195 00:1111: E2 20        	sep	#$20
  4196                        	longa	off
  4197 00:1113: A7 11        	lda	[<L156+fs_1]
  4198 00:1115: C9 03        	cmp	#<$3
  4199 00:1117: C2 20        	rep	#$20
  4200                        	longa	on
  4201 00:1119: B0 03        	bcs	L165
  4202 00:111B: 82 1C 00     	brl	L10069
  4203                        L165:
  4204                        ;		clst = (DWORD)fs->dirbase;
  Thu May 20 2021 21:37                                                Page 90


  4205 00:111E: A0 23 00     	ldy	#$23
  4206 00:1121: B7 11        	lda	[<L156+fs_1],Y
  4207 00:1123: 85 0D        	sta	<L156+clst_1
  4208 00:1125: A0 25 00     	ldy	#$25
  4209 00:1128: B7 11        	lda	[<L156+fs_1],Y
  4210 00:112A: 85 0F        	sta	<L156+clst_1+2
  4211                        ;		if (FF_FS_EXFAT) dp->obj.stat = 0;	
                    /* exFAT: Root dir has an FAT chain */
  4212 00:112C: 82 0B 00     	brl	L10070
  4213 00:112F: E2 20        	sep	#$20
  4214                        	longa	off
  4215 00:1131: A9 00        	lda	#$0
  4216 00:1133: A0 07 00     	ldy	#$7
  4217 00:1136: 97 18        	sta	[<L155+dp_0],Y
  4218 00:1138: C2 20        	rep	#$20
  4219                        	longa	on
  4220                        ;	}
  4221                        L10070:
  4222                        ;
  4223                        ;	if (clst == 0) {	/* Static table (root-di
                    rectory on the FAT volume) */
  4224                        L10069:
  4225 00:113A: A5 0D        	lda	<L156+clst_1
  4226 00:113C: 05 0F        	ora	<L156+clst_1+2
  4227 00:113E: F0 03        	beq	L166
  4228 00:1140: 82 42 00     	brl	L10071
  4229                        L166:
  4230                        ;		if (ofs / SZDIRE >= fs->n_rootdir) retur
                    n FR_INT_ERR;	/* Is index out of range? */
  4231 00:1143: A0 07 00     	ldy	#$7
  4232 00:1146: B7 11        	lda	[<L156+fs_1],Y
  4233 00:1148: 85 01        	sta	<R0
  4234 00:114A: 64 03        	stz	<R0+2
  4235 00:114C: D4 1E        	pei	<L155+ofs_0+2
  4236 00:114E: D4 1C        	pei	<L155+ofs_0
  4237 00:1150: A9 05 00     	lda	#$5
  4238                        	xref	~~~llsr
  4239 00:1153: 22 xx xx xx  	jsl	~~~llsr
  4240 00:1157: 85 05        	sta	<R1
  4241 00:1159: 86 07        	stx	<R1+2
  4242 00:115B: A5 05        	lda	<R1
  4243 00:115D: C5 01        	cmp	<R0
  4244 00:115F: A5 07        	lda	<R1+2
  4245 00:1161: E5 03        	sbc	<R0+2
  4246 00:1163: B0 03        	bcs	L167
  4247 00:1165: 82 06 00     	brl	L10072
  4248                        L167:
  4249 00:1168: A9 02 00     	lda	#$2
  4250 00:116B: 82 6C FF     	brl	L163
  4251                        ;		dp->sect = fs->dirbase;
  4252                        L10072:
  4253 00:116E: A0 23 00     	ldy	#$23
  4254 00:1171: B7 11        	lda	[<L156+fs_1],Y
  4255 00:1173: A0 18 00     	ldy	#$18
  4256 00:1176: 97 18        	sta	[<L155+dp_0],Y
  4257 00:1178: A0 25 00     	ldy	#$25
  4258 00:117B: B7 11        	lda	[<L156+fs_1],Y
  4259 00:117D: A0 1A 00     	ldy	#$1a
  Thu May 20 2021 21:37                                                Page 91


  4260 00:1180: 97 18        	sta	[<L155+dp_0],Y
  4261                        ;
  4262                        ;	} else {			/* Dynamic table
                     (sub-directory or root-directory on the FAT32/exFAT volume)
                     */
  4263 00:1182: 82 A2 00     	brl	L10073
  4264                        L10071:
  4265                        ;		csz = (DWORD)fs->csize * SS(fs);	
                    /* Bytes per cluster */
  4266 00:1185: A0 09 00     	ldy	#$9
  4267 00:1188: B7 11        	lda	[<L156+fs_1],Y
  4268 00:118A: 85 01        	sta	<R0
  4269 00:118C: 64 03        	stz	<R0+2
  4270 00:118E: D4 03        	pei	<R0+2
  4271 00:1190: D4 01        	pei	<R0
  4272 00:1192: A9 09 00     	lda	#$9
  4273                        	xref	~~~lasl
  4274 00:1195: 22 xx xx xx  	jsl	~~~lasl
  4275 00:1199: 85 09        	sta	<L156+csz_1
  4276 00:119B: 86 0B        	stx	<L156+csz_1+2
  4277                        ;		while (ofs >= csz) {			
                    	/* Follow cluster chain */
  4278                        L10074:
  4279 00:119D: A5 1C        	lda	<L155+ofs_0
  4280 00:119F: C5 09        	cmp	<L156+csz_1
  4281 00:11A1: A5 1E        	lda	<L155+ofs_0+2
  4282 00:11A3: E5 0B        	sbc	<L156+csz_1+2
  4283 00:11A5: B0 03        	bcs	L168
  4284 00:11A7: 82 5F 00     	brl	L10075
  4285                        L168:
  4286                        ;			clst = get_fat(&dp->obj, clst);	
                    			/* Get next cluster */
  4287 00:11AA: D4 0F        	pei	<L156+clst_1+2
  4288 00:11AC: D4 0D        	pei	<L156+clst_1
  4289 00:11AE: D4 1A        	pei	<L155+dp_0+2
  4290 00:11B0: D4 18        	pei	<L155+dp_0
  4291 00:11B2: 22 xx xx xx  	jsl	~~get_fat
  4292 00:11B6: 85 0D        	sta	<L156+clst_1
  4293 00:11B8: 86 0F        	stx	<L156+clst_1+2
  4294                        ;			if (clst == 0xFFFFFFFF) return F
                    R_DISK_ERR;	/* Disk error */
  4295 00:11BA: A5 0D        	lda	<L156+clst_1
  4296 00:11BC: C9 FF FF     	cmp	#<$ffffffff
  4297 00:11BF: D0 05        	bne	L169
  4298 00:11C1: A5 0F        	lda	<L156+clst_1+2
  4299 00:11C3: C9 FF FF     	cmp	#^$ffffffff
  4300                        L169:
  4301 00:11C6: F0 03        	beq	L170
  4302 00:11C8: 82 06 00     	brl	L10076
  4303                        L170:
  4304 00:11CB: A9 01 00     	lda	#$1
  4305 00:11CE: 82 09 FF     	brl	L163
  4306                        ;			if (clst < 2 || clst >= fs->n_fa
                    tent) return FR_INT_ERR;	/* Reached to end of table or in
                    ternal error */
  4307                        L10076:
  4308 00:11D1: A5 0D        	lda	<L156+clst_1
  4309 00:11D3: C9 02 00     	cmp	#<$2
  Thu May 20 2021 21:37                                                Page 92


  4310 00:11D6: A5 0F        	lda	<L156+clst_1+2
  4311 00:11D8: E9 00 00     	sbc	#^$2
  4312 00:11DB: B0 03        	bcs	L172
  4313 00:11DD: 82 13 00     	brl	L171
  4314                        L172:
  4315 00:11E0: A5 0D        	lda	<L156+clst_1
  4316 00:11E2: A0 13 00     	ldy	#$13
  4317 00:11E5: D7 11        	cmp	[<L156+fs_1],Y
  4318 00:11E7: A5 0F        	lda	<L156+clst_1+2
  4319 00:11E9: A0 15 00     	ldy	#$15
  4320 00:11EC: F7 11        	sbc	[<L156+fs_1],Y
  4321 00:11EE: B0 03        	bcs	L173
  4322 00:11F0: 82 06 00     	brl	L10077
  4323                        L173:
  4324                        L171:
  4325 00:11F3: A9 02 00     	lda	#$2
  4326 00:11F6: 82 E1 FE     	brl	L163
  4327                        ;			ofs -= csz;
  4328                        L10077:
  4329 00:11F9: 38           	sec
  4330 00:11FA: A5 1C        	lda	<L155+ofs_0
  4331 00:11FC: E5 09        	sbc	<L156+csz_1
  4332 00:11FE: 85 1C        	sta	<L155+ofs_0
  4333 00:1200: A5 1E        	lda	<L155+ofs_0+2
  4334 00:1202: E5 0B        	sbc	<L156+csz_1+2
  4335 00:1204: 85 1E        	sta	<L155+ofs_0+2
  4336                        ;		}
  4337 00:1206: 82 94 FF     	brl	L10074
  4338                        L10075:
  4339                        ;		dp->sect = clst2sect(fs, clst);
  4340 00:1209: D4 0F        	pei	<L156+clst_1+2
  4341 00:120B: D4 0D        	pei	<L156+clst_1
  4342 00:120D: D4 13        	pei	<L156+fs_1+2
  4343 00:120F: D4 11        	pei	<L156+fs_1
  4344 00:1211: 22 xx xx xx  	jsl	~~clst2sect
  4345 00:1215: 85 01        	sta	<R0
  4346 00:1217: 86 03        	stx	<R0+2
  4347 00:1219: A5 01        	lda	<R0
  4348 00:121B: A0 18 00     	ldy	#$18
  4349 00:121E: 97 18        	sta	[<L155+dp_0],Y
  4350 00:1220: A5 03        	lda	<R0+2
  4351 00:1222: A0 1A 00     	ldy	#$1a
  4352 00:1225: 97 18        	sta	[<L155+dp_0],Y
  4353                        ;	}
  4354                        L10073:
  4355                        ;	dp->clust = clst;				
                    	/* Current cluster# */
  4356 00:1227: A5 0D        	lda	<L156+clst_1
  4357 00:1229: A0 14 00     	ldy	#$14
  4358 00:122C: 97 18        	sta	[<L155+dp_0],Y
  4359 00:122E: A5 0F        	lda	<L156+clst_1+2
  4360 00:1230: A0 16 00     	ldy	#$16
  4361 00:1233: 97 18        	sta	[<L155+dp_0],Y
  4362                        ;	if (dp->sect == 0) return FR_INT_ERR;
  4363 00:1235: A0 18 00     	ldy	#$18
  4364 00:1238: B7 18        	lda	[<L155+dp_0],Y
  4365 00:123A: A0 1A 00     	ldy	#$1a
  4366 00:123D: 17 18        	ora	[<L155+dp_0],Y
  Thu May 20 2021 21:37                                                Page 93


  4367 00:123F: F0 03        	beq	L174
  4368 00:1241: 82 06 00     	brl	L10078
  4369                        L174:
  4370 00:1244: A9 02 00     	lda	#$2
  4371 00:1247: 82 90 FE     	brl	L163
  4372                        ;	dp->sect += ofs / SS(fs);			
                    /* Sector# of the directory entry */
  4373                        L10078:
  4374 00:124A: 18           	clc
  4375 00:124B: A9 18 00     	lda	#$18
  4376 00:124E: 65 18        	adc	<L155+dp_0
  4377 00:1250: 85 01        	sta	<R0
  4378 00:1252: A9 00 00     	lda	#$0
  4379 00:1255: 65 1A        	adc	<L155+dp_0+2
  4380 00:1257: 85 03        	sta	<R0+2
  4381 00:1259: D4 1E        	pei	<L155+ofs_0+2
  4382 00:125B: D4 1C        	pei	<L155+ofs_0
  4383 00:125D: A9 09 00     	lda	#$9
  4384                        	xref	~~~llsr
  4385 00:1260: 22 xx xx xx  	jsl	~~~llsr
  4386 00:1264: 85 05        	sta	<R1
  4387 00:1266: 86 07        	stx	<R1+2
  4388 00:1268: 18           	clc
  4389 00:1269: A5 05        	lda	<R1
  4390 00:126B: 67 01        	adc	[<R0]
  4391 00:126D: 87 01        	sta	[<R0]
  4392 00:126F: A5 07        	lda	<R1+2
  4393 00:1271: A0 02 00     	ldy	#$2
  4394 00:1274: 77 01        	adc	[<R0],Y
  4395 00:1276: A0 02 00     	ldy	#$2
  4396 00:1279: 97 01        	sta	[<R0],Y
  4397                        ;	dp->dir = fs->win + (ofs % SS(fs));	/* Point
                    er to the entry in the win[] */
  4398 00:127B: A5 1C        	lda	<L155+ofs_0
  4399 00:127D: 29 FF 01     	and	#<$1ff
  4400 00:1280: 85 01        	sta	<R0
  4401 00:1282: 64 03        	stz	<R0+2
  4402 00:1284: 18           	clc
  4403 00:1285: A9 2F 00     	lda	#$2f
  4404 00:1288: 65 01        	adc	<R0
  4405 00:128A: 85 05        	sta	<R1
  4406 00:128C: A9 00 00     	lda	#$0
  4407 00:128F: 65 03        	adc	<R0+2
  4408 00:1291: 85 07        	sta	<R1+2
  4409 00:1293: 18           	clc
  4410 00:1294: A5 11        	lda	<L156+fs_1
  4411 00:1296: 65 05        	adc	<R1
  4412 00:1298: 85 01        	sta	<R0
  4413 00:129A: A5 13        	lda	<L156+fs_1+2
  4414 00:129C: 65 07        	adc	<R1+2
  4415 00:129E: 85 03        	sta	<R0+2
  4416 00:12A0: A5 01        	lda	<R0
  4417 00:12A2: A0 1C 00     	ldy	#$1c
  4418 00:12A5: 97 18        	sta	[<L155+dp_0],Y
  4419 00:12A7: A5 03        	lda	<R0+2
  4420 00:12A9: A0 1E 00     	ldy	#$1e
  4421 00:12AC: 97 18        	sta	[<L155+dp_0],Y
  4422                        ;
  Thu May 20 2021 21:37                                                Page 94


  4423                        ;	return FR_OK;
  4424 00:12AE: A9 00 00     	lda	#$0
  4425 00:12B1: 82 26 FE     	brl	L163
  4426                        ;}
  4427             00000014   L155	equ	20
  4428             00000009   L156	equ	9
  4429                        	ends
  4430                        	efunc
  4431                        ;
  4432                        ;
  4433                        ;
  4434                        ;
  4435                        ;/*-----------------------------------------------
                    ------------------------*/
  4436                        ;/* Directory handling - Move directory table inde
                    x next                  */
  4437                        ;/*-----------------------------------------------
                    ------------------------*/
  4438                        ;
  4439                        ;static FRESULT dir_next (	/* FR_OK(0):succ
                    eeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch 
                    */
  4440                        ;	DIR* dp,				/* Point
                    er to the directory object */
  4441                        ;	int stretch				/* 0: Do
                     not stretch table, 1: Stretch table if needed */
  4442                        ;)
  4443                        ;{
  4444                        	code
  4445                        	func
  4446                        ~~dir_next:
  4447                        	longa	on
  4448                        	longi	on
  4449 00:12B4: 3B           	tsc
  4450 00:12B5: 38           	sec
  4451 00:12B6: E9 18 00     	sbc	#L175
  4452 00:12B9: 1B           	tcs
  4453 00:12BA: 0B           	phd
  4454 00:12BB: 5B           	tcd
  4455             00000004   dp_0	set	4
  4456             00000008   stretch_0	set	8
  4457                        ;	DWORD ofs, clst;
  4458                        ;	FATFS *fs = dp->obj.fs;
  4459                        ;
  4460                        ;
  4461                        ;	ofs = dp->dptr + SZDIRE;	/* Next entry */
  4462             00000000   ofs_1	set	0
  4463             00000004   clst_1	set	4
  4464             00000008   fs_1	set	8
  4465 00:12BC: A7 1C        	lda	[<L175+dp_0]
  4466 00:12BE: 85 15        	sta	<L176+fs_1
  4467 00:12C0: A0 02 00     	ldy	#$2
  4468 00:12C3: B7 1C        	lda	[<L175+dp_0],Y
  4469 00:12C5: 85 17        	sta	<L176+fs_1+2
  4470 00:12C7: 18           	clc
  4471 00:12C8: A9 20 00     	lda	#$20
  4472 00:12CB: A0 10 00     	ldy	#$10
  4473 00:12CE: 77 1C        	adc	[<L175+dp_0],Y
  Thu May 20 2021 21:37                                                Page 95


  4474 00:12D0: 85 0D        	sta	<L176+ofs_1
  4475 00:12D2: A9 00 00     	lda	#$0
  4476 00:12D5: A0 12 00     	ldy	#$12
  4477 00:12D8: 77 1C        	adc	[<L175+dp_0],Y
  4478 00:12DA: 85 0F        	sta	<L176+ofs_1+2
  4479                        ;	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type =
                    = FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disab
                    le it if the offset reached the max value */
  4480 00:12DC: 82 16 00     	brl	L177
  4481 00:12DF: E2 20        	sep	#$20
  4482                        	longa	off
  4483 00:12E1: A7 15        	lda	[<L176+fs_1]
  4484 00:12E3: C9 04        	cmp	#<$4
  4485 00:12E5: C2 20        	rep	#$20
  4486                        	longa	on
  4487 00:12E7: F0 03        	beq	L178
  4488 00:12E9: 82 09 00     	brl	L177
  4489                        L178:
  4490 00:12EC: A9 00 10     	lda	#$1000
  4491 00:12EF: AA           	tax
  4492 00:12F0: A9 00 00     	lda	#$0
  4493 00:12F3: 80 07        	bra	L179
  4494                        L177:
  4495 00:12F5: A9 20 00     	lda	#$20
  4496 00:12F8: AA           	tax
  4497 00:12F9: A9 00 00     	lda	#$0
  4498                        L179:
  4499 00:12FC: 85 01        	sta	<R0
  4500 00:12FE: 86 03        	stx	<R0+2
  4501 00:1300: A5 0D        	lda	<L176+ofs_1
  4502 00:1302: C5 01        	cmp	<R0
  4503 00:1304: A5 0F        	lda	<L176+ofs_1+2
  4504 00:1306: E5 03        	sbc	<R0+2
  4505 00:1308: B0 03        	bcs	L180
  4506 00:130A: 82 10 00     	brl	L10079
  4507                        L180:
  4508 00:130D: A9 00 00     	lda	#$0
  4509 00:1310: A0 18 00     	ldy	#$18
  4510 00:1313: 97 1C        	sta	[<L175+dp_0],Y
  4511 00:1315: A9 00 00     	lda	#$0
  4512 00:1318: A0 1A 00     	ldy	#$1a
  4513 00:131B: 97 1C        	sta	[<L175+dp_0],Y
  4514                        ;	if (dp->sect == 0) return FR_NO_FILE;	/* Repor
                    t EOT if it has been disabled */
  4515                        L10079:
  4516 00:131D: A0 18 00     	ldy	#$18
  4517 00:1320: B7 1C        	lda	[<L175+dp_0],Y
  4518 00:1322: A0 1A 00     	ldy	#$1a
  4519 00:1325: 17 1C        	ora	[<L175+dp_0],Y
  4520 00:1327: F0 03        	beq	L181
  4521 00:1329: 82 15 00     	brl	L10080
  4522                        L181:
  4523 00:132C: A9 04 00     	lda	#$4
  4524                        L182:
  4525 00:132F: A8           	tay
  4526 00:1330: A5 1A        	lda	<L175+2
  4527 00:1332: 85 20        	sta	<L175+2+6
  4528 00:1334: A5 19        	lda	<L175+1
  Thu May 20 2021 21:37                                                Page 96


  4529 00:1336: 85 1F        	sta	<L175+1+6
  4530 00:1338: 2B           	pld
  4531 00:1339: 3B           	tsc
  4532 00:133A: 18           	clc
  4533 00:133B: 69 1E 00     	adc	#L175+6
  4534 00:133E: 1B           	tcs
  4535 00:133F: 98           	tya
  4536 00:1340: 6B           	rtl
  4537                        ;
  4538                        ;	if (ofs % SS(fs) == 0) {	/* Sector change
                    d? */
  4539                        L10080:
  4540 00:1341: A5 0D        	lda	<L176+ofs_1
  4541 00:1343: 29 FF 01     	and	#<$1ff
  4542 00:1346: F0 03        	beq	L183
  4543 00:1348: 82 C6 01     	brl	L10081
  4544                        L183:
  4545                        ;		dp->sect++;				
                    /* Next sector */
  4546 00:134B: 18           	clc
  4547 00:134C: A9 01 00     	lda	#$1
  4548 00:134F: A0 18 00     	ldy	#$18
  4549 00:1352: 77 1C        	adc	[<L175+dp_0],Y
  4550 00:1354: A0 18 00     	ldy	#$18
  4551 00:1357: 97 1C        	sta	[<L175+dp_0],Y
  4552 00:1359: A9 00 00     	lda	#$0
  4553 00:135C: A0 1A 00     	ldy	#$1a
  4554 00:135F: 77 1C        	adc	[<L175+dp_0],Y
  4555 00:1361: A0 1A 00     	ldy	#$1a
  4556 00:1364: 97 1C        	sta	[<L175+dp_0],Y
  4557                        ;
  4558                        ;		if (dp->clust == 0) {	/* Static table 
                    */
  4559 00:1366: A0 14 00     	ldy	#$14
  4560 00:1369: B7 1C        	lda	[<L175+dp_0],Y
  4561 00:136B: A0 16 00     	ldy	#$16
  4562 00:136E: 17 1C        	ora	[<L175+dp_0],Y
  4563 00:1370: F0 03        	beq	L184
  4564 00:1372: 82 3E 00     	brl	L10082
  4565                        L184:
  4566                        ;			if (ofs / SZDIRE >= fs->n_rootdi
                    r) {	/* Report EOT if it reached end of static table 
                    */
  4567 00:1375: A0 07 00     	ldy	#$7
  4568 00:1378: B7 15        	lda	[<L176+fs_1],Y
  4569 00:137A: 85 01        	sta	<R0
  4570 00:137C: 64 03        	stz	<R0+2
  4571 00:137E: D4 0F        	pei	<L176+ofs_1+2
  4572 00:1380: D4 0D        	pei	<L176+ofs_1
  4573 00:1382: A9 05 00     	lda	#$5
  4574                        	xref	~~~llsr
  4575 00:1385: 22 xx xx xx  	jsl	~~~llsr
  4576 00:1389: 85 05        	sta	<R1
  4577 00:138B: 86 07        	stx	<R1+2
  4578 00:138D: A5 05        	lda	<R1
  4579 00:138F: C5 01        	cmp	<R0
  4580 00:1391: A5 07        	lda	<R1+2
  4581 00:1393: E5 03        	sbc	<R0+2
  Thu May 20 2021 21:37                                                Page 97


  4582 00:1395: B0 03        	bcs	L185
  4583 00:1397: 82 16 00     	brl	L10083
  4584                        L185:
  4585                        ;				dp->sect = 0; return FR_
                    NO_FILE;
  4586 00:139A: A9 00 00     	lda	#$0
  4587 00:139D: A0 18 00     	ldy	#$18
  4588 00:13A0: 97 1C        	sta	[<L175+dp_0],Y
  4589 00:13A2: A9 00 00     	lda	#$0
  4590 00:13A5: A0 1A 00     	ldy	#$1a
  4591 00:13A8: 97 1C        	sta	[<L175+dp_0],Y
  4592 00:13AA: A9 04 00     	lda	#$4
  4593 00:13AD: 82 7F FF     	brl	L182
  4594                        ;			}
  4595                        ;		}
  4596                        L10083:
  4597                        ;		else {					
                    /* Dynamic table */
  4598 00:13B0: 82 5E 01     	brl	L10084
  4599                        L10082:
  4600                        ;			if ((ofs / SS(fs) & (fs->csize -
                     1)) == 0) {	/* Cluster changed? */
  4601 00:13B3: D4 0F        	pei	<L176+ofs_1+2
  4602 00:13B5: D4 0D        	pei	<L176+ofs_1
  4603 00:13B7: A9 09 00     	lda	#$9
  4604                        	xref	~~~llsr
  4605 00:13BA: 22 xx xx xx  	jsl	~~~llsr
  4606 00:13BE: 85 01        	sta	<R0
  4607 00:13C0: 86 03        	stx	<R0+2
  4608 00:13C2: 18           	clc
  4609 00:13C3: A9 FF FF     	lda	#$ffff
  4610 00:13C6: A0 09 00     	ldy	#$9
  4611 00:13C9: 77 15        	adc	[<L176+fs_1],Y
  4612 00:13CB: 85 05        	sta	<R1
  4613 00:13CD: A5 05        	lda	<R1
  4614 00:13CF: 85 05        	sta	<R1
  4615 00:13D1: 64 07        	stz	<R1+2
  4616 00:13D3: A5 05        	lda	<R1
  4617 00:13D5: 25 01        	and	<R0
  4618 00:13D7: 85 09        	sta	<R2
  4619 00:13D9: A5 07        	lda	<R1+2
  4620 00:13DB: 25 03        	and	<R0+2
  4621 00:13DD: 85 0B        	sta	<R2+2
  4622 00:13DF: A5 09        	lda	<R2
  4623 00:13E1: 05 0B        	ora	<R2+2
  4624 00:13E3: F0 03        	beq	L186
  4625 00:13E5: 82 29 01     	brl	L10085
  4626                        L186:
  4627                        ;				clst = get_fat(&dp->obj,
                     dp->clust);		/* Get next cluster */
  4628 00:13E8: A0 16 00     	ldy	#$16
  4629 00:13EB: B7 1C        	lda	[<L175+dp_0],Y
  4630 00:13ED: 48           	pha
  4631 00:13EE: A0 14 00     	ldy	#$14
  4632 00:13F1: B7 1C        	lda	[<L175+dp_0],Y
  4633 00:13F3: 48           	pha
  4634 00:13F4: D4 1E        	pei	<L175+dp_0+2
  4635 00:13F6: D4 1C        	pei	<L175+dp_0
  Thu May 20 2021 21:37                                                Page 98


  4636 00:13F8: 22 xx xx xx  	jsl	~~get_fat
  4637 00:13FC: 85 11        	sta	<L176+clst_1
  4638 00:13FE: 86 13        	stx	<L176+clst_1+2
  4639                        ;				if (clst <= 1) return FR
                    _INT_ERR;			/* Internal error */
  4640 00:1400: A9 01 00     	lda	#$1
  4641 00:1403: C5 11        	cmp	<L176+clst_1
  4642 00:1405: A9 00 00     	lda	#$0
  4643 00:1408: E5 13        	sbc	<L176+clst_1+2
  4644 00:140A: B0 03        	bcs	L187
  4645 00:140C: 82 06 00     	brl	L10086
  4646                        L187:
  4647 00:140F: A9 02 00     	lda	#$2
  4648 00:1412: 82 1A FF     	brl	L182
  4649                        ;				if (clst == 0xFFFFFFFF) 
                    return FR_DISK_ERR;	/* Disk error */
  4650                        L10086:
  4651 00:1415: A5 11        	lda	<L176+clst_1
  4652 00:1417: C9 FF FF     	cmp	#<$ffffffff
  4653 00:141A: D0 05        	bne	L188
  4654 00:141C: A5 13        	lda	<L176+clst_1+2
  4655 00:141E: C9 FF FF     	cmp	#^$ffffffff
  4656                        L188:
  4657 00:1421: F0 03        	beq	L189
  4658 00:1423: 82 06 00     	brl	L10087
  4659                        L189:
  4660 00:1426: A9 01 00     	lda	#$1
  4661 00:1429: 82 03 FF     	brl	L182
  4662                        ;				if (clst >= fs->n_fatent
                    ) {					/* It reached end of dyn
                    amic table */
  4663                        L10087:
  4664 00:142C: A5 11        	lda	<L176+clst_1
  4665 00:142E: A0 13 00     	ldy	#$13
  4666 00:1431: D7 15        	cmp	[<L176+fs_1],Y
  4667 00:1433: A5 13        	lda	<L176+clst_1+2
  4668 00:1435: A0 15 00     	ldy	#$15
  4669 00:1438: F7 15        	sbc	[<L176+fs_1],Y
  4670 00:143A: B0 03        	bcs	L190
  4671 00:143C: 82 A6 00     	brl	L10088
  4672                        L190:
  4673                        ;#if !FF_FS_READONLY
  4674                        ;					if (!stretch) {	
                    							/* If no
                     stretch, report EOT */
  4675 00:143F: A5 20        	lda	<L175+stretch_0
  4676 00:1441: F0 03        	beq	L191
  4677 00:1443: 82 16 00     	brl	L10089
  4678                        L191:
  4679                        ;						dp->sect
                     = 0; return FR_NO_FILE;
  4680 00:1446: A9 00 00     	lda	#$0
  4681 00:1449: A0 18 00     	ldy	#$18
  4682 00:144C: 97 1C        	sta	[<L175+dp_0],Y
  4683 00:144E: A9 00 00     	lda	#$0
  4684 00:1451: A0 1A 00     	ldy	#$1a
  4685 00:1454: 97 1C        	sta	[<L175+dp_0],Y
  4686 00:1456: A9 04 00     	lda	#$4
  Thu May 20 2021 21:37                                                Page 99


  4687 00:1459: 82 D3 FE     	brl	L182
  4688                        ;					}
  4689                        ;					clst = create_ch
                    ain(&dp->obj, dp->clust);	/* Allocate a cluster */
  4690                        L10089:
  4691 00:145C: A0 16 00     	ldy	#$16
  4692 00:145F: B7 1C        	lda	[<L175+dp_0],Y
  4693 00:1461: 48           	pha
  4694 00:1462: A0 14 00     	ldy	#$14
  4695 00:1465: B7 1C        	lda	[<L175+dp_0],Y
  4696 00:1467: 48           	pha
  4697 00:1468: D4 1E        	pei	<L175+dp_0+2
  4698 00:146A: D4 1C        	pei	<L175+dp_0
  4699 00:146C: 22 xx xx xx  	jsl	~~create_chain
  4700 00:1470: 85 11        	sta	<L176+clst_1
  4701 00:1472: 86 13        	stx	<L176+clst_1+2
  4702                        ;					if (clst == 0) r
                    eturn FR_DENIED;			/* No free cluster */
  4703 00:1474: A5 11        	lda	<L176+clst_1
  4704 00:1476: 05 13        	ora	<L176+clst_1+2
  4705 00:1478: F0 03        	beq	L192
  4706 00:147A: 82 06 00     	brl	L10090
  4707                        L192:
  4708 00:147D: A9 07 00     	lda	#$7
  4709 00:1480: 82 AC FE     	brl	L182
  4710                        ;					if (clst == 1) r
                    eturn FR_INT_ERR;			/* Internal error */
  4711                        L10090:
  4712 00:1483: A5 11        	lda	<L176+clst_1
  4713 00:1485: C9 01 00     	cmp	#<$1
  4714 00:1488: D0 05        	bne	L193
  4715 00:148A: A5 13        	lda	<L176+clst_1+2
  4716 00:148C: C9 00 00     	cmp	#^$1
  4717                        L193:
  4718 00:148F: F0 03        	beq	L194
  4719 00:1491: 82 06 00     	brl	L10091
  4720                        L194:
  4721 00:1494: A9 02 00     	lda	#$2
  4722 00:1497: 82 95 FE     	brl	L182
  4723                        ;					if (clst == 0xFF
                    FFFFFF) return FR_DISK_ERR;	/* Disk error */
  4724                        L10091:
  4725 00:149A: A5 11        	lda	<L176+clst_1
  4726 00:149C: C9 FF FF     	cmp	#<$ffffffff
  4727 00:149F: D0 05        	bne	L195
  4728 00:14A1: A5 13        	lda	<L176+clst_1+2
  4729 00:14A3: C9 FF FF     	cmp	#^$ffffffff
  4730                        L195:
  4731 00:14A6: F0 03        	beq	L196
  4732 00:14A8: 82 06 00     	brl	L10092
  4733                        L196:
  4734 00:14AB: A9 01 00     	lda	#$1
  4735 00:14AE: 82 7E FE     	brl	L182
  4736                        ;					if (dir_clear(fs
                    , clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the 
                    stretched table */
  4737                        L10092:
  4738 00:14B1: D4 13        	pei	<L176+clst_1+2
  Thu May 20 2021 21:37                                                Page 100


  4739 00:14B3: D4 11        	pei	<L176+clst_1
  4740 00:14B5: D4 17        	pei	<L176+fs_1+2
  4741 00:14B7: D4 15        	pei	<L176+fs_1
  4742 00:14B9: 22 xx xx xx  	jsl	~~dir_clear
  4743 00:14BD: AA           	tax
  4744 00:14BE: D0 03        	bne	L197
  4745 00:14C0: 82 06 00     	brl	L10093
  4746                        L197:
  4747 00:14C3: A9 01 00     	lda	#$1
  4748 00:14C6: 82 66 FE     	brl	L182
  4749                        ;					if (FF_FS_EXFAT)
                     dp->obj.stat |= 4;			/* exFAT: The directory 
                    has been stretched */
  4750                        L10093:
  4751 00:14C9: 82 19 00     	brl	L10094
  4752 00:14CC: 18           	clc
  4753 00:14CD: A9 07 00     	lda	#$7
  4754 00:14D0: 65 1C        	adc	<L175+dp_0
  4755 00:14D2: 85 01        	sta	<R0
  4756 00:14D4: A9 00 00     	lda	#$0
  4757 00:14D7: 65 1E        	adc	<L175+dp_0+2
  4758 00:14D9: 85 03        	sta	<R0+2
  4759 00:14DB: E2 20        	sep	#$20
  4760                        	longa	off
  4761 00:14DD: A7 01        	lda	[<R0]
  4762 00:14DF: 09 04        	ora	#<$4
  4763 00:14E1: 87 01        	sta	[<R0]
  4764 00:14E3: C2 20        	rep	#$20
  4765                        	longa	on
  4766                        ;#else
  4767                        ;					if (!stretch) dp
                    ->sect = 0;					/* (this line is
                     to suppress compiler warning) */
  4768                        ;					dp->sect = 0; re
                    turn FR_NO_FILE;			/* Report EOT */
  4769                        ;#endif
  4770                        ;				}
  4771                        L10094:
  4772                        ;				dp->clust = clst;	
                    	/* Initialize data for new cluster */
  4773                        L10088:
  4774 00:14E5: A5 11        	lda	<L176+clst_1
  4775 00:14E7: A0 14 00     	ldy	#$14
  4776 00:14EA: 97 1C        	sta	[<L175+dp_0],Y
  4777 00:14EC: A5 13        	lda	<L176+clst_1+2
  4778 00:14EE: A0 16 00     	ldy	#$16
  4779 00:14F1: 97 1C        	sta	[<L175+dp_0],Y
  4780                        ;				dp->sect = clst2sect(fs,
                     clst);
  4781 00:14F3: D4 13        	pei	<L176+clst_1+2
  4782 00:14F5: D4 11        	pei	<L176+clst_1
  4783 00:14F7: D4 17        	pei	<L176+fs_1+2
  4784 00:14F9: D4 15        	pei	<L176+fs_1
  4785 00:14FB: 22 xx xx xx  	jsl	~~clst2sect
  4786 00:14FF: 85 01        	sta	<R0
  4787 00:1501: 86 03        	stx	<R0+2
  4788 00:1503: A5 01        	lda	<R0
  4789 00:1505: A0 18 00     	ldy	#$18
  Thu May 20 2021 21:37                                                Page 101


  4790 00:1508: 97 1C        	sta	[<L175+dp_0],Y
  4791 00:150A: A5 03        	lda	<R0+2
  4792 00:150C: A0 1A 00     	ldy	#$1a
  4793 00:150F: 97 1C        	sta	[<L175+dp_0],Y
  4794                        ;			}
  4795                        ;		}
  4796                        L10085:
  4797                        L10084:
  4798                        ;	}
  4799                        ;	dp->dptr = ofs;					
                    	/* Current entry */
  4800                        L10081:
  4801 00:1511: A5 0D        	lda	<L176+ofs_1
  4802 00:1513: A0 10 00     	ldy	#$10
  4803 00:1516: 97 1C        	sta	[<L175+dp_0],Y
  4804 00:1518: A5 0F        	lda	<L176+ofs_1+2
  4805 00:151A: A0 12 00     	ldy	#$12
  4806 00:151D: 97 1C        	sta	[<L175+dp_0],Y
  4807                        ;	dp->dir = fs->win + ofs % SS(fs);	/* Point
                    er to the entry in the win[] */
  4808 00:151F: A5 0D        	lda	<L176+ofs_1
  4809 00:1521: 29 FF 01     	and	#<$1ff
  4810 00:1524: 85 01        	sta	<R0
  4811 00:1526: 64 03        	stz	<R0+2
  4812 00:1528: 18           	clc
  4813 00:1529: A9 2F 00     	lda	#$2f
  4814 00:152C: 65 01        	adc	<R0
  4815 00:152E: 85 05        	sta	<R1
  4816 00:1530: A9 00 00     	lda	#$0
  4817 00:1533: 65 03        	adc	<R0+2
  4818 00:1535: 85 07        	sta	<R1+2
  4819 00:1537: 18           	clc
  4820 00:1538: A5 15        	lda	<L176+fs_1
  4821 00:153A: 65 05        	adc	<R1
  4822 00:153C: 85 01        	sta	<R0
  4823 00:153E: A5 17        	lda	<L176+fs_1+2
  4824 00:1540: 65 07        	adc	<R1+2
  4825 00:1542: 85 03        	sta	<R0+2
  4826 00:1544: A5 01        	lda	<R0
  4827 00:1546: A0 1C 00     	ldy	#$1c
  4828 00:1549: 97 1C        	sta	[<L175+dp_0],Y
  4829 00:154B: A5 03        	lda	<R0+2
  4830 00:154D: A0 1E 00     	ldy	#$1e
  4831 00:1550: 97 1C        	sta	[<L175+dp_0],Y
  4832                        ;
  4833                        ;	return FR_OK;
  4834 00:1552: A9 00 00     	lda	#$0
  4835 00:1555: 82 D7 FD     	brl	L182
  4836                        ;}
  4837             00000018   L175	equ	24
  4838             0000000D   L176	equ	13
  4839                        	ends
  4840                        	efunc
  4841                        ;
  4842                        ;
  4843                        ;
  4844                        ;
  4845                        ;#if !FF_FS_READONLY
  Thu May 20 2021 21:37                                                Page 102


  4846                        ;/*-----------------------------------------------
                    ------------------------*/
  4847                        ;/* Directory handling - Reserve a block of direct
                    ory entries             */
  4848                        ;/*-----------------------------------------------
                    ------------------------*/
  4849                        ;
  4850                        ;static FRESULT dir_alloc (	/* FR_OK(0):succ
                    eeded, !=0:error */
  4851                        ;	DIR* dp,				/* Point
                    er to the directory object */
  4852                        ;	UINT n_ent				/* Numbe
                    r of contiguous entries to allocate */
  4853                        ;)
  4854                        ;{
  4855                        	code
  4856                        	func
  4857                        ~~dir_alloc:
  4858                        	longa	on
  4859                        	longi	on
  4860 00:1558: 3B           	tsc
  4861 00:1559: 38           	sec
  4862 00:155A: E9 0C 00     	sbc	#L198
  4863 00:155D: 1B           	tcs
  4864 00:155E: 0B           	phd
  4865 00:155F: 5B           	tcd
  4866             00000004   dp_0	set	4
  4867             00000008   n_ent_0	set	8
  4868                        ;	FRESULT res;
  4869                        ;	UINT n;
  4870                        ;	FATFS *fs = dp->obj.fs;
  4871                        ;
  4872                        ;
  4873                        ;	res = dir_sdi(dp, 0);
  4874             00000000   res_1	set	0
  4875             00000002   n_1	set	2
  4876             00000004   fs_1	set	4
  4877 00:1560: A7 10        	lda	[<L198+dp_0]
  4878 00:1562: 85 09        	sta	<L199+fs_1
  4879 00:1564: A0 02 00     	ldy	#$2
  4880 00:1567: B7 10        	lda	[<L198+dp_0],Y
  4881 00:1569: 85 0B        	sta	<L199+fs_1+2
  4882 00:156B: F4 00 00     	pea	#^$0
  4883 00:156E: F4 00 00     	pea	#<$0
  4884 00:1571: D4 12        	pei	<L198+dp_0+2
  4885 00:1573: D4 10        	pei	<L198+dp_0
  4886 00:1575: 22 xx xx xx  	jsl	~~dir_sdi
  4887 00:1579: 85 05        	sta	<L199+res_1
  4888                        ;	if (res == FR_OK) {
  4889 00:157B: A5 05        	lda	<L199+res_1
  4890 00:157D: F0 03        	beq	L200
  4891 00:157F: 82 76 00     	brl	L10095
  4892                        L200:
  4893                        ;		n = 0;
  4894 00:1582: 64 07        	stz	<L199+n_1
  4895                        ;		do {
  4896                        L10098:
  4897                        ;			res = move_window(fs, dp->sect);
  Thu May 20 2021 21:37                                                Page 103


  4898 00:1584: A0 1A 00     	ldy	#$1a
  4899 00:1587: B7 10        	lda	[<L198+dp_0],Y
  4900 00:1589: 48           	pha
  4901 00:158A: A0 18 00     	ldy	#$18
  4902 00:158D: B7 10        	lda	[<L198+dp_0],Y
  4903 00:158F: 48           	pha
  4904 00:1590: D4 0B        	pei	<L199+fs_1+2
  4905 00:1592: D4 09        	pei	<L199+fs_1
  4906 00:1594: 22 xx xx xx  	jsl	~~move_window
  4907 00:1598: 85 05        	sta	<L199+res_1
  4908                        ;			if (res != FR_OK) break;
  4909 00:159A: A5 05        	lda	<L199+res_1
  4910 00:159C: F0 03        	beq	L201
  4911 00:159E: 82 57 00     	brl	L10097
  4912                        L201:
  4913                        ;#if FF_FS_EXFAT
  4914                        ;			if ((fs->fs_type == FS_EXFAT) ? 
                    (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_
                    Name] == DDEM || dp->dir[DIR_Name] == 0)) {	/* Is the entry 
                    free? */
  4915                        ;#else
  4916                        ;			if (dp->dir[DIR_Name] == DDEM ||
                     dp->dir[DIR_Name] == 0) {	/* Is the entry free? */
  4917 00:15A1: A0 1C 00     	ldy	#$1c
  4918 00:15A4: B7 10        	lda	[<L198+dp_0],Y
  4919 00:15A6: 85 01        	sta	<R0
  4920 00:15A8: A0 1E 00     	ldy	#$1e
  4921 00:15AB: B7 10        	lda	[<L198+dp_0],Y
  4922 00:15AD: 85 03        	sta	<R0+2
  4923 00:15AF: E2 20        	sep	#$20
  4924                        	longa	off
  4925 00:15B1: A7 01        	lda	[<R0]
  4926 00:15B3: C9 E5        	cmp	#<$e5
  4927 00:15B5: C2 20        	rep	#$20
  4928                        	longa	on
  4929 00:15B7: D0 03        	bne	L203
  4930 00:15B9: 82 18 00     	brl	L202
  4931                        L203:
  4932 00:15BC: A0 1C 00     	ldy	#$1c
  4933 00:15BF: B7 10        	lda	[<L198+dp_0],Y
  4934 00:15C1: 85 01        	sta	<R0
  4935 00:15C3: A0 1E 00     	ldy	#$1e
  4936 00:15C6: B7 10        	lda	[<L198+dp_0],Y
  4937 00:15C8: 85 03        	sta	<R0+2
  4938 00:15CA: A7 01        	lda	[<R0]
  4939 00:15CC: 29 FF 00     	and	#$ff
  4940 00:15CF: F0 03        	beq	L204
  4941 00:15D1: 82 0E 00     	brl	L10099
  4942                        L204:
  4943                        L202:
  4944                        ;#endif
  4945                        ;				if (++n == n_ent) break;
                    	/* Is a block of contiguous free entries found? */
  4946 00:15D4: E6 07        	inc	<L199+n_1
  4947 00:15D6: A5 07        	lda	<L199+n_1
  4948 00:15D8: C5 14        	cmp	<L198+n_ent_0
  4949 00:15DA: D0 03        	bne	L205
  4950 00:15DC: 82 19 00     	brl	L10097
  Thu May 20 2021 21:37                                                Page 104


  4951                        L205:
  4952                        ;			} else {
  4953 00:15DF: 82 02 00     	brl	L10100
  4954                        L10099:
  4955                        ;				n = 0;			
                    	/* Not a free entry, restart to search */
  4956 00:15E2: 64 07        	stz	<L199+n_1
  4957                        ;			}
  4958                        L10100:
  4959                        ;			res = dir_next(dp, 1);	/* Next 
                    entry with table stretch enabled */
  4960 00:15E4: F4 01 00     	pea	#<$1
  4961 00:15E7: D4 12        	pei	<L198+dp_0+2
  4962 00:15E9: D4 10        	pei	<L198+dp_0
  4963 00:15EB: 22 xx xx xx  	jsl	~~dir_next
  4964 00:15EF: 85 05        	sta	<L199+res_1
  4965                        ;		} while (res == FR_OK);
  4966                        L10096:
  4967 00:15F1: A5 05        	lda	<L199+res_1
  4968 00:15F3: D0 03        	bne	L206
  4969 00:15F5: 82 8C FF     	brl	L10098
  4970                        L206:
  4971                        L10097:
  4972                        ;	}
  4973                        ;
  4974                        ;	if (res == FR_NO_FILE) res = FR_DENIED;	/* No di
                    rectory entry to allocate */
  4975                        L10095:
  4976 00:15F8: A5 05        	lda	<L199+res_1
  4977 00:15FA: C9 04 00     	cmp	#<$4
  4978 00:15FD: F0 03        	beq	L207
  4979 00:15FF: 82 05 00     	brl	L10101
  4980                        L207:
  4981 00:1602: A9 07 00     	lda	#$7
  4982 00:1605: 85 05        	sta	<L199+res_1
  4983                        ;	return res;
  4984                        L10101:
  4985 00:1607: A5 05        	lda	<L199+res_1
  4986                        L208:
  4987 00:1609: A8           	tay
  4988 00:160A: A5 0E        	lda	<L198+2
  4989 00:160C: 85 14        	sta	<L198+2+6
  4990 00:160E: A5 0D        	lda	<L198+1
  4991 00:1610: 85 13        	sta	<L198+1+6
  4992 00:1612: 2B           	pld
  4993 00:1613: 3B           	tsc
  4994 00:1614: 18           	clc
  4995 00:1615: 69 12 00     	adc	#L198+6
  4996 00:1618: 1B           	tcs
  4997 00:1619: 98           	tya
  4998 00:161A: 6B           	rtl
  4999                        ;}
  5000             0000000C   L198	equ	12
  5001             00000005   L199	equ	5
  5002                        	ends
  5003                        	efunc
  5004                        ;
  5005                        ;#endif	/* !FF_FS_READONLY */
  Thu May 20 2021 21:37                                                Page 105


  5006                        ;
  5007                        ;
  5008                        ;
  5009                        ;
  5010                        ;/*-----------------------------------------------
                    ------------------------*/
  5011                        ;/* FAT: Directory handling - Load/Store start clu
                    ster number             */
  5012                        ;/*-----------------------------------------------
                    ------------------------*/
  5013                        ;
  5014                        ;static DWORD ld_clust (	/* Returns the top clust
                    er value of the SFN entry */
  5015                        ;	FATFS* fs,			/* Pointer to th
                    e fs object */
  5016                        ;	const BYTE* dir		/* Pointer to the key en
                    try */
  5017                        ;)
  5018                        ;{
  5019                        	code
  5020                        	func
  5021                        ~~ld_clust:
  5022                        	longa	on
  5023                        	longi	on
  5024 00:161B: 3B           	tsc
  5025 00:161C: 38           	sec
  5026 00:161D: E9 10 00     	sbc	#L209
  5027 00:1620: 1B           	tcs
  5028 00:1621: 0B           	phd
  5029 00:1622: 5B           	tcd
  5030             00000004   fs_0	set	4
  5031             00000008   dir_0	set	8
  5032                        ;	DWORD cl;
  5033                        ;
  5034                        ;	cl = ld_word(dir + DIR_FstClusLO);
  5035             00000000   cl_1	set	0
  5036 00:1623: 18           	clc
  5037 00:1624: A9 1A 00     	lda	#$1a
  5038 00:1627: 65 18        	adc	<L209+dir_0
  5039 00:1629: 85 01        	sta	<R0
  5040 00:162B: A9 00 00     	lda	#$0
  5041 00:162E: 65 1A        	adc	<L209+dir_0+2
  5042 00:1630: 85 03        	sta	<R0+2
  5043 00:1632: D4 03        	pei	<R0+2
  5044 00:1634: D4 01        	pei	<R0
  5045 00:1636: 22 xx xx xx  	jsl	~~ld_word
  5046 00:163A: 85 05        	sta	<R1
  5047 00:163C: A5 05        	lda	<R1
  5048 00:163E: 85 0D        	sta	<L210+cl_1
  5049 00:1640: 64 0F        	stz	<L210+cl_1+2
  5050                        ;	if (fs->fs_type == FS_FAT32) {
  5051 00:1642: E2 20        	sep	#$20
  5052                        	longa	off
  5053 00:1644: A7 14        	lda	[<L209+fs_0]
  5054 00:1646: C9 03        	cmp	#<$3
  5055 00:1648: C2 20        	rep	#$20
  5056                        	longa	on
  5057 00:164A: F0 03        	beq	L211
  Thu May 20 2021 21:37                                                Page 106


  5058 00:164C: 82 3A 00     	brl	L10102
  5059                        L211:
  5060                        ;		cl |= (DWORD)ld_word(dir + DIR_FstClusHI
                    ) << 16;
  5061 00:164F: 18           	clc
  5062 00:1650: A9 14 00     	lda	#$14
  5063 00:1653: 65 18        	adc	<L209+dir_0
  5064 00:1655: 85 05        	sta	<R1
  5065 00:1657: A9 00 00     	lda	#$0
  5066 00:165A: 65 1A        	adc	<L209+dir_0+2
  5067 00:165C: 85 07        	sta	<R1+2
  5068 00:165E: D4 07        	pei	<R1+2
  5069 00:1660: D4 05        	pei	<R1
  5070 00:1662: 22 xx xx xx  	jsl	~~ld_word
  5071 00:1666: 85 09        	sta	<R2
  5072 00:1668: A5 09        	lda	<R2
  5073 00:166A: 85 09        	sta	<R2
  5074 00:166C: 64 0B        	stz	<R2+2
  5075 00:166E: D4 0B        	pei	<R2+2
  5076 00:1670: D4 09        	pei	<R2
  5077 00:1672: A9 10 00     	lda	#$10
  5078                        	xref	~~~lasl
  5079 00:1675: 22 xx xx xx  	jsl	~~~lasl
  5080 00:1679: 85 01        	sta	<R0
  5081 00:167B: 86 03        	stx	<R0+2
  5082 00:167D: A5 0D        	lda	<L210+cl_1
  5083 00:167F: 05 01        	ora	<R0
  5084 00:1681: 85 0D        	sta	<L210+cl_1
  5085 00:1683: A5 0F        	lda	<L210+cl_1+2
  5086 00:1685: 05 03        	ora	<R0+2
  5087 00:1687: 85 0F        	sta	<L210+cl_1+2
  5088                        ;	}
  5089                        ;
  5090                        ;	return cl;
  5091                        L10102:
  5092 00:1689: A6 0F        	ldx	<L210+cl_1+2
  5093 00:168B: A5 0D        	lda	<L210+cl_1
  5094                        L212:
  5095 00:168D: A8           	tay
  5096 00:168E: A5 12        	lda	<L209+2
  5097 00:1690: 85 1A        	sta	<L209+2+8
  5098 00:1692: A5 11        	lda	<L209+1
  5099 00:1694: 85 19        	sta	<L209+1+8
  5100 00:1696: 2B           	pld
  5101 00:1697: 3B           	tsc
  5102 00:1698: 18           	clc
  5103 00:1699: 69 18 00     	adc	#L209+8
  5104 00:169C: 1B           	tcs
  5105 00:169D: 98           	tya
  5106 00:169E: 6B           	rtl
  5107                        ;}
  5108             00000010   L209	equ	16
  5109             0000000D   L210	equ	13
  5110                        	ends
  5111                        	efunc
  5112                        ;
  5113                        ;
  5114                        ;#if !FF_FS_READONLY
  Thu May 20 2021 21:37                                                Page 107


  5115                        ;static void st_clust (
  5116                        ;	FATFS* fs,	/* Pointer to the fs object */
  5117                        ;	BYTE* dir,	/* Pointer to the key entry */
  5118                        ;	DWORD cl	/* Value to be set */
  5119                        ;)
  5120                        ;{
  5121                        	code
  5122                        	func
  5123                        ~~st_clust:
  5124                        	longa	on
  5125                        	longi	on
  5126 00:169F: 3B           	tsc
  5127 00:16A0: 38           	sec
  5128 00:16A1: E9 08 00     	sbc	#L213
  5129 00:16A4: 1B           	tcs
  5130 00:16A5: 0B           	phd
  5131 00:16A6: 5B           	tcd
  5132             00000004   fs_0	set	4
  5133             00000008   dir_0	set	8
  5134             0000000C   cl_0	set	12
  5135                        ;	st_word(dir + DIR_FstClusLO, (WORD)cl);
  5136 00:16A7: D4 14        	pei	<L213+cl_0
  5137 00:16A9: 18           	clc
  5138 00:16AA: A9 1A 00     	lda	#$1a
  5139 00:16AD: 65 10        	adc	<L213+dir_0
  5140 00:16AF: 85 01        	sta	<R0
  5141 00:16B1: A9 00 00     	lda	#$0
  5142 00:16B4: 65 12        	adc	<L213+dir_0+2
  5143 00:16B6: 85 03        	sta	<R0+2
  5144 00:16B8: D4 03        	pei	<R0+2
  5145 00:16BA: D4 01        	pei	<R0
  5146 00:16BC: 22 xx xx xx  	jsl	~~st_word
  5147                        ;	if (fs->fs_type == FS_FAT32) {
  5148 00:16C0: E2 20        	sep	#$20
  5149                        	longa	off
  5150 00:16C2: A7 0C        	lda	[<L213+fs_0]
  5151 00:16C4: C9 03        	cmp	#<$3
  5152 00:16C6: C2 20        	rep	#$20
  5153                        	longa	on
  5154 00:16C8: F0 03        	beq	L215
  5155 00:16CA: 82 28 00     	brl	L10103
  5156                        L215:
  5157                        ;		st_word(dir + DIR_FstClusHI, (WORD)(cl >
                    > 16));
  5158 00:16CD: D4 16        	pei	<L213+cl_0+2
  5159 00:16CF: D4 14        	pei	<L213+cl_0
  5160 00:16D1: A9 10 00     	lda	#$10
  5161                        	xref	~~~llsr
  5162 00:16D4: 22 xx xx xx  	jsl	~~~llsr
  5163 00:16D8: 85 01        	sta	<R0
  5164 00:16DA: 86 03        	stx	<R0+2
  5165 00:16DC: D4 01        	pei	<R0
  5166 00:16DE: 18           	clc
  5167 00:16DF: A9 14 00     	lda	#$14
  5168 00:16E2: 65 10        	adc	<L213+dir_0
  5169 00:16E4: 85 05        	sta	<R1
  5170 00:16E6: A9 00 00     	lda	#$0
  5171 00:16E9: 65 12        	adc	<L213+dir_0+2
  Thu May 20 2021 21:37                                                Page 108


  5172 00:16EB: 85 07        	sta	<R1+2
  5173 00:16ED: D4 07        	pei	<R1+2
  5174 00:16EF: D4 05        	pei	<R1
  5175 00:16F1: 22 xx xx xx  	jsl	~~st_word
  5176                        ;	}
  5177                        ;}
  5178                        L10103:
  5179                        L216:
  5180 00:16F5: A5 0A        	lda	<L213+2
  5181 00:16F7: 85 16        	sta	<L213+2+12
  5182 00:16F9: A5 09        	lda	<L213+1
  5183 00:16FB: 85 15        	sta	<L213+1+12
  5184 00:16FD: 2B           	pld
  5185 00:16FE: 3B           	tsc
  5186 00:16FF: 18           	clc
  5187 00:1700: 69 14 00     	adc	#L213+12
  5188 00:1703: 1B           	tcs
  5189 00:1704: 6B           	rtl
  5190             00000008   L213	equ	8
  5191             00000009   L214	equ	9
  5192                        	ends
  5193                        	efunc
  5194                        ;#endif
  5195                        ;
  5196                        ;
  5197                        ;
  5198                        ;#if FF_USE_LFN
  5199                        ;/*-----------------------------------------------
                    ---------*/
  5200                        ;/* FAT-LFN: Compare a part of file name with an L
                    FN entry */
  5201                        ;/*-----------------------------------------------
                    ---------*/
  5202                        ;
  5203                        ;static int cmp_lfn (		/* 1:matched, 0:
                    not matched */
  5204                        ;	const WCHAR* lfnbuf,	/* Pointer to the LFN wo
                    rking buffer to be compared */
  5205                        ;	BYTE* dir				/* Point
                    er to the directory entry containing the part of LFN */
  5206                        ;)
  5207                        ;{
  5208                        ;	UINT i, s;
  5209                        ;	WCHAR wc, uc;
  5210                        ;
  5211                        ;
  5212                        ;	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0
                    ;	/* Check LDIR_FstClusLO */
  5213                        ;
  5214                        ;	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offse
                    t in the LFN buffer */
  5215                        ;
  5216                        ;	for (wc = 1, s = 0; s < 13; s++) {		
                    /* Process all characters in the entry */
  5217                        ;		uc = ld_word(dir + LfnOfs[s]);		
                    /* Pick an LFN character */
  5218                        ;		if (wc != 0) {
  5219                        ;			if (i >= FF_MAX_LFN + 1 || ff_wt
  Thu May 20 2021 21:37                                                Page 109


                    oupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
  5220                        ;				return 0;		
                    			/* Not matched */
  5221                        ;			}
  5222                        ;			wc = uc;
  5223                        ;		} else {
  5224                        ;			if (uc != 0xFFFF) return 0;	
                    	/* Check filler */
  5225                        ;		}
  5226                        ;	}
  5227                        ;
  5228                        ;	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) r
                    eturn 0;	/* Last segment matched but different length */
  5229                        ;
  5230                        ;	return 1;		/* The part of LFN match
                    ed */
  5231                        ;}
  5232                        ;
  5233                        ;
  5234                        ;#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF
                    _USE_LABEL || FF_FS_EXFAT
  5235                        ;/*-----------------------------------------------
                    ------*/
  5236                        ;/* FAT-LFN: Pick a part of file name from an LFN 
                    entry */
  5237                        ;/*-----------------------------------------------
                    ------*/
  5238                        ;
  5239                        ;static int pick_lfn (	/* 1:succeeded, 0:buffer
                     overflow or invalid LFN entry */
  5240                        ;	WCHAR* lfnbuf,		/* Pointer to the LFN wo
                    rking buffer */
  5241                        ;	BYTE* dir			/* Pointer to th
                    e LFN entry */
  5242                        ;)
  5243                        ;{
  5244                        ;	UINT i, s;
  5245                        ;	WCHAR wc, uc;
  5246                        ;
  5247                        ;
  5248                        ;	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0
                    ;	/* Check LDIR_FstClusLO is 0 */
  5249                        ;
  5250                        ;	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offse
                    t in the LFN buffer */
  5251                        ;
  5252                        ;	for (wc = 1, s = 0; s < 13; s++) {		
                    /* Process all characters in the entry */
  5253                        ;		uc = ld_word(dir + LfnOfs[s]);		
                    /* Pick an LFN character */
  5254                        ;		if (wc != 0) {
  5255                        ;			if (i >= FF_MAX_LFN + 1) return 
                    0;	/* Buffer overflow? */
  5256                        ;			lfnbuf[i++] = wc = uc;		
                    	/* Store it */
  5257                        ;		} else {
  5258                        ;			if (uc != 0xFFFF) return 0;	
                    	/* Check filler */
  Thu May 20 2021 21:37                                                Page 110


  5259                        ;		}
  5260                        ;	}
  5261                        ;
  5262                        ;	if (dir[LDIR_Ord] & LLEF && wc != 0) {	/* Put t
                    erminator if it is the last LFN part and not terminated */
  5263                        ;		if (i >= FF_MAX_LFN + 1) return 0;	
                    /* Buffer overflow? */
  5264                        ;		lfnbuf[i] = 0;
  5265                        ;	}
  5266                        ;
  5267                        ;	return 1;		/* The part of LFN is va
                    lid */
  5268                        ;}
  5269                        ;#endif
  5270                        ;
  5271                        ;
  5272                        ;#if !FF_FS_READONLY
  5273                        ;/*-----------------------------------------*/
  5274                        ;/* FAT-LFN: Create an entry of LFN entries */
  5275                        ;/*-----------------------------------------*/
  5276                        ;
  5277                        ;static void put_lfn (
  5278                        ;	const WCHAR* lfn,	/* Pointer to the LFN */
  5279                        ;	BYTE* dir,			/* Pointer to th
                    e LFN entry to be created */
  5280                        ;	BYTE ord,			/* LFN order (1-
                    20) */
  5281                        ;	BYTE sum			/* Checksum of t
                    he corresponding SFN */
  5282                        ;)
  5283                        ;{
  5284                        ;	UINT i, s;
  5285                        ;	WCHAR wc;
  5286                        ;
  5287                        ;
  5288                        ;	dir[LDIR_Chksum] = sum;			/* Set c
                    hecksum */
  5289                        ;	dir[LDIR_Attr] = AM_LFN;		/* Set a
                    ttribute. LFN entry */
  5290                        ;	dir[LDIR_Type] = 0;
  5291                        ;	st_word(dir + LDIR_FstClusLO, 0);
  5292                        ;
  5293                        ;	i = (ord - 1) * 13;				
                    /* Get offset in the LFN working buffer */
  5294                        ;	s = wc = 0;
  5295                        ;	do {
  5296                        ;		if (wc != 0xFFFF) wc = lfn[i++];	
                    /* Get an effective character */
  5297                        ;		st_word(dir + LfnOfs[s], wc);		
                    /* Put it */
  5298                        ;		if (wc == 0) wc = 0xFFFF;		
                    	/* Padding characters for following items */
  5299                        ;	} while (++s < 13);
  5300                        ;	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	
                    /* Last LFN part is the start of LFN sequence */
  5301                        ;	dir[LDIR_Ord] = ord;			/* Set t
                    he LFN order */
  5302                        ;}
  Thu May 20 2021 21:37                                                Page 111


  5303                        ;
  5304                        ;#endif	/* !FF_FS_READONLY */
  5305                        ;#endif	/* FF_USE_LFN */
  5306                        ;
  5307                        ;
  5308                        ;
  5309                        ;#if FF_USE_LFN && !FF_FS_READONLY
  5310                        ;/*-----------------------------------------------
                    ------------------------*/
  5311                        ;/* FAT-LFN: Create a Numbered SFN                
                                            */
  5312                        ;/*-----------------------------------------------
                    ------------------------*/
  5313                        ;
  5314                        ;static void gen_numname (
  5315                        ;	BYTE* dst,			/* Pointer to th
                    e buffer to store numbered SFN */
  5316                        ;	const BYTE* src,	/* Pointer to SFN in dir
                    ectory form */
  5317                        ;	const WCHAR* lfn,	/* Pointer to LFN */
  5318                        ;	UINT seq			/* Sequence numb
                    er */
  5319                        ;)
  5320                        ;{
  5321                        ;	BYTE ns[8], c;
  5322                        ;	UINT i, j;
  5323                        ;	WCHAR wc;
  5324                        ;	DWORD sreg;
  5325                        ;
  5326                        ;
  5327                        ;	memcpy(dst, src, 11);	/* Prepare the SFN to be
                     modified */
  5328                        ;
  5329                        ;	if (seq > 5) {	/* In case of many collisions, g
                    enerate a hash number instead of sequential number */
  5330                        ;		sreg = seq;
  5331                        ;		while (*lfn) {	/* Create a CRC as hash 
                    value */
  5332                        ;			wc = *lfn++;
  5333                        ;			for (i = 0; i < 16; i++) {
  5334                        ;				sreg = (sreg << 1) + (wc
                     & 1);
  5335                        ;				wc >>= 1;
  5336                        ;				if (sreg & 0x10000) sreg
                     ^= 0x11021;
  5337                        ;			}
  5338                        ;		}
  5339                        ;		seq = (UINT)sreg;
  5340                        ;	}
  5341                        ;
  5342                        ;	/* Make suffix (~ + hexdecimal) */
  5343                        ;	i = 7;
  5344                        ;	do {
  5345                        ;		c = (BYTE)((seq % 16) + '0'); seq /= 16;
  5346                        ;		if (c > '9') c += 7;
  5347                        ;		ns[i--] = c;
  5348                        ;	} while (i && seq);
  5349                        ;	ns[i] = '~';
  Thu May 20 2021 21:37                                                Page 112


  5350                        ;
  5351                        ;	/* Append the suffix to the SFN body */
  5352                        ;	for (j = 0; j < i && dst[j] != ' '; j++) {	
                    /* Find the offset to append */
  5353                        ;		if (dbc_1st(dst[j])) {	/* To avoid DBC 
                    break up */
  5354                        ;			if (j == i - 1) break;
  5355                        ;			j++;
  5356                        ;		}
  5357                        ;	}
  5358                        ;	do {	/* Append the suffix */
  5359                        ;		dst[j++] = (i < 8) ? ns[i++] : ' ';
  5360                        ;	} while (j < 8);
  5361                        ;}
  5362                        ;#endif	/* FF_USE_LFN && !FF_FS_READONLY */
  5363                        ;
  5364                        ;
  5365                        ;
  5366                        ;#if FF_USE_LFN
  5367                        ;/*-----------------------------------------------
                    ------------------------*/
  5368                        ;/* FAT-LFN: Calculate checksum of an SFN entry   
                                            */
  5369                        ;/*-----------------------------------------------
                    ------------------------*/
  5370                        ;
  5371                        ;static BYTE sum_sfn (
  5372                        ;	const BYTE* dir		/* Pointer to the SFN en
                    try */
  5373                        ;)
  5374                        ;{
  5375                        ;	BYTE sum = 0;
  5376                        ;	UINT n = 11;
  5377                        ;
  5378                        ;	do {
  5379                        ;		sum = (sum >> 1) + (sum << 7) + *dir++;
  5380                        ;	} while (--n);
  5381                        ;	return sum;
  5382                        ;}
  5383                        ;
  5384                        ;#endif	/* FF_USE_LFN */
  5385                        ;
  5386                        ;
  5387                        ;
  5388                        ;#if FF_FS_EXFAT
  5389                        ;/*-----------------------------------------------
                    ------------------------*/
  5390                        ;/* exFAT: Checksum                               
                                            */
  5391                        ;/*-----------------------------------------------
                    ------------------------*/
  5392                        ;
  5393                        ;static WORD xdir_sum (	/* Get checksum of the d
                    irectoly entry block */
  5394                        ;	const BYTE* dir		/* Directory entry block
                     to be calculated */
  5395                        ;)
  5396                        ;{
  Thu May 20 2021 21:37                                                Page 113


  5397                        ;	UINT i, szblk;
  5398                        ;	WORD sum;
  5399                        ;
  5400                        ;
  5401                        ;	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	
                    /* Number of bytes of the entry block */
  5402                        ;	for (i = sum = 0; i < szblk; i++) {
  5403                        ;		if (i == XDIR_SetSum) {	/* Skip 2-byte s
                    um field */
  5404                        ;			i++;
  5405                        ;		} else {
  5406                        ;			sum = ((sum & 1) ? 0x8000 : 0) +
                     (sum >> 1) + dir[i];
  5407                        ;		}
  5408                        ;	}
  5409                        ;	return sum;
  5410                        ;}
  5411                        ;
  5412                        ;
  5413                        ;
  5414                        ;static WORD xname_sum (	/* Get check sum (to be 
                    used as hash) of the file name */
  5415                        ;	const WCHAR* name	/* File name to be calcu
                    lated */
  5416                        ;)
  5417                        ;{
  5418                        ;	WCHAR chr;
  5419                        ;	WORD sum = 0;
  5420                        ;
  5421                        ;
  5422                        ;	while ((chr = *name++) != 0) {
  5423                        ;		chr = (WCHAR)ff_wtoupper(chr);		
                    /* File name needs to be up-case converted */
  5424                        ;		sum = ((sum & 1) ? 0x8000 : 0) + (sum >>
                     1) + (chr & 0xFF);
  5425                        ;		sum = ((sum & 1) ? 0x8000 : 0) + (sum >>
                     1) + (chr >> 8);
  5426                        ;	}
  5427                        ;	return sum;
  5428                        ;}
  5429                        ;
  5430                        ;
  5431                        ;#if !FF_FS_READONLY && FF_USE_MKFS
  5432                        ;static DWORD xsum32 (	/* Returns 32-bit checks
                    um */
  5433                        ;	BYTE  dat,			/* Byte to be ca
                    lculated (byte-by-byte processing) */
  5434                        ;	DWORD sum			/* Previous sum 
                    value */
  5435                        ;)
  5436                        ;{
  5437                        ;	sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) 
                    + dat;
  5438                        ;	return sum;
  5439                        ;}
  5440                        ;#endif
  5441                        ;
  5442                        ;
  Thu May 20 2021 21:37                                                Page 114


  5443                        ;
  5444                        ;/*-----------------------------------*/
  5445                        ;/* exFAT: Get a directry entry block */
  5446                        ;/*-----------------------------------*/
  5447                        ;
  5448                        ;static FRESULT load_xdir (	/* FR_INT_ERR: i
                    nvalid entry block */
  5449                        ;	DIR* dp					/* Readi
                    ng direcotry object pointing top of the entry block to load 
                    */
  5450                        ;)
  5451                        ;{
  5452                        ;	FRESULT res;
  5453                        ;	UINT i, sz_ent;
  5454                        ;	BYTE *dirb = dp->obj.fs->dirbuf;	/* Point
                    er to the on-memory direcotry entry block 85+C0+C1s */
  5455                        ;
  5456                        ;
  5457                        ;	/* Load file directory entry */
  5458                        ;	res = move_window(dp->obj.fs, dp->sect);
  5459                        ;	if (res != FR_OK) return res;
  5460                        ;	if (dp->dir[XDIR_Type] != ET_FILEDIR) return FR_
                    INT_ERR;	/* Invalid order */
  5461                        ;	memcpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
  5462                        ;	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
  5463                        ;	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE)
                     return FR_INT_ERR;
  5464                        ;
  5465                        ;	/* Load stream extension entry */
  5466                        ;	res = dir_next(dp, 0);
  5467                        ;	if (res == FR_NO_FILE) res = FR_INT_ERR;	
                    /* It cannot be */
  5468                        ;	if (res != FR_OK) return res;
  5469                        ;	res = move_window(dp->obj.fs, dp->sect);
  5470                        ;	if (res != FR_OK) return res;
  5471                        ;	if (dp->dir[XDIR_Type] != ET_STREAM) return FR_I
                    NT_ERR;	/* Invalid order */
  5472                        ;	memcpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
  5473                        ;	if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return
                     FR_INT_ERR;
  5474                        ;
  5475                        ;	/* Load file name entries */
  5476                        ;	i = 2 * SZDIRE;	/* Name offset to load */
  5477                        ;	do {
  5478                        ;		res = dir_next(dp, 0);
  5479                        ;		if (res == FR_NO_FILE) res = FR_INT_ERR;
                    	/* It cannot be */
  5480                        ;		if (res != FR_OK) return res;
  5481                        ;		res = move_window(dp->obj.fs, dp->sect);
  5482                        ;		if (res != FR_OK) return res;
  5483                        ;		if (dp->dir[XDIR_Type] != ET_FILENAME) r
                    eturn FR_INT_ERR;	/* Invalid order */
  5484                        ;		if (i < MAXDIRB(FF_MAX_LFN)) memcpy(dirb
                     + i, dp->dir, SZDIRE);
  5485                        ;	} while ((i += SZDIRE) < sz_ent);
  5486                        ;
  5487                        ;	/* Sanity check (do it for only accessible objec
                    t) */
  Thu May 20 2021 21:37                                                Page 115


  5488                        ;	if (i <= MAXDIRB(FF_MAX_LFN)) {
  5489                        ;		if (xdir_sum(dirb) != ld_word(dirb + XDI
                    R_SetSum)) return FR_INT_ERR;
  5490                        ;	}
  5491                        ;	return FR_OK;
  5492                        ;}
  5493                        ;
  5494                        ;
  5495                        ;/*-----------------------------------------------
                    -------------------*/
  5496                        ;/* exFAT: Initialize object allocation info with 
                    loaded entry block */
  5497                        ;/*-----------------------------------------------
                    -------------------*/
  5498                        ;
  5499                        ;static void init_alloc_info (
  5500                        ;	FATFS* fs,		/* Filesystem object */
  5501                        ;	FFOBJID* obj	/* Object allocation information
                     to be initialized */
  5502                        ;)
  5503                        ;{
  5504                        ;	obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus
                    );		/* Start cluster */
  5505                        ;	obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSi
                    ze);	/* Size */
  5506                        ;	obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;	
                    			/* Allocation status */
  5507                        ;	obj->n_frag = 0;				
                    						/* No last fragm
                    ent info */
  5508                        ;}
  5509                        ;
  5510                        ;
  5511                        ;
  5512                        ;#if !FF_FS_READONLY || FF_FS_RPATH != 0
  5513                        ;/*-----------------------------------------------
                    -*/
  5514                        ;/* exFAT: Load the object's directory entry block
                     */
  5515                        ;/*-----------------------------------------------
                    -*/
  5516                        ;
  5517                        ;static FRESULT load_obj_xdir (
  5518                        ;	DIR* dp,			/* Blank directo
                    ry object to be used to access containing direcotry */
  5519                        ;	const FFOBJID* obj	/* Object with its conta
                    ining directory information */
  5520                        ;)
  5521                        ;{
  5522                        ;	FRESULT res;
  5523                        ;
  5524                        ;	/* Open object containing directory */
  5525                        ;	dp->obj.fs = obj->fs;
  5526                        ;	dp->obj.sclust = obj->c_scl;
  5527                        ;	dp->obj.stat = (BYTE)obj->c_size;
  5528                        ;	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
  5529                        ;	dp->obj.n_frag = 0;
  5530                        ;	dp->blk_ofs = obj->c_ofs;
  Thu May 20 2021 21:37                                                Page 116


  5531                        ;
  5532                        ;	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's
                     entry block */
  5533                        ;	if (res == FR_OK) {
  5534                        ;		res = load_xdir(dp);		/* Load 
                    the object's entry block */
  5535                        ;	}
  5536                        ;	return res;
  5537                        ;}
  5538                        ;#endif
  5539                        ;
  5540                        ;
  5541                        ;#if !FF_FS_READONLY
  5542                        ;/*----------------------------------------*/
  5543                        ;/* exFAT: Store the directory entry block */
  5544                        ;/*----------------------------------------*/
  5545                        ;
  5546                        ;static FRESULT store_xdir (
  5547                        ;	DIR* dp				/* Pointer to th
                    e direcotry object */
  5548                        ;)
  5549                        ;{
  5550                        ;	FRESULT res;
  5551                        ;	UINT nent;
  5552                        ;	BYTE *dirb = dp->obj.fs->dirbuf;	/* Point
                    er to the direcotry entry block 85+C0+C1s */
  5553                        ;
  5554                        ;	/* Create set sum */
  5555                        ;	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
  5556                        ;	nent = dirb[XDIR_NumSec] + 1;
  5557                        ;
  5558                        ;	/* Store the direcotry entry block to the direct
                    ory */
  5559                        ;	res = dir_sdi(dp, dp->blk_ofs);
  5560                        ;	while (res == FR_OK) {
  5561                        ;		res = move_window(dp->obj.fs, dp->sect);
  5562                        ;		if (res != FR_OK) break;
  5563                        ;		memcpy(dp->dir, dirb, SZDIRE);
  5564                        ;		dp->obj.fs->wflag = 1;
  5565                        ;		if (--nent == 0) break;
  5566                        ;		dirb += SZDIRE;
  5567                        ;		res = dir_next(dp, 0);
  5568                        ;	}
  5569                        ;	return (res == FR_OK || res == FR_DISK_ERR) ? re
                    s : FR_INT_ERR;
  5570                        ;}
  5571                        ;
  5572                        ;
  5573                        ;
  5574                        ;/*-------------------------------------------*/
  5575                        ;/* exFAT: Create a new directory enrty block */
  5576                        ;/*-------------------------------------------*/
  5577                        ;
  5578                        ;static void create_xdir (
  5579                        ;	BYTE* dirb,			/* Pointer to th
                    e direcotry entry block buffer */
  5580                        ;	const WCHAR* lfn	/* Pointer to the object
                     name */
  Thu May 20 2021 21:37                                                Page 117


  5581                        ;)
  5582                        ;{
  5583                        ;	UINT i;
  5584                        ;	BYTE nc1, nlen;
  5585                        ;	WCHAR wc;
  5586                        ;
  5587                        ;
  5588                        ;	/* Create file-directory and stream-extension en
                    try */
  5589                        ;	memset(dirb, 0, 2 * SZDIRE);
  5590                        ;	dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
  5591                        ;	dirb[1 * SZDIRE + XDIR_Type] = ET_STREAM;
  5592                        ;
  5593                        ;	/* Create file-name entries */
  5594                        ;	i = SZDIRE * 2;	/* Top of file_name entries */
  5595                        ;	nlen = nc1 = 0; wc = 1;
  5596                        ;	do {
  5597                        ;		dirb[i++] = ET_FILENAME; dirb[i++] = 0;
  5598                        ;		do {	/* Fill name field */
  5599                        ;			if (wc != 0 && (wc = lfn[nlen]) 
                    != 0) nlen++;	/* Get a character if exist */
  5600                        ;			st_word(dirb + i, wc); 	/* Store
                     it */
  5601                        ;			i += 2;
  5602                        ;		} while (i % SZDIRE != 0);
  5603                        ;		nc1++;
  5604                        ;	} while (lfn[nlen]);	/* Fill next entry if an
                    y char follows */
  5605                        ;
  5606                        ;	dirb[XDIR_NumName] = nlen;		/* Set n
                    ame length */
  5607                        ;	dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary
                     count (C0 + C1s) */
  5608                        ;	st_word(dirb + XDIR_NameHash, xname_sum(lfn));	
                    /* Set name hash */
  5609                        ;}
  5610                        ;
  5611                        ;#endif	/* !FF_FS_READONLY */
  5612                        ;#endif	/* FF_FS_EXFAT */
  5613                        ;
  5614                        ;
  5615                        ;
  5616                        ;#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF
                    _USE_LABEL || FF_FS_EXFAT
  5617                        ;/*-----------------------------------------------
                    ------------------------*/
  5618                        ;/* Read an object from the directory             
                                            */
  5619                        ;/*-----------------------------------------------
                    ------------------------*/
  5620                        ;
  5621                        ;#define DIR_READ_FILE(dp) dir_read(dp, 0)
  5622                        ;#define DIR_READ_LABEL(dp) dir_read(dp, 1)
  5623                        ;
  5624                        ;static FRESULT dir_read (
  5625                        ;	DIR* dp,		/* Pointer to the direct
                    ory object */
  5626                        ;	int vol			/* Filtered by 0:file/di
  Thu May 20 2021 21:37                                                Page 118


                    rectory or 1:volume label */
  5627                        ;)
  5628                        ;{
  5629                        	code
  5630                        	func
  5631                        ~~dir_read:
  5632                        	longa	on
  5633                        	longi	on
  5634 00:1705: 3B           	tsc
  5635 00:1706: 38           	sec
  5636 00:1707: E9 10 00     	sbc	#L217
  5637 00:170A: 1B           	tcs
  5638 00:170B: 0B           	phd
  5639 00:170C: 5B           	tcd
  5640             00000004   dp_0	set	4
  5641             00000008   vol_0	set	8
  5642                        ;	FRESULT res = FR_NO_FILE;
  5643                        ;	FATFS *fs = dp->obj.fs;
  5644                        ;	BYTE attr, b;
  5645                        ;#if FF_USE_LFN
  5646                        ;	BYTE ord = 0xFF, sum = 0xFF;
  5647                        ;#endif
  5648                        ;
  5649                        ;	while (dp->sect) {
  5650             00000000   res_1	set	0
  5651             00000002   fs_1	set	2
  5652             00000006   attr_1	set	6
  5653             00000007   b_1	set	7
  5654 00:170D: A9 04 00     	lda	#$4
  5655 00:1710: 85 09        	sta	<L218+res_1
  5656 00:1712: A7 14        	lda	[<L217+dp_0]
  5657 00:1714: 85 0B        	sta	<L218+fs_1
  5658 00:1716: A0 02 00     	ldy	#$2
  5659 00:1719: B7 14        	lda	[<L217+dp_0],Y
  5660 00:171B: 85 0D        	sta	<L218+fs_1+2
  5661                        L10104:
  5662 00:171D: A0 18 00     	ldy	#$18
  5663 00:1720: B7 14        	lda	[<L217+dp_0],Y
  5664 00:1722: A0 1A 00     	ldy	#$1a
  5665 00:1725: 17 14        	ora	[<L217+dp_0],Y
  5666 00:1727: D0 03        	bne	L219
  5667 00:1729: 82 CD 00     	brl	L10105
  5668                        L219:
  5669                        ;		res = move_window(fs, dp->sect);
  5670 00:172C: A0 1A 00     	ldy	#$1a
  5671 00:172F: B7 14        	lda	[<L217+dp_0],Y
  5672 00:1731: 48           	pha
  5673 00:1732: A0 18 00     	ldy	#$18
  5674 00:1735: B7 14        	lda	[<L217+dp_0],Y
  5675 00:1737: 48           	pha
  5676 00:1738: D4 0D        	pei	<L218+fs_1+2
  5677 00:173A: D4 0B        	pei	<L218+fs_1
  5678 00:173C: 22 xx xx xx  	jsl	~~move_window
  5679 00:1740: 85 09        	sta	<L218+res_1
  5680                        ;		if (res != FR_OK) break;
  5681 00:1742: A5 09        	lda	<L218+res_1
  5682 00:1744: F0 03        	beq	L220
  5683 00:1746: 82 B0 00     	brl	L10105
  Thu May 20 2021 21:37                                                Page 119


  5684                        L220:
  5685                        ;		b = dp->dir[DIR_Name];	/* Test for the 
                    entry type */
  5686 00:1749: A0 1C 00     	ldy	#$1c
  5687 00:174C: B7 14        	lda	[<L217+dp_0],Y
  5688 00:174E: 85 01        	sta	<R0
  5689 00:1750: A0 1E 00     	ldy	#$1e
  5690 00:1753: B7 14        	lda	[<L217+dp_0],Y
  5691 00:1755: 85 03        	sta	<R0+2
  5692 00:1757: E2 20        	sep	#$20
  5693                        	longa	off
  5694 00:1759: A7 01        	lda	[<R0]
  5695 00:175B: 85 10        	sta	<L218+b_1
  5696 00:175D: C2 20        	rep	#$20
  5697                        	longa	on
  5698                        ;		if (b == 0) {
  5699 00:175F: A5 10        	lda	<L218+b_1
  5700 00:1761: 29 FF 00     	and	#$ff
  5701 00:1764: F0 03        	beq	L221
  5702 00:1766: 82 08 00     	brl	L10106
  5703                        L221:
  5704                        ;			res = FR_NO_FILE; break; /* Reac
                    hed to end of the directory */
  5705 00:1769: A9 04 00     	lda	#$4
  5706 00:176C: 85 09        	sta	<L218+res_1
  5707 00:176E: 82 88 00     	brl	L10105
  5708                        ;		}
  5709                        ;#if FF_FS_EXFAT
  5710                        ;		if (fs->fs_type == FS_EXFAT) {	/* On th
                    e exFAT volume */
  5711                        ;			if (FF_USE_LABEL && vol) {
  5712                        ;				if (b == ET_VLABEL) brea
                    k;	/* Volume label entry? */
  5713                        ;			} else {
  5714                        ;				if (b == ET_FILEDIR) {	
                    	/* Start of the file entry block? */
  5715                        ;					dp->blk_ofs = dp
                    ->dptr;	/* Get location of the block */
  5716                        ;					res = load_xdir(
                    dp);	/* Load the entry block */
  5717                        ;					if (res == FR_OK
                    ) {
  5718                        ;						dp->obj.
                    attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute
                     */
  5719                        ;					}
  5720                        ;					break;
  5721                        ;				}
  5722                        ;			}
  5723                        ;		} else
  5724                        ;#endif
  5725                        ;		{	/* On the FAT/FAT32 volume */
  5726                        L10106:
  5727                        ;			dp->obj.attr = attr = dp->dir[DI
                    R_Attr] & AM_MASK;	/* Get attribute */
  5728 00:1771: A0 1C 00     	ldy	#$1c
  5729 00:1774: B7 14        	lda	[<L217+dp_0],Y
  5730 00:1776: 85 01        	sta	<R0
  Thu May 20 2021 21:37                                                Page 120


  5731 00:1778: A0 1E 00     	ldy	#$1e
  5732 00:177B: B7 14        	lda	[<L217+dp_0],Y
  5733 00:177D: 85 03        	sta	<R0+2
  5734 00:177F: E2 20        	sep	#$20
  5735                        	longa	off
  5736 00:1781: A0 0B 00     	ldy	#$b
  5737 00:1784: B7 01        	lda	[<R0],Y
  5738 00:1786: 29 3F        	and	#<$3f
  5739 00:1788: 85 0F        	sta	<L218+attr_1
  5740 00:178A: C2 20        	rep	#$20
  5741                        	longa	on
  5742 00:178C: E2 20        	sep	#$20
  5743                        	longa	off
  5744 00:178E: A5 0F        	lda	<L218+attr_1
  5745 00:1790: A0 06 00     	ldy	#$6
  5746 00:1793: 97 14        	sta	[<L217+dp_0],Y
  5747 00:1795: C2 20        	rep	#$20
  5748                        	longa	on
  5749                        ;#if FF_USE_LFN		/* LFN configuration */
  5750                        ;			if (b == DDEM || b == '.' || (in
                    t)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry with
                    out valid data */
  5751                        ;				ord = 0xFF;
  5752                        ;			} else {
  5753                        ;				if (attr == AM_LFN) {	
                    /* An LFN entry is found */
  5754                        ;					if (b & LLEF) {	
                    	/* Is it start of an LFN sequence? */
  5755                        ;						sum = dp
                    ->dir[LDIR_Chksum];
  5756                        ;						b &= (BY
                    TE)~LLEF; ord = b;
  5757                        ;						dp->blk_
                    ofs = dp->dptr;
  5758                        ;					}
  5759                        ;					/* Check LFN val
                    idity and capture it */
  5760                        ;					ord = (b == ord 
                    && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->d
                    ir)) ? ord - 1 : 0xFF;
  5761                        ;				} else {		
                    		/* An SFN entry is found */
  5762                        ;					if (ord != 0 || 
                    sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
  5763                        ;						dp->blk_
                    ofs = 0xFFFFFFFF;	/* It has no LFN. */
  5764                        ;					}
  5765                        ;					break;
  5766                        ;				}
  5767                        ;			}
  5768                        ;#else		/* Non LFN configuration */
  5769                        ;			if (b != DDEM && b != '.' && att
                    r != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	
                    /* Is it a valid entry? */
  5770 00:1797: E2 20        	sep	#$20
  5771                        	longa	off
  5772 00:1799: A5 10        	lda	<L218+b_1
  5773 00:179B: C9 E5        	cmp	#<$e5
  Thu May 20 2021 21:37                                                Page 121


  5774 00:179D: C2 20        	rep	#$20
  5775                        	longa	on
  5776 00:179F: D0 03        	bne	L222
  5777 00:17A1: 82 3E 00     	brl	L10107
  5778                        L222:
  5779 00:17A4: E2 20        	sep	#$20
  5780                        	longa	off
  5781 00:17A6: A5 10        	lda	<L218+b_1
  5782 00:17A8: C9 2E        	cmp	#<$2e
  5783 00:17AA: C2 20        	rep	#$20
  5784                        	longa	on
  5785 00:17AC: D0 03        	bne	L223
  5786 00:17AE: 82 31 00     	brl	L10107
  5787                        L223:
  5788 00:17B1: E2 20        	sep	#$20
  5789                        	longa	off
  5790 00:17B3: A5 0F        	lda	<L218+attr_1
  5791 00:17B5: C9 0F        	cmp	#<$f
  5792 00:17B7: C2 20        	rep	#$20
  5793                        	longa	on
  5794 00:17B9: D0 03        	bne	L224
  5795 00:17BB: 82 24 00     	brl	L10107
  5796                        L224:
  5797 00:17BE: 64 01        	stz	<R0
  5798 00:17C0: A5 0F        	lda	<L218+attr_1
  5799 00:17C2: 29 FF 00     	and	#$ff
  5800 00:17C5: 29 DF FF     	and	#<$ffffffdf
  5801 00:17C8: 85 05        	sta	<R1
  5802 00:17CA: A5 05        	lda	<R1
  5803 00:17CC: C9 08 00     	cmp	#<$8
  5804 00:17CF: F0 03        	beq	L226
  5805 00:17D1: 82 02 00     	brl	L225
  5806                        L226:
  5807 00:17D4: E6 01        	inc	<R0
  5808                        L225:
  5809 00:17D6: A5 01        	lda	<R0
  5810 00:17D8: C5 18        	cmp	<L217+vol_0
  5811 00:17DA: F0 03        	beq	L227
  5812 00:17DC: 82 03 00     	brl	L10107
  5813                        L227:
  5814                        ;				break;
  5815 00:17DF: 82 17 00     	brl	L10105
  5816                        ;			}
  5817                        ;#endif
  5818                        ;		}
  5819                        L10107:
  5820                        ;		res = dir_next(dp, 0);		/* Next 
                    entry */
  5821 00:17E2: F4 00 00     	pea	#<$0
  5822 00:17E5: D4 16        	pei	<L217+dp_0+2
  5823 00:17E7: D4 14        	pei	<L217+dp_0
  5824 00:17E9: 22 xx xx xx  	jsl	~~dir_next
  5825 00:17ED: 85 09        	sta	<L218+res_1
  5826                        ;		if (res != FR_OK) break;
  5827 00:17EF: A5 09        	lda	<L218+res_1
  5828 00:17F1: F0 03        	beq	L228
  5829 00:17F3: 82 03 00     	brl	L10105
  5830                        L228:
  Thu May 20 2021 21:37                                                Page 122


  5831                        ;	}
  5832 00:17F6: 82 24 FF     	brl	L10104
  5833                        L10105:
  5834                        ;
  5835                        ;	if (res != FR_OK) dp->sect = 0;		/* Termi
                    nate the read operation on error or EOT */
  5836 00:17F9: A5 09        	lda	<L218+res_1
  5837 00:17FB: D0 03        	bne	L229
  5838 00:17FD: 82 10 00     	brl	L10108
  5839                        L229:
  5840 00:1800: A9 00 00     	lda	#$0
  5841 00:1803: A0 18 00     	ldy	#$18
  5842 00:1806: 97 14        	sta	[<L217+dp_0],Y
  5843 00:1808: A9 00 00     	lda	#$0
  5844 00:180B: A0 1A 00     	ldy	#$1a
  5845 00:180E: 97 14        	sta	[<L217+dp_0],Y
  5846                        ;	return res;
  5847                        L10108:
  5848 00:1810: A5 09        	lda	<L218+res_1
  5849                        L230:
  5850 00:1812: A8           	tay
  5851 00:1813: A5 12        	lda	<L217+2
  5852 00:1815: 85 18        	sta	<L217+2+6
  5853 00:1817: A5 11        	lda	<L217+1
  5854 00:1819: 85 17        	sta	<L217+1+6
  5855 00:181B: 2B           	pld
  5856 00:181C: 3B           	tsc
  5857 00:181D: 18           	clc
  5858 00:181E: 69 16 00     	adc	#L217+6
  5859 00:1821: 1B           	tcs
  5860 00:1822: 98           	tya
  5861 00:1823: 6B           	rtl
  5862                        ;}
  5863             00000010   L217	equ	16
  5864             00000009   L218	equ	9
  5865                        	ends
  5866                        	efunc
  5867                        ;
  5868                        ;#endif	/* FF_FS_MINIMIZE <= 1 || FF_USE_LABEL |
                    | FF_FS_RPATH >= 2 */
  5869                        ;
  5870                        ;
  5871                        ;
  5872                        ;/*-----------------------------------------------
                    ------------------------*/
  5873                        ;/* Directory handling - Find an object in the dir
                    ectory                  */
  5874                        ;/*-----------------------------------------------
                    ------------------------*/
  5875                        ;
  5876                        ;static FRESULT dir_find (	/* FR_OK(0):succ
                    eeded, !=0:error */
  5877                        ;	DIR* dp					/* Point
                    er to the directory object with the file name */
  5878                        ;)
  5879                        ;{
  5880                        	code
  5881                        	func
  Thu May 20 2021 21:37                                                Page 123


  5882                        ~~dir_find:
  5883                        	longa	on
  5884                        	longi	on
  5885 00:1824: 3B           	tsc
  5886 00:1825: 38           	sec
  5887 00:1826: E9 0B 00     	sbc	#L231
  5888 00:1829: 1B           	tcs
  5889 00:182A: 0B           	phd
  5890 00:182B: 5B           	tcd
  5891             00000004   dp_0	set	4
  5892                        ;	FRESULT res;
  5893                        ;	FATFS *fs = dp->obj.fs;
  5894                        ;	BYTE c;
  5895                        ;#if FF_USE_LFN
  5896                        ;	BYTE a, ord, sum;
  5897                        ;#endif
  5898                        ;
  5899                        ;	res = dir_sdi(dp, 0);			/* Rewin
                    d directory object */
  5900             00000000   res_1	set	0
  5901             00000002   fs_1	set	2
  5902             00000006   c_1	set	6
  5903 00:182C: A7 0F        	lda	[<L231+dp_0]
  5904 00:182E: 85 07        	sta	<L232+fs_1
  5905 00:1830: A0 02 00     	ldy	#$2
  5906 00:1833: B7 0F        	lda	[<L231+dp_0],Y
  5907 00:1835: 85 09        	sta	<L232+fs_1+2
  5908 00:1837: F4 00 00     	pea	#^$0
  5909 00:183A: F4 00 00     	pea	#<$0
  5910 00:183D: D4 11        	pei	<L231+dp_0+2
  5911 00:183F: D4 0F        	pei	<L231+dp_0
  5912 00:1841: 22 xx xx xx  	jsl	~~dir_sdi
  5913 00:1845: 85 05        	sta	<L232+res_1
  5914                        ;	if (res != FR_OK) return res;
  5915 00:1847: A5 05        	lda	<L232+res_1
  5916 00:1849: D0 03        	bne	L233
  5917 00:184B: 82 14 00     	brl	L10109
  5918                        L233:
  5919 00:184E: A5 05        	lda	<L232+res_1
  5920                        L234:
  5921 00:1850: A8           	tay
  5922 00:1851: A5 0D        	lda	<L231+2
  5923 00:1853: 85 11        	sta	<L231+2+4
  5924 00:1855: A5 0C        	lda	<L231+1
  5925 00:1857: 85 10        	sta	<L231+1+4
  5926 00:1859: 2B           	pld
  5927 00:185A: 3B           	tsc
  5928 00:185B: 18           	clc
  5929 00:185C: 69 0F 00     	adc	#L231+4
  5930 00:185F: 1B           	tcs
  5931 00:1860: 98           	tya
  5932 00:1861: 6B           	rtl
  5933                        ;#if FF_FS_EXFAT
  5934                        ;	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT 
                    volume */
  5935                        ;		BYTE nc;
  5936                        ;		UINT di, ni;
  5937                        ;		WORD hash = xname_sum(fs->lfnbuf);	
  Thu May 20 2021 21:37                                                Page 124


                    	/* Hash value of the name to find */
  5938                        ;
  5939                        ;		while ((res = DIR_READ_FILE(dp)) == FR_O
                    K) {	/* Read an item */
  5940                        ;#if FF_MAX_LFN < 255
  5941                        ;			if (fs->dirbuf[XDIR_NumName] > F
                    F_MAX_LFN) continue;		/* Skip comparison if in
                    accessible object name */
  5942                        ;#endif
  5943                        ;			if (ld_word(fs->dirbuf + XDIR_Na
                    meHash) != hash) continue;	/* Skip comparison if hash misma
                    tched */
  5944                        ;			for (nc = fs->dirbuf[XDIR_NumNam
                    e], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	
                    /* Compare the name */
  5945                        ;				if ((di % SZDIRE) == 0) 
                    di += 2;
  5946                        ;				if (ff_wtoupper(ld_word(
                    fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
  5947                        ;			}
  5948                        ;			if (nc == 0 && !fs->lfnbuf[ni]) 
                    break;	/* Name matched? */
  5949                        ;		}
  5950                        ;		return res;
  5951                        ;	}
  5952                        ;#endif
  5953                        ;	/* On the FAT/FAT32 volume */
  5954                        ;#if FF_USE_LFN
  5955                        ;	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	
                    /* Reset LFN sequence */
  5956                        ;#endif
  5957                        ;	do {
  5958                        L10109:
  5959                        L10112:
  5960                        ;		res = move_window(fs, dp->sect);
  5961 00:1862: A0 1A 00     	ldy	#$1a
  5962 00:1865: B7 0F        	lda	[<L231+dp_0],Y
  5963 00:1867: 48           	pha
  5964 00:1868: A0 18 00     	ldy	#$18
  5965 00:186B: B7 0F        	lda	[<L231+dp_0],Y
  5966 00:186D: 48           	pha
  5967 00:186E: D4 09        	pei	<L232+fs_1+2
  5968 00:1870: D4 07        	pei	<L232+fs_1
  5969 00:1872: 22 xx xx xx  	jsl	~~move_window
  5970 00:1876: 85 05        	sta	<L232+res_1
  5971                        ;		if (res != FR_OK) break;
  5972 00:1878: A5 05        	lda	<L232+res_1
  5973 00:187A: F0 03        	beq	L235
  5974 00:187C: 82 A8 00     	brl	L10111
  5975                        L235:
  5976                        ;		c = dp->dir[DIR_Name];
  5977 00:187F: A0 1C 00     	ldy	#$1c
  5978 00:1882: B7 0F        	lda	[<L231+dp_0],Y
  5979 00:1884: 85 01        	sta	<R0
  5980 00:1886: A0 1E 00     	ldy	#$1e
  5981 00:1889: B7 0F        	lda	[<L231+dp_0],Y
  5982 00:188B: 85 03        	sta	<R0+2
  5983 00:188D: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 125


  5984                        	longa	off
  5985 00:188F: A7 01        	lda	[<R0]
  5986 00:1891: 85 0B        	sta	<L232+c_1
  5987 00:1893: C2 20        	rep	#$20
  5988                        	longa	on
  5989                        ;		if (c == 0) { res = FR_NO_FILE; break; }
                    	/* Reached to end of table */
  5990 00:1895: A5 0B        	lda	<L232+c_1
  5991 00:1897: 29 FF 00     	and	#$ff
  5992 00:189A: F0 03        	beq	L236
  5993 00:189C: 82 08 00     	brl	L10113
  5994                        L236:
  5995 00:189F: A9 04 00     	lda	#$4
  5996 00:18A2: 85 05        	sta	<L232+res_1
  5997 00:18A4: 82 80 00     	brl	L10111
  5998                        ;#if FF_USE_LFN		/* LFN configuration */
  5999                        ;		dp->obj.attr = a = dp->dir[DIR_Attr] & A
                    M_MASK;
  6000                        ;		if (c == DDEM || ((a & AM_VOL) && a != A
                    M_LFN)) {	/* An entry without valid data */
  6001                        ;			ord = 0xFF; dp->blk_ofs = 0xFFFF
                    FFFF;	/* Reset LFN sequence */
  6002                        ;		} else {
  6003                        ;			if (a == AM_LFN) {		
                    	/* An LFN entry is found */
  6004                        ;				if (!(dp->fn[NSFLAG] & N
                    S_NOLFN)) {
  6005                        ;					if (c & LLEF) {	
                    	/* Is it start of LFN sequence? */
  6006                        ;						sum = dp
                    ->dir[LDIR_Chksum];
  6007                        ;						c &= (BY
                    TE)~LLEF; ord = c;	/* LFN start order */
  6008                        ;						dp->blk_
                    ofs = dp->dptr;	/* Start offset of LFN */
  6009                        ;					}
  6010                        ;					/* Check validit
                    y of the LFN entry and compare it with given name */
  6011                        ;					ord = (c == ord 
                    && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->di
                    r)) ? ord - 1 : 0xFF;
  6012                        ;				}
  6013                        ;			} else {			
                    		/* An SFN entry is found */
  6014                        ;				if (ord == 0 && sum == s
                    um_sfn(dp->dir)) break;	/* LFN matched? */
  6015                        ;				if (!(dp->fn[NSFLAG] & N
                    S_LOSS) && !memcmp(dp->dir, dp->fn, 11)) break;	/* SFN m
                    atched? */
  6016                        ;				ord = 0xFF; dp->blk_ofs 
                    = 0xFFFFFFFF;	/* Reset LFN sequence */
  6017                        ;			}
  6018                        ;		}
  6019                        ;#else		/* Non LFN configuration */
  6020                        ;		dp->obj.attr = dp->dir[DIR_Attr] & AM_MA
                    SK;
  6021                        L10113:
  6022 00:18A7: A0 1C 00     	ldy	#$1c
  Thu May 20 2021 21:37                                                Page 126


  6023 00:18AA: B7 0F        	lda	[<L231+dp_0],Y
  6024 00:18AC: 85 01        	sta	<R0
  6025 00:18AE: A0 1E 00     	ldy	#$1e
  6026 00:18B1: B7 0F        	lda	[<L231+dp_0],Y
  6027 00:18B3: 85 03        	sta	<R0+2
  6028 00:18B5: E2 20        	sep	#$20
  6029                        	longa	off
  6030 00:18B7: A0 0B 00     	ldy	#$b
  6031 00:18BA: B7 01        	lda	[<R0],Y
  6032 00:18BC: 29 3F        	and	#<$3f
  6033 00:18BE: C2 20        	rep	#$20
  6034                        	longa	on
  6035 00:18C0: E2 20        	sep	#$20
  6036                        	longa	off
  6037 00:18C2: A0 06 00     	ldy	#$6
  6038 00:18C5: 97 0F        	sta	[<L231+dp_0],Y
  6039 00:18C7: C2 20        	rep	#$20
  6040                        	longa	on
  6041                        ;		if (!(dp->dir[DIR_Attr] & AM_VOL) && !me
                    mcmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? 
                    */
  6042 00:18C9: A0 1C 00     	ldy	#$1c
  6043 00:18CC: B7 0F        	lda	[<L231+dp_0],Y
  6044 00:18CE: 85 01        	sta	<R0
  6045 00:18D0: A0 1E 00     	ldy	#$1e
  6046 00:18D3: B7 0F        	lda	[<L231+dp_0],Y
  6047 00:18D5: 85 03        	sta	<R0+2
  6048 00:18D7: E2 20        	sep	#$20
  6049                        	longa	off
  6050 00:18D9: A0 0B 00     	ldy	#$b
  6051 00:18DC: B7 01        	lda	[<R0],Y
  6052 00:18DE: 29 08        	and	#<$8
  6053 00:18E0: C2 20        	rep	#$20
  6054                        	longa	on
  6055 00:18E2: F0 03        	beq	L238
  6056 00:18E4: 82 2C 00     	brl	L237
  6057                        L238:
  6058 00:18E7: F4 0B 00     	pea	#<$b
  6059 00:18EA: 18           	clc
  6060 00:18EB: A9 20 00     	lda	#$20
  6061 00:18EE: 65 0F        	adc	<L231+dp_0
  6062 00:18F0: 85 01        	sta	<R0
  6063 00:18F2: A9 00 00     	lda	#$0
  6064 00:18F5: 65 11        	adc	<L231+dp_0+2
  6065 00:18F7: 85 03        	sta	<R0+2
  6066 00:18F9: D4 03        	pei	<R0+2
  6067 00:18FB: D4 01        	pei	<R0
  6068 00:18FD: A0 1E 00     	ldy	#$1e
  6069 00:1900: B7 0F        	lda	[<L231+dp_0],Y
  6070 00:1902: 48           	pha
  6071 00:1903: A0 1C 00     	ldy	#$1c
  6072 00:1906: B7 0F        	lda	[<L231+dp_0],Y
  6073 00:1908: 48           	pha
  6074 00:1909: 22 xx xx xx  	jsl	~~memcmp
  6075 00:190D: AA           	tax
  6076 00:190E: D0 03        	bne	L239
  6077 00:1910: 82 14 00     	brl	L10111
  6078                        L239:
  Thu May 20 2021 21:37                                                Page 127


  6079                        L237:
  6080                        ;#endif
  6081                        ;		res = dir_next(dp, 0);	/* Next entry */
  6082 00:1913: F4 00 00     	pea	#<$0
  6083 00:1916: D4 11        	pei	<L231+dp_0+2
  6084 00:1918: D4 0F        	pei	<L231+dp_0
  6085 00:191A: 22 xx xx xx  	jsl	~~dir_next
  6086 00:191E: 85 05        	sta	<L232+res_1
  6087                        ;	} while (res == FR_OK);
  6088                        L10110:
  6089 00:1920: A5 05        	lda	<L232+res_1
  6090 00:1922: D0 03        	bne	L240
  6091 00:1924: 82 3B FF     	brl	L10112
  6092                        L240:
  6093                        L10111:
  6094                        ;
  6095                        ;	return res;
  6096 00:1927: A5 05        	lda	<L232+res_1
  6097 00:1929: 82 24 FF     	brl	L234
  6098                        ;}
  6099             0000000B   L231	equ	11
  6100             00000005   L232	equ	5
  6101                        	ends
  6102                        	efunc
  6103                        ;
  6104                        ;
  6105                        ;
  6106                        ;
  6107                        ;#if !FF_FS_READONLY
  6108                        ;/*-----------------------------------------------
                    ------------------------*/
  6109                        ;/* Register an object to the directory           
                                            */
  6110                        ;/*-----------------------------------------------
                    ------------------------*/
  6111                        ;
  6112                        ;static FRESULT dir_register (	/* FR_OK:succeed
                    ed, FR_DENIED:no free entry or too many SFN collision, FR_DI
                    SK_ERR:disk error */
  6113                        ;	DIR* dp						
                    /* Target directory with object name to be created */
  6114                        ;)
  6115                        ;{
  6116                        	code
  6117                        	func
  6118                        ~~dir_register:
  6119                        	longa	on
  6120                        	longi	on
  6121 00:192C: 3B           	tsc
  6122 00:192D: 38           	sec
  6123 00:192E: E9 0A 00     	sbc	#L241
  6124 00:1931: 1B           	tcs
  6125 00:1932: 0B           	phd
  6126 00:1933: 5B           	tcd
  6127             00000004   dp_0	set	4
  6128                        ;	FRESULT res;
  6129                        ;	FATFS *fs = dp->obj.fs;
  6130                        ;#if FF_USE_LFN		/* LFN configuration */
  Thu May 20 2021 21:37                                                Page 128


  6131                        ;	UINT n, len, n_ent;
  6132                        ;	BYTE sn[12], sum;
  6133                        ;
  6134                        ;
  6135                        ;	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) retur
                    n FR_INVALID_NAME;	/* Check name validity */
  6136                        ;	for (len = 0; fs->lfnbuf[len]; len++) ;	/* Get l
                    fn length */
  6137                        ;
  6138                        ;#if FF_FS_EXFAT
  6139                        ;	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT 
                    volume */
  6140                        ;		n_ent = (len + 14) / 15 + 2;	/* Numbe
                    r of entries to allocate (85+C0+C1s) */
  6141                        ;		res = dir_alloc(dp, n_ent);		
                    /* Allocate directory entries */
  6142                        ;		if (res != FR_OK) return res;
  6143                        ;		dp->blk_ofs = dp->dptr - SZDIRE * (n_ent
                     - 1);	/* Set the allocated entry block offset */
  6144                        ;
  6145                        ;		if (dp->obj.stat & 4) {			
                    /* Has the directory been stretched by new allocation? */
  6146                        ;			dp->obj.stat &= ~4;
  6147                        ;			res = fill_first_frag(&dp->obj);
                    	/* Fill the first fragment on the FAT if needed */
  6148                        ;			if (res != FR_OK) return res;
  6149                        ;			res = fill_last_frag(&dp->obj, d
                    p->clust, 0xFFFFFFFF);	/* Fill the last fragment on the
                     FAT if needed */
  6150                        ;			if (res != FR_OK) return res;
  6151                        ;			if (dp->obj.sclust != 0) {	
                    	/* Is it a sub-directory? */
  6152                        ;				DIR dj;
  6153                        ;
  6154                        ;				res = load_obj_xdir(&dj,
                     &dp->obj);	/* Load the object status */
  6155                        ;				if (res != FR_OK) return
                     res;
  6156                        ;				dp->obj.objsize += (DWOR
                    D)fs->csize * SS(fs);		/* Increase the director
                    y size by cluster size */
  6157                        ;				st_qword(fs->dirbuf + XD
                    IR_FileSize, dp->obj.objsize);
  6158                        ;				st_qword(fs->dirbuf + XD
                    IR_ValidFileSize, dp->obj.objsize);
  6159                        ;				fs->dirbuf[XDIR_GenFlags
                    ] = dp->obj.stat | 1;		/* Update the allocation
                     status */
  6160                        ;				res = store_xdir(&dj);	
                    			/* Store the object status */
  6161                        ;				if (res != FR_OK) return
                     res;
  6162                        ;			}
  6163                        ;		}
  6164                        ;
  6165                        ;		create_xdir(fs->dirbuf, fs->lfnbuf);	
                    /* Create on-memory directory block to be written later */
  6166                        ;		return FR_OK;
  Thu May 20 2021 21:37                                                Page 129


  6167                        ;	}
  6168                        ;#endif
  6169                        ;	/* On the FAT/FAT32 volume */
  6170                        ;	memcpy(sn, dp->fn, 12);
  6171                        ;	if (sn[NSFLAG] & NS_LOSS) {			
                    /* When LFN is out of 8.3 format, generate a numbered name *
                    /
  6172                        ;		dp->fn[NSFLAG] = NS_NOLFN;		
                    /* Find only SFN */
  6173                        ;		for (n = 1; n < 100; n++) {
  6174                        ;			gen_numname(dp->fn, sn, fs->lfnb
                    uf, n);	/* Generate a numbered name */
  6175                        ;			res = dir_find(dp);		
                    		/* Check if the name collides with existing SFN 
                    */
  6176                        ;			if (res != FR_OK) break;
  6177                        ;		}
  6178                        ;		if (n == 100) return FR_DENIED;		
                    /* Abort if too many collisions */
  6179                        ;		if (res != FR_NO_FILE) return res;	
                    /* Abort if the result is other than 'not collided' */
  6180                        ;		dp->fn[NSFLAG] = sn[NSFLAG];
  6181                        ;	}
  6182                        ;
  6183                        ;	/* Create an SFN with/without LFNs. */
  6184                        ;	n_ent = (sn[NSFLAG] & NS_LFN) ? (len + 12) / 13 
                    + 1 : 1;	/* Number of entries to allocate */
  6185                        ;	res = dir_alloc(dp, n_ent);		/* Alloc
                    ate entries */
  6186                        ;	if (res == FR_OK && --n_ent) {	/* Set LFN entry
                     if needed */
  6187                        ;		res = dir_sdi(dp, dp->dptr - n_ent * SZD
                    IRE);
  6188                        ;		if (res == FR_OK) {
  6189                        ;			sum = sum_sfn(dp->fn);	/* Check
                    sum value of the SFN tied to the LFN */
  6190                        ;			do {				
                    	/* Store LFN entries in bottom first */
  6191                        ;				res = move_window(fs, dp
                    ->sect);
  6192                        ;				if (res != FR_OK) break;
  6193                        ;				put_lfn(fs->lfnbuf, dp->
                    dir, (BYTE)n_ent, sum);
  6194                        ;				fs->wflag = 1;
  6195                        ;				res = dir_next(dp, 0);	
                    /* Next entry */
  6196                        ;			} while (res == FR_OK && --n_ent
                    );
  6197                        ;		}
  6198                        ;	}
  6199                        ;
  6200                        ;#else	/* Non LFN configuration */
  6201                        ;	res = dir_alloc(dp, 1);		/* Allocate an e
                    ntry for SFN */
  6202             00000000   res_1	set	0
  6203             00000002   fs_1	set	2
  6204 00:1934: A7 0E        	lda	[<L241+dp_0]
  6205 00:1936: 85 07        	sta	<L242+fs_1
  Thu May 20 2021 21:37                                                Page 130


  6206 00:1938: A0 02 00     	ldy	#$2
  6207 00:193B: B7 0E        	lda	[<L241+dp_0],Y
  6208 00:193D: 85 09        	sta	<L242+fs_1+2
  6209 00:193F: F4 01 00     	pea	#<$1
  6210 00:1942: D4 10        	pei	<L241+dp_0+2
  6211 00:1944: D4 0E        	pei	<L241+dp_0
  6212 00:1946: 22 xx xx xx  	jsl	~~dir_alloc
  6213 00:194A: 85 05        	sta	<L242+res_1
  6214                        ;
  6215                        ;#endif
  6216                        ;
  6217                        ;	/* Set SFN entry */
  6218                        ;	if (res == FR_OK) {
  6219 00:194C: A5 05        	lda	<L242+res_1
  6220 00:194E: F0 03        	beq	L243
  6221 00:1950: 82 64 00     	brl	L10114
  6222                        L243:
  6223                        ;		res = move_window(fs, dp->sect);
  6224 00:1953: A0 1A 00     	ldy	#$1a
  6225 00:1956: B7 0E        	lda	[<L241+dp_0],Y
  6226 00:1958: 48           	pha
  6227 00:1959: A0 18 00     	ldy	#$18
  6228 00:195C: B7 0E        	lda	[<L241+dp_0],Y
  6229 00:195E: 48           	pha
  6230 00:195F: D4 09        	pei	<L242+fs_1+2
  6231 00:1961: D4 07        	pei	<L242+fs_1
  6232 00:1963: 22 xx xx xx  	jsl	~~move_window
  6233 00:1967: 85 05        	sta	<L242+res_1
  6234                        ;		if (res == FR_OK) {
  6235 00:1969: A5 05        	lda	<L242+res_1
  6236 00:196B: F0 03        	beq	L244
  6237 00:196D: 82 47 00     	brl	L10115
  6238                        L244:
  6239                        ;			memset(dp->dir, 0, SZDIRE);	
                    /* Clean the entry */
  6240 00:1970: F4 20 00     	pea	#<$20
  6241 00:1973: F4 00 00     	pea	#<$0
  6242 00:1976: A0 1E 00     	ldy	#$1e
  6243 00:1979: B7 0E        	lda	[<L241+dp_0],Y
  6244 00:197B: 48           	pha
  6245 00:197C: A0 1C 00     	ldy	#$1c
  6246 00:197F: B7 0E        	lda	[<L241+dp_0],Y
  6247 00:1981: 48           	pha
  6248 00:1982: 22 xx xx xx  	jsl	~~memset
  6249                        ;			memcpy(dp->dir + DIR_Name, dp->f
                    n, 11);	/* Put SFN */
  6250 00:1986: F4 0B 00     	pea	#<$b
  6251 00:1989: 18           	clc
  6252 00:198A: A9 20 00     	lda	#$20
  6253 00:198D: 65 0E        	adc	<L241+dp_0
  6254 00:198F: 85 01        	sta	<R0
  6255 00:1991: A9 00 00     	lda	#$0
  6256 00:1994: 65 10        	adc	<L241+dp_0+2
  6257 00:1996: 85 03        	sta	<R0+2
  6258 00:1998: D4 03        	pei	<R0+2
  6259 00:199A: D4 01        	pei	<R0
  6260 00:199C: A0 1E 00     	ldy	#$1e
  6261 00:199F: B7 0E        	lda	[<L241+dp_0],Y
  Thu May 20 2021 21:37                                                Page 131


  6262 00:19A1: 48           	pha
  6263 00:19A2: A0 1C 00     	ldy	#$1c
  6264 00:19A5: B7 0E        	lda	[<L241+dp_0],Y
  6265 00:19A7: 48           	pha
  6266 00:19A8: 22 xx xx xx  	jsl	~~memcpy
  6267                        ;#if FF_USE_LFN
  6268                        ;			dp->dir[DIR_NTres] = dp->fn[NSFL
                    AG] & (NS_BODY | NS_EXT);	/* Put NT flag */
  6269                        ;#endif
  6270                        ;			fs->wflag = 1;
  6271 00:19AC: E2 20        	sep	#$20
  6272                        	longa	off
  6273 00:19AE: A9 01        	lda	#$1
  6274 00:19B0: A0 03 00     	ldy	#$3
  6275 00:19B3: 97 07        	sta	[<L242+fs_1],Y
  6276 00:19B5: C2 20        	rep	#$20
  6277                        	longa	on
  6278                        ;		}
  6279                        ;	}
  6280                        L10115:
  6281                        ;
  6282                        ;	return res;
  6283                        L10114:
  6284 00:19B7: A5 05        	lda	<L242+res_1
  6285                        L245:
  6286 00:19B9: A8           	tay
  6287 00:19BA: A5 0C        	lda	<L241+2
  6288 00:19BC: 85 10        	sta	<L241+2+4
  6289 00:19BE: A5 0B        	lda	<L241+1
  6290 00:19C0: 85 0F        	sta	<L241+1+4
  6291 00:19C2: 2B           	pld
  6292 00:19C3: 3B           	tsc
  6293 00:19C4: 18           	clc
  6294 00:19C5: 69 0E 00     	adc	#L241+4
  6295 00:19C8: 1B           	tcs
  6296 00:19C9: 98           	tya
  6297 00:19CA: 6B           	rtl
  6298                        ;}
  6299             0000000A   L241	equ	10
  6300             00000005   L242	equ	5
  6301                        	ends
  6302                        	efunc
  6303                        ;
  6304                        ;#endif /* !FF_FS_READONLY */
  6305                        ;
  6306                        ;
  6307                        ;
  6308                        ;#if !FF_FS_READONLY && FF_FS_MINIMIZE == 0
  6309                        ;/*-----------------------------------------------
                    ------------------------*/
  6310                        ;/* Remove an object from the directory           
                                            */
  6311                        ;/*-----------------------------------------------
                    ------------------------*/
  6312                        ;
  6313                        ;static FRESULT dir_remove (	/* FR_OK:Succeed
                    ed, FR_DISK_ERR:A disk error */
  6314                        ;	DIR* dp					/* Direc
  Thu May 20 2021 21:37                                                Page 132


                    tory object pointing the entry to be removed */
  6315                        ;)
  6316                        ;{
  6317                        	code
  6318                        	func
  6319                        ~~dir_remove:
  6320                        	longa	on
  6321                        	longi	on
  6322 00:19CB: 3B           	tsc
  6323 00:19CC: 38           	sec
  6324 00:19CD: E9 0A 00     	sbc	#L246
  6325 00:19D0: 1B           	tcs
  6326 00:19D1: 0B           	phd
  6327 00:19D2: 5B           	tcd
  6328             00000004   dp_0	set	4
  6329                        ;	FRESULT res;
  6330                        ;	FATFS *fs = dp->obj.fs;
  6331                        ;#if FF_USE_LFN		/* LFN configuration */
  6332                        ;	DWORD last = dp->dptr;
  6333                        ;
  6334                        ;	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_
                    sdi(dp, dp->blk_ofs);	/* Goto top of the entry block i
                    f LFN is exist */
  6335                        ;	if (res == FR_OK) {
  6336                        ;		do {
  6337                        ;			res = move_window(fs, dp->sect);
  6338                        ;			if (res != FR_OK) break;
  6339                        ;			if (FF_FS_EXFAT && fs->fs_type =
                    = FS_EXFAT) {	/* On the exFAT volume */
  6340                        ;				dp->dir[XDIR_Type] &= 0x
                    7F;	/* Clear the entry InUse flag. */
  6341                        ;			} else {			
                    							/* On th
                    e FAT/FAT32 volume */
  6342                        ;				dp->dir[DIR_Name] = DDEM
                    ;	/* Mark the entry 'deleted'. */
  6343                        ;			}
  6344                        ;			fs->wflag = 1;
  6345                        ;			if (dp->dptr >= last) break;	
                    /* If reached last entry then all entries of the object has 
                    been deleted. */
  6346                        ;			res = dir_next(dp, 0);	/* Next 
                    entry */
  6347                        ;		} while (res == FR_OK);
  6348                        ;		if (res == FR_NO_FILE) res = FR_INT_ERR;
  6349                        ;	}
  6350                        ;#else			/* Non LFN configuration
                     */
  6351                        ;
  6352                        ;	res = move_window(fs, dp->sect);
  6353             00000000   res_1	set	0
  6354             00000002   fs_1	set	2
  6355 00:19D3: A7 0E        	lda	[<L246+dp_0]
  6356 00:19D5: 85 07        	sta	<L247+fs_1
  6357 00:19D7: A0 02 00     	ldy	#$2
  6358 00:19DA: B7 0E        	lda	[<L246+dp_0],Y
  6359 00:19DC: 85 09        	sta	<L247+fs_1+2
  6360 00:19DE: A0 1A 00     	ldy	#$1a
  Thu May 20 2021 21:37                                                Page 133


  6361 00:19E1: B7 0E        	lda	[<L246+dp_0],Y
  6362 00:19E3: 48           	pha
  6363 00:19E4: A0 18 00     	ldy	#$18
  6364 00:19E7: B7 0E        	lda	[<L246+dp_0],Y
  6365 00:19E9: 48           	pha
  6366 00:19EA: D4 09        	pei	<L247+fs_1+2
  6367 00:19EC: D4 07        	pei	<L247+fs_1
  6368 00:19EE: 22 xx xx xx  	jsl	~~move_window
  6369 00:19F2: 85 05        	sta	<L247+res_1
  6370                        ;	if (res == FR_OK) {
  6371 00:19F4: A5 05        	lda	<L247+res_1
  6372 00:19F6: F0 03        	beq	L248
  6373 00:19F8: 82 21 00     	brl	L10116
  6374                        L248:
  6375                        ;		dp->dir[DIR_Name] = DDEM;	/* Mark 
                    the entry 'deleted'.*/
  6376 00:19FB: A0 1C 00     	ldy	#$1c
  6377 00:19FE: B7 0E        	lda	[<L246+dp_0],Y
  6378 00:1A00: 85 01        	sta	<R0
  6379 00:1A02: A0 1E 00     	ldy	#$1e
  6380 00:1A05: B7 0E        	lda	[<L246+dp_0],Y
  6381 00:1A07: 85 03        	sta	<R0+2
  6382 00:1A09: E2 20        	sep	#$20
  6383                        	longa	off
  6384 00:1A0B: A9 E5        	lda	#$e5
  6385 00:1A0D: 87 01        	sta	[<R0]
  6386 00:1A0F: C2 20        	rep	#$20
  6387                        	longa	on
  6388                        ;		fs->wflag = 1;
  6389 00:1A11: E2 20        	sep	#$20
  6390                        	longa	off
  6391 00:1A13: A9 01        	lda	#$1
  6392 00:1A15: A0 03 00     	ldy	#$3
  6393 00:1A18: 97 07        	sta	[<L247+fs_1],Y
  6394 00:1A1A: C2 20        	rep	#$20
  6395                        	longa	on
  6396                        ;	}
  6397                        ;#endif
  6398                        ;
  6399                        ;	return res;
  6400                        L10116:
  6401 00:1A1C: A5 05        	lda	<L247+res_1
  6402                        L249:
  6403 00:1A1E: A8           	tay
  6404 00:1A1F: A5 0C        	lda	<L246+2
  6405 00:1A21: 85 10        	sta	<L246+2+4
  6406 00:1A23: A5 0B        	lda	<L246+1
  6407 00:1A25: 85 0F        	sta	<L246+1+4
  6408 00:1A27: 2B           	pld
  6409 00:1A28: 3B           	tsc
  6410 00:1A29: 18           	clc
  6411 00:1A2A: 69 0E 00     	adc	#L246+4
  6412 00:1A2D: 1B           	tcs
  6413 00:1A2E: 98           	tya
  6414 00:1A2F: 6B           	rtl
  6415                        ;}
  6416             0000000A   L246	equ	10
  6417             00000005   L247	equ	5
  Thu May 20 2021 21:37                                                Page 134


  6418                        	ends
  6419                        	efunc
  6420                        ;
  6421                        ;#endif /* !FF_FS_READONLY && FF_FS_MINIMIZE == 0 
                    */
  6422                        ;
  6423                        ;
  6424                        ;
  6425                        ;#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
  6426                        ;/*-----------------------------------------------
                    ------------------------*/
  6427                        ;/* Get file information from directory entry     
                                            */
  6428                        ;/*-----------------------------------------------
                    ------------------------*/
  6429                        ;
  6430                        ;static void get_fileinfo (
  6431                        ;	DIR* dp,			/* Pointer to th
                    e directory object */
  6432                        ;	FILINFO* fno		/* Pointer to the file i
                    nformation to be filled */
  6433                        ;)
  6434                        ;{
  6435                        	code
  6436                        	func
  6437                        ~~get_fileinfo:
  6438                        	longa	on
  6439                        	longi	on
  6440 00:1A30: 3B           	tsc
  6441 00:1A31: 38           	sec
  6442 00:1A32: E9 0D 00     	sbc	#L250
  6443 00:1A35: 1B           	tcs
  6444 00:1A36: 0B           	phd
  6445 00:1A37: 5B           	tcd
  6446             00000004   dp_0	set	4
  6447             00000008   fno_0	set	8
  6448                        ;	UINT si, di;
  6449                        ;#if FF_USE_LFN
  6450                        ;	BYTE lcf;
  6451                        ;	WCHAR wc, hs;
  6452                        ;	FATFS *fs = dp->obj.fs;
  6453                        ;	UINT nw;
  6454                        ;#else
  6455                        ;	TCHAR c;
  6456                        ;#endif
  6457                        ;
  6458                        ;
  6459                        ;	fno->fname[0] = 0;			/* Invai
                    date file info */
  6460             00000000   si_1	set	0
  6461             00000002   di_1	set	2
  6462             00000004   c_1	set	4
  6463 00:1A38: E2 20        	sep	#$20
  6464                        	longa	off
  6465 00:1A3A: A9 00        	lda	#$0
  6466 00:1A3C: A0 09 00     	ldy	#$9
  6467 00:1A3F: 97 15        	sta	[<L250+fno_0],Y
  6468 00:1A41: C2 20        	rep	#$20
  Thu May 20 2021 21:37                                                Page 135


  6469                        	longa	on
  6470                        ;	if (dp->sect == 0) return;	/* Exit if read 
                    pointer has reached end of directory */
  6471 00:1A43: A0 18 00     	ldy	#$18
  6472 00:1A46: B7 11        	lda	[<L250+dp_0],Y
  6473 00:1A48: A0 1A 00     	ldy	#$1a
  6474 00:1A4B: 17 11        	ora	[<L250+dp_0],Y
  6475 00:1A4D: F0 03        	beq	L252
  6476 00:1A4F: 82 10 00     	brl	L10117
  6477                        L252:
  6478                        L253:
  6479 00:1A52: A5 0F        	lda	<L250+2
  6480 00:1A54: 85 17        	sta	<L250+2+8
  6481 00:1A56: A5 0E        	lda	<L250+1
  6482 00:1A58: 85 16        	sta	<L250+1+8
  6483 00:1A5A: 2B           	pld
  6484 00:1A5B: 3B           	tsc
  6485 00:1A5C: 18           	clc
  6486 00:1A5D: 69 15 00     	adc	#L250+8
  6487 00:1A60: 1B           	tcs
  6488 00:1A61: 6B           	rtl
  6489                        ;
  6490                        ;#if FF_USE_LFN		/* LFN configuration */
  6491                        ;#if FF_FS_EXFAT
  6492                        ;	if (fs->fs_type == FS_EXFAT) {	/* exFAT volume 
                    */
  6493                        ;		UINT nc = 0;
  6494                        ;
  6495                        ;		si = SZDIRE * 2; di = 0;	/* 1st C
                    1 entry in the entry block */
  6496                        ;		hs = 0;
  6497                        ;		while (nc < fs->dirbuf[XDIR_NumName]) {
  6498                        ;			if (si >= MAXDIRB(FF_MAX_LFN)) {
                     di = 0; break; }	/* Truncated directory block? */
  6499                        ;			if ((si % SZDIRE) == 0) si += 2;
                    		/* Skip entry type field */
  6500                        ;			wc = ld_word(fs->dirbuf + si); s
                    i += 2; nc++;	/* Get a character */
  6501                        ;			if (hs == 0 && IsSurrogate(wc)) 
                    {		/* Is it a surrogate? */
  6502                        ;				hs = wc; continue;	
                    				/* Get low surrogate */
  6503                        ;			}
  6504                        ;			nw = put_utf((DWORD)hs << 16 | w
                    c, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in A
                    PI encoding */
  6505                        ;			if (nw == 0) { di = 0; break; }	
                    		/* Buffer overflow or wrong char? */
  6506                        ;			di += nw;
  6507                        ;			hs = 0;
  6508                        ;		}
  6509                        ;		if (hs != 0) di = 0;			
                    		/* Broken surrogate pair? */
  6510                        ;		if (di == 0) fno->fname[di++] = '?';	
                    /* Inaccessible object name? */
  6511                        ;		fno->fname[di] = 0;			
                    			/* Terminate the name */
  6512                        ;		fno->altname[0] = 0;			
  Thu May 20 2021 21:37                                                Page 136


                    		/* exFAT does not support SFN */
  6513                        ;
  6514                        ;		fno->fattrib = fs->dirbuf[XDIR_Attr] & A
                    M_MASKX;		/* Attribute */
  6515                        ;		fno->fsize = (fno->fattrib & AM_DIR) ? 0
                     : ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
  6516                        ;		fno->ftime = ld_word(fs->dirbuf + XDIR_M
                    odTime + 0);	/* Time */
  6517                        ;		fno->fdate = ld_word(fs->dirbuf + XDIR_M
                    odTime + 2);	/* Date */
  6518                        ;		return;
  6519                        ;	} else
  6520                        ;#endif
  6521                        ;	{	/* FAT/FAT32 volume */
  6522                        ;		if (dp->blk_ofs != 0xFFFFFFFF) {	
                    /* Get LFN if available */
  6523                        ;			si = di = 0;
  6524                        ;			hs = 0;
  6525                        ;			while (fs->lfnbuf[si] != 0) {
  6526                        ;				wc = fs->lfnbuf[si++];	
                    	/* Get an LFN character (UTF-16) */
  6527                        ;				if (hs == 0 && IsSurroga
                    te(wc)) {	/* Is it a surrogate? */
  6528                        ;					hs = wc; continu
                    e;		/* Get low surrogate */
  6529                        ;				}
  6530                        ;				nw = put_utf((DWORD)hs <
                    < 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store
                     it in API encoding */
  6531                        ;				if (nw == 0) { di = 0; b
                    reak; }	/* Buffer overflow or wrong char? */
  6532                        ;				di += nw;
  6533                        ;				hs = 0;
  6534                        ;			}
  6535                        ;			if (hs != 0) di = 0;	/* Broke
                    n surrogate pair? */
  6536                        ;			fno->fname[di] = 0;		
                    /* Terminate the LFN (null string means LFN is invalid) */
  6537                        ;		}
  6538                        ;	}
  6539                        ;
  6540                        ;	si = di = 0;
  6541                        ;	while (si < 11) {		/* Get SFN from 
                    SFN entry */
  6542                        ;		wc = dp->dir[si++];			
                    /* Get a char */
  6543                        ;		if (wc == ' ') continue;	/* Skip 
                    padding spaces */
  6544                        ;		if (wc == RDDEM) wc = DDEM;	/* Resto
                    re replaced DDEM character */
  6545                        ;		if (si == 9 && di < FF_SFN_BUF) fno->alt
                    name[di++] = '.';	/* Insert a . if extension is exist */
  6546                        ;#if FF_LFN_UNICODE >= 1	/* Unicode output */
  6547                        ;		if (dbc_1st((BYTE)wc) && si != 8 && si !
                    = 11 && dbc_2nd(dp->dir[si])) {	/* Make a DBC if needed 
                    */
  6548                        ;			wc = wc << 8 | dp->dir[si++];
  6549                        ;		}
  Thu May 20 2021 21:37                                                Page 137


  6550                        ;		wc = ff_oem2uni(wc, CODEPAGE);		
                    /* ANSI/OEM -> Unicode */
  6551                        ;		if (wc == 0) { di = 0; break; }		
                    /* Wrong char in the current code page? */
  6552                        ;		nw = put_utf(wc, &fno->altname[di], FF_S
                    FN_BUF - di);	/* Store it in API encoding */
  6553                        ;		if (nw == 0) { di = 0; break; }		
                    /* Buffer overflow? */
  6554                        ;		di += nw;
  6555                        ;#else					/* ANSI/
                    OEM output */
  6556                        ;		fno->altname[di++] = (TCHAR)wc;	/* Store
                     it without any conversion */
  6557                        ;#endif
  6558                        ;	}
  6559                        ;	fno->altname[di] = 0;	/* Terminate the SFN  (n
                    ull string means SFN is invalid) */
  6560                        ;
  6561                        ;	if (fno->fname[0] == 0) {	/* If LFN is inv
                    alid, altname[] needs to be copied to fname[] */
  6562                        ;		if (di == 0) {	/* If LFN and SFN both a
                    re invalid, this object is inaccesible */
  6563                        ;			fno->fname[di++] = '?';
  6564                        ;		} else {
  6565                        ;			for (si = di = 0, lcf = NS_BODY;
                     fno->altname[si]; si++, di++) {	/* Copy altname[] to fna
                    me[] with case information */
  6566                        ;				wc = (WCHAR)fno->altname
                    [si];
  6567                        ;				if (wc == '.') lcf = NS_
                    EXT;
  6568                        ;				if (IsUpper(wc) && (dp->
                    dir[DIR_NTres] & lcf)) wc += 0x20;
  6569                        ;				fno->fname[di] = (TCHAR)
                    wc;
  6570                        ;			}
  6571                        ;		}
  6572                        ;		fno->fname[di] = 0;	/* Terminate the
                     LFN */
  6573                        ;		if (!dp->dir[DIR_NTres]) fno->altname[0]
                     = 0;	/* Altname is not needed if neither LFN nor case
                     info is exist. */
  6574                        ;	}
  6575                        ;
  6576                        ;#else	/* Non-LFN configuration */
  6577                        ;	si = di = 0;
  6578                        L10117:
  6579 00:1A62: 64 0B        	stz	<L251+di_1
  6580 00:1A64: 64 09        	stz	<L251+si_1
  6581                        ;	while (si < 11) {		/* Copy name bod
                    y and extension */
  6582                        L10118:
  6583 00:1A66: A5 09        	lda	<L251+si_1
  6584 00:1A68: C9 0B 00     	cmp	#<$b
  6585 00:1A6B: 90 03        	bcc	L254
  6586 00:1A6D: 82 71 00     	brl	L10119
  6587                        L254:
  6588                        ;		c = (TCHAR)dp->dir[si++];
  Thu May 20 2021 21:37                                                Page 138


  6589 00:1A70: A0 1C 00     	ldy	#$1c
  6590 00:1A73: B7 11        	lda	[<L250+dp_0],Y
  6591 00:1A75: 85 01        	sta	<R0
  6592 00:1A77: A0 1E 00     	ldy	#$1e
  6593 00:1A7A: B7 11        	lda	[<L250+dp_0],Y
  6594 00:1A7C: 85 03        	sta	<R0+2
  6595 00:1A7E: E2 20        	sep	#$20
  6596                        	longa	off
  6597 00:1A80: A4 09        	ldy	<L251+si_1
  6598 00:1A82: B7 01        	lda	[<R0],Y
  6599 00:1A84: 85 0D        	sta	<L251+c_1
  6600 00:1A86: C2 20        	rep	#$20
  6601                        	longa	on
  6602 00:1A88: E6 09        	inc	<L251+si_1
  6603                        ;		if (c == ' ') continue;		/* Skip 
                    padding spaces */
  6604 00:1A8A: E2 20        	sep	#$20
  6605                        	longa	off
  6606 00:1A8C: A5 0D        	lda	<L251+c_1
  6607 00:1A8E: C9 20        	cmp	#<$20
  6608 00:1A90: C2 20        	rep	#$20
  6609                        	longa	on
  6610 00:1A92: D0 03        	bne	L255
  6611 00:1A94: 82 CF FF     	brl	L10118
  6612                        L255:
  6613                        ;		if (c == RDDEM) c = DDEM;	/* Resto
                    re replaced DDEM character */
  6614 00:1A97: E2 20        	sep	#$20
  6615                        	longa	off
  6616 00:1A99: A5 0D        	lda	<L251+c_1
  6617 00:1A9B: C9 05        	cmp	#<$5
  6618 00:1A9D: C2 20        	rep	#$20
  6619                        	longa	on
  6620 00:1A9F: F0 03        	beq	L256
  6621 00:1AA1: 82 08 00     	brl	L10120
  6622                        L256:
  6623 00:1AA4: E2 20        	sep	#$20
  6624                        	longa	off
  6625 00:1AA6: A9 E5        	lda	#$e5
  6626 00:1AA8: 85 0D        	sta	<L251+c_1
  6627 00:1AAA: C2 20        	rep	#$20
  6628                        	longa	on
  6629                        ;		if (si == 9) fno->fname[di++] = '.';/* I
                    nsert a . if extension is exist */
  6630                        L10120:
  6631 00:1AAC: A5 09        	lda	<L251+si_1
  6632 00:1AAE: C9 09 00     	cmp	#<$9
  6633 00:1AB1: F0 03        	beq	L257
  6634 00:1AB3: 82 14 00     	brl	L10121
  6635                        L257:
  6636 00:1AB6: 18           	clc
  6637 00:1AB7: A9 09 00     	lda	#$9
  6638 00:1ABA: 65 0B        	adc	<L251+di_1
  6639 00:1ABC: 85 01        	sta	<R0
  6640 00:1ABE: E2 20        	sep	#$20
  6641                        	longa	off
  6642 00:1AC0: A9 2E        	lda	#$2e
  6643 00:1AC2: A4 01        	ldy	<R0
  Thu May 20 2021 21:37                                                Page 139


  6644 00:1AC4: 97 15        	sta	[<L250+fno_0],Y
  6645 00:1AC6: C2 20        	rep	#$20
  6646                        	longa	on
  6647 00:1AC8: E6 0B        	inc	<L251+di_1
  6648                        ;		fno->fname[di++] = c;
  6649                        L10121:
  6650 00:1ACA: 18           	clc
  6651 00:1ACB: A9 09 00     	lda	#$9
  6652 00:1ACE: 65 0B        	adc	<L251+di_1
  6653 00:1AD0: 85 01        	sta	<R0
  6654 00:1AD2: E2 20        	sep	#$20
  6655                        	longa	off
  6656 00:1AD4: A5 0D        	lda	<L251+c_1
  6657 00:1AD6: A4 01        	ldy	<R0
  6658 00:1AD8: 97 15        	sta	[<L250+fno_0],Y
  6659 00:1ADA: C2 20        	rep	#$20
  6660                        	longa	on
  6661 00:1ADC: E6 0B        	inc	<L251+di_1
  6662                        ;	}
  6663 00:1ADE: 82 85 FF     	brl	L10118
  6664                        L10119:
  6665                        ;	fno->fname[di] = 0;		/* Terminate the
                     SFN */
  6666 00:1AE1: 18           	clc
  6667 00:1AE2: A9 09 00     	lda	#$9
  6668 00:1AE5: 65 0B        	adc	<L251+di_1
  6669 00:1AE7: 85 01        	sta	<R0
  6670 00:1AE9: E2 20        	sep	#$20
  6671                        	longa	off
  6672 00:1AEB: A9 00        	lda	#$0
  6673 00:1AED: A4 01        	ldy	<R0
  6674 00:1AEF: 97 15        	sta	[<L250+fno_0],Y
  6675 00:1AF1: C2 20        	rep	#$20
  6676                        	longa	on
  6677                        ;#endif
  6678                        ;
  6679                        ;	fno->fattrib = dp->dir[DIR_Attr] & AM_MASK;	
                    		/* Attribute */
  6680 00:1AF3: A0 1C 00     	ldy	#$1c
  6681 00:1AF6: B7 11        	lda	[<L250+dp_0],Y
  6682 00:1AF8: 85 01        	sta	<R0
  6683 00:1AFA: A0 1E 00     	ldy	#$1e
  6684 00:1AFD: B7 11        	lda	[<L250+dp_0],Y
  6685 00:1AFF: 85 03        	sta	<R0+2
  6686 00:1B01: E2 20        	sep	#$20
  6687                        	longa	off
  6688 00:1B03: A0 0B 00     	ldy	#$b
  6689 00:1B06: B7 01        	lda	[<R0],Y
  6690 00:1B08: 29 3F        	and	#<$3f
  6691 00:1B0A: C2 20        	rep	#$20
  6692                        	longa	on
  6693 00:1B0C: E2 20        	sep	#$20
  6694                        	longa	off
  6695 00:1B0E: A0 08 00     	ldy	#$8
  6696 00:1B11: 97 15        	sta	[<L250+fno_0],Y
  6697 00:1B13: C2 20        	rep	#$20
  6698                        	longa	on
  6699                        ;	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	
  Thu May 20 2021 21:37                                                Page 140


                    	/* Size */
  6700 00:1B15: 18           	clc
  6701 00:1B16: A9 1C 00     	lda	#$1c
  6702 00:1B19: A0 1C 00     	ldy	#$1c
  6703 00:1B1C: 77 11        	adc	[<L250+dp_0],Y
  6704 00:1B1E: 85 01        	sta	<R0
  6705 00:1B20: A9 00 00     	lda	#$0
  6706 00:1B23: A0 1E 00     	ldy	#$1e
  6707 00:1B26: 77 11        	adc	[<L250+dp_0],Y
  6708 00:1B28: 85 03        	sta	<R0+2
  6709 00:1B2A: D4 03        	pei	<R0+2
  6710 00:1B2C: D4 01        	pei	<R0
  6711 00:1B2E: 22 xx xx xx  	jsl	~~ld_dword
  6712 00:1B32: 85 05        	sta	<R1
  6713 00:1B34: 86 07        	stx	<R1+2
  6714 00:1B36: A5 05        	lda	<R1
  6715 00:1B38: 87 15        	sta	[<L250+fno_0]
  6716 00:1B3A: A5 07        	lda	<R1+2
  6717 00:1B3C: A0 02 00     	ldy	#$2
  6718 00:1B3F: 97 15        	sta	[<L250+fno_0],Y
  6719                        ;	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);
                    	/* Time */
  6720 00:1B41: 18           	clc
  6721 00:1B42: A9 16 00     	lda	#$16
  6722 00:1B45: A0 1C 00     	ldy	#$1c
  6723 00:1B48: 77 11        	adc	[<L250+dp_0],Y
  6724 00:1B4A: 85 01        	sta	<R0
  6725 00:1B4C: A9 00 00     	lda	#$0
  6726 00:1B4F: A0 1E 00     	ldy	#$1e
  6727 00:1B52: 77 11        	adc	[<L250+dp_0],Y
  6728 00:1B54: 85 03        	sta	<R0+2
  6729 00:1B56: D4 03        	pei	<R0+2
  6730 00:1B58: D4 01        	pei	<R0
  6731 00:1B5A: 22 xx xx xx  	jsl	~~ld_word
  6732 00:1B5E: A0 06 00     	ldy	#$6
  6733 00:1B61: 97 15        	sta	[<L250+fno_0],Y
  6734                        ;	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);
                    	/* Date */
  6735 00:1B63: 18           	clc
  6736 00:1B64: A9 18 00     	lda	#$18
  6737 00:1B67: A0 1C 00     	ldy	#$1c
  6738 00:1B6A: 77 11        	adc	[<L250+dp_0],Y
  6739 00:1B6C: 85 01        	sta	<R0
  6740 00:1B6E: A9 00 00     	lda	#$0
  6741 00:1B71: A0 1E 00     	ldy	#$1e
  6742 00:1B74: 77 11        	adc	[<L250+dp_0],Y
  6743 00:1B76: 85 03        	sta	<R0+2
  6744 00:1B78: D4 03        	pei	<R0+2
  6745 00:1B7A: D4 01        	pei	<R0
  6746 00:1B7C: 22 xx xx xx  	jsl	~~ld_word
  6747 00:1B80: A0 04 00     	ldy	#$4
  6748 00:1B83: 97 15        	sta	[<L250+fno_0],Y
  6749                        ;}
  6750 00:1B85: 82 CA FE     	brl	L253
  6751             0000000D   L250	equ	13
  6752             00000009   L251	equ	9
  6753                        	ends
  6754                        	efunc
  Thu May 20 2021 21:37                                                Page 141


  6755                        ;
  6756                        ;#endif /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
                     */
  6757                        ;
  6758                        ;
  6759                        ;
  6760                        ;#if FF_USE_FIND && FF_FS_MINIMIZE <= 1
  6761                        ;/*-----------------------------------------------
                    ------------------------*/
  6762                        ;/* Pattern matching                              
                                            */
  6763                        ;/*-----------------------------------------------
                    ------------------------*/
  6764                        ;
  6765                        ;#define FIND_RECURS	4	/* Maximum numbe
                    r of wildcard terms in the pattern to limit recursion */
  6766                        ;
  6767                        ;
  6768                        ;static DWORD get_achar (	/* Get a character and a
                    dvance ptr */
  6769                        ;	const TCHAR** ptr		/* Pointer to po
                    inter to the ANSI/OEM or Unicode string */
  6770                        ;)
  6771                        ;{
  6772                        ;	DWORD chr;
  6773                        ;
  6774                        ;
  6775                        ;#if FF_USE_LFN && FF_LFN_UNICODE >= 1	/* Unico
                    de input */
  6776                        ;	chr = tchar2uni(ptr);
  6777                        ;	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong
                     UTF encoding is recognized as end of the string */
  6778                        ;	chr = ff_wtoupper(chr);
  6779                        ;
  6780                        ;#else						
                    			/* ANSI/OEM input */
  6781                        ;	chr = (BYTE)*(*ptr)++;				
                    /* Get a byte */
  6782                        ;	if (IsLower(chr)) chr -= 0x20;		/* To up
                    per ASCII char */
  6783                        ;#if FF_CODE_PAGE == 0
  6784                        ;	if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80
                    ];	/* To upper SBCS extended char */
  6785                        ;#elif FF_CODE_PAGE < 900
  6786                        ;	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	
                    /* To upper SBCS extended char */
  6787                        ;#endif
  6788                        ;#if FF_CODE_PAGE == 0 || FF_CODE_PAGE >= 900
  6789                        ;	if (dbc_1st((BYTE)chr)) {	/* Get DBC 2nd b
                    yte if needed */
  6790                        ;		chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | 
                    (BYTE)*(*ptr)++ : 0;
  6791                        ;	}
  6792                        ;#endif
  6793                        ;
  6794                        ;#endif
  6795                        ;	return chr;
  6796                        ;}
  Thu May 20 2021 21:37                                                Page 142


  6797                        ;
  6798                        ;
  6799                        ;static int pattern_match (	/* 0:mismatched,
                     1:matched */
  6800                        ;	const TCHAR* pat,	/* Matching pattern */
  6801                        ;	const TCHAR* nam,	/* String to be tested *
                    /
  6802                        ;	UINT skip,			/* Number of pre
                    -skip chars (number of ?s, b8:infinite (* specified)) */
  6803                        ;	UINT recur			/* Recursion cou
                    nt */
  6804                        ;)
  6805                        ;{
  6806                        ;	const TCHAR *pptr, *nptr;
  6807                        ;	DWORD pchr, nchr;
  6808                        ;	UINT sk;
  6809                        ;
  6810                        ;
  6811                        ;	while ((skip & 0xFF) != 0) {		/* Pre-s
                    kip name chars */
  6812                        ;		if (!get_achar(&nam)) return 0;	/* Branc
                    h mismatched if less name chars */
  6813                        ;		skip--;
  6814                        ;	}
  6815                        ;	if (*pat == 0 && skip) return 1;	/* Match
                    ed? (short circuit) */
  6816                        ;
  6817                        ;	do {
  6818                        ;		pptr = pat; nptr = nam;			
                    /* Top of pattern and name to match */
  6819                        ;		for (;;) {
  6820                        ;			if (*pptr == '?' || *pptr == '*'
                    ) {	/* Wildcard term? */
  6821                        ;				if (recur == 0) return 0
                    ;	/* Too many wildcard terms? */
  6822                        ;				sk = 0;
  6823                        ;				do {	/* Analyze the w
                    ildcard term */
  6824                        ;					if (*pptr++ == '
                    ?') sk++; else sk |= 0x100;
  6825                        ;				} while (*pptr == '?' ||
                     *pptr == '*');
  6826                        ;				if (pattern_match(pptr, 
                    nptr, sk, recur - 1)) return 1;	/* Test new branch (recu
                    rsive call) */
  6827                        ;				nchr = *nptr; break;	
                    /* Branch mismatched */
  6828                        ;			}
  6829                        ;			pchr = get_achar(&pptr);	
                    /* Get a pattern char */
  6830                        ;			nchr = get_achar(&nptr);	
                    /* Get a name char */
  6831                        ;			if (pchr != nchr) break;	
                    /* Branch mismatched? */
  6832                        ;			if (pchr == 0) return 1;	
                    /* Branch matched? (matched at end of both strings) */
  6833                        ;		}
  6834                        ;		get_achar(&nam);			
  Thu May 20 2021 21:37                                                Page 143


                    /* nam++ */
  6835                        ;	} while (skip && nchr);		/* Retry until e
                    nd of name if infinite search is specified */
  6836                        ;
  6837                        ;	return 0;
  6838                        ;}
  6839                        ;
  6840                        ;#endif /* FF_USE_FIND && FF_FS_MINIMIZE <= 1 */
  6841                        ;
  6842                        ;
  6843                        ;
  6844                        ;/*-----------------------------------------------
                    ------------------------*/
  6845                        ;/* Pick a top segment and create the object name 
                    in directory form       */
  6846                        ;/*-----------------------------------------------
                    ------------------------*/
  6847                        ;
  6848                        ;static FRESULT create_name (	/* FR_OK: succes
                    sful, FR_INVALID_NAME: could not create */
  6849                        ;	DIR* dp,					
                    /* Pointer to the directory object */
  6850                        ;	const TCHAR** path			/* Point
                    er to pointer to the segment in the path string */
  6851                        ;)
  6852                        ;{
  6853                        	code
  6854                        	func
  6855                        ~~create_name:
  6856                        	longa	on
  6857                        	longi	on
  6858 00:1B88: 3B           	tsc
  6859 00:1B89: 38           	sec
  6860 00:1B8A: E9 18 00     	sbc	#L258
  6861 00:1B8D: 1B           	tcs
  6862 00:1B8E: 0B           	phd
  6863 00:1B8F: 5B           	tcd
  6864             00000004   dp_0	set	4
  6865             00000008   path_0	set	8
  6866                        ;#if FF_USE_LFN		/* LFN configuration */
  6867                        ;	BYTE b, cf;
  6868                        ;	WCHAR wc, *lfn;
  6869                        ;	DWORD uc;
  6870                        ;	UINT i, ni, si, di;
  6871                        ;	const TCHAR *p;
  6872                        ;
  6873                        ;
  6874                        ;	/* Create LFN into LFN working buffer */
  6875                        ;	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
  6876                        ;	for (;;) {
  6877                        ;		uc = tchar2uni(&p);			
                    /* Get a character */
  6878                        ;		if (uc == 0xFFFFFFFF) return FR_INVALID_
                    NAME;		/* Invalid code or UTF decode error */
  6879                        ;		if (uc >= 0x10000) lfn[di++] = (WCHAR)(u
                    c >> 16);	/* Store high surrogate if needed */
  6880                        ;		wc = (WCHAR)uc;
  6881                        ;		if (wc < ' ' || IsSeparator(wc)) break;	
  Thu May 20 2021 21:37                                                Page 144


                    /* Break if end of the path or a separator is found */
  6882                        ;		if (wc < 0x80 && strchr("*:<>|\"\?\x7F",
                     (int)wc)) return FR_INVALID_NAME;	/* Reject illegal charac
                    ters for LFN */
  6883                        ;		if (di >= FF_MAX_LFN) return FR_INVALID_
                    NAME;	/* Reject too long name */
  6884                        ;		lfn[di++] = wc;				
                    /* Store the Unicode character */
  6885                        ;	}
  6886                        ;	if (wc < ' ') {				/* Stopp
                    ed at end of the path? */
  6887                        ;		cf = NS_LAST;			/* Last 
                    segment */
  6888                        ;	} else {					
                    /* Stopped at a separator */
  6889                        ;		while (IsSeparator(*p)) p++;	/* Skip 
                    duplicated separators if exist */
  6890                        ;		cf = 0;					
                    /* Next segment may follow */
  6891                        ;		if (IsTerminator(*p)) cf = NS_LAST;	
                    /* Ignore terminating separator */
  6892                        ;	}
  6893                        ;	*path = p;					
                    /* Return pointer to the next segment */
  6894                        ;
  6895                        ;#if FF_FS_RPATH != 0
  6896                        ;	if ((di == 1 && lfn[di - 1] == '.') ||
  6897                        ;		(di == 2 && lfn[di - 1] == '.' && lfn[di
                     - 2] == '.')) {	/* Is this segment a dot name? */
  6898                        ;		lfn[di] = 0;
  6899                        ;		for (i = 0; i < 11; i++) {	/* Creat
                    e dot name for SFN entry */
  6900                        ;			dp->fn[i] = (i < di) ? '.' : ' '
                    ;
  6901                        ;		}
  6902                        ;		dp->fn[i] = cf | NS_DOT;	/* This 
                    is a dot entry */
  6903                        ;		return FR_OK;
  6904                        ;	}
  6905                        ;#endif
  6906                        ;	while (di) {					
                    /* Snip off trailing spaces and dots if exist */
  6907                        ;		wc = lfn[di - 1];
  6908                        ;		if (wc != ' ' && wc != '.') break;
  6909                        ;		di--;
  6910                        ;	}
  6911                        ;	lfn[di] = 0;					
                    		/* LFN is created into the working buffer */
  6912                        ;	if (di == 0) return FR_INVALID_NAME;	/* Rejec
                    t null name */
  6913                        ;
  6914                        ;	/* Create SFN in directory form */
  6915                        ;	for (si = 0; lfn[si] == ' '; si++) ;	/* Remov
                    e leading spaces */
  6916                        ;	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS
                    _LFN;	/* Is there any leading space or dot? */
  6917                        ;	while (di > 0 && lfn[di - 1] != '.') di--;	
                    /* Find last dot (di<=si: no extension) */
  Thu May 20 2021 21:37                                                Page 145


  6918                        ;
  6919                        ;	memset(dp->fn, ' ', 11);
  6920                        ;	i = b = 0; ni = 8;
  6921                        ;	for (;;) {
  6922                        ;		wc = lfn[si++];				
                    	/* Get an LFN character */
  6923                        ;		if (wc == 0) break;			
                    	/* Break on end of the LFN */
  6924                        ;		if (wc == ' ' || (wc == '.' && si != di)
                    ) {	/* Remove embedded spaces and dots */
  6925                        ;			cf |= NS_LOSS | NS_LFN;
  6926                        ;			continue;
  6927                        ;		}
  6928                        ;
  6929                        ;		if (i >= ni || si == di) {		
                    /* End of field? */
  6930                        ;			if (ni == 11) {			
                    	/* Name extension overflow? */
  6931                        ;				cf |= NS_LOSS | NS_LFN;
  6932                        ;				break;
  6933                        ;			}
  6934                        ;			if (si != di) cf |= NS_LOSS | NS
                    _LFN;	/* Name body overflow? */
  6935                        ;			if (si > di) break;		
                    				/* No name extension? */
  6936                        ;			si = di; i = 8; ni = 11; b <<= 2
                    ;		/* Enter name extension */
  6937                        ;			continue;
  6938                        ;		}
  6939                        ;
  6940                        ;		if (wc >= 0x80) {	/* Is this an ex
                    tended character? */
  6941                        ;			cf |= NS_LFN;	/* LFN entry nee
                    ds to be created */
  6942                        ;#if FF_CODE_PAGE == 0
  6943                        ;			if (ExCvt) {	/* In SBCS cfg *
                    /
  6944                        ;				wc = ff_uni2oem(wc, CODE
                    PAGE);			/* Unicode ==> ANSI/OEM code */
  6945                        ;				if (wc & 0x80) wc = ExCv
                    t[wc & 0x7F];	/* Convert extended character to upper (
                    SBCS) */
  6946                        ;			} else {		/* In DB
                    CS cfg */
  6947                        ;				wc = ff_uni2oem(ff_wtoup
                    per(wc), CODEPAGE);	/* Unicode ==> Up-convert ==> ANSI/OEM c
                    ode */
  6948                        ;			}
  6949                        ;#elif FF_CODE_PAGE < 900	/* In SBCS cfg */
  6950                        ;			wc = ff_uni2oem(wc, CODEPAGE);	
                    		/* Unicode ==> ANSI/OEM code */
  6951                        ;			if (wc & 0x80) wc = ExCvt[wc & 0
                    x7F];	/* Convert extended character to upper (SBCS) */
  6952                        ;#else						
                    /* In DBCS cfg */
  6953                        ;			wc = ff_uni2oem(ff_wtoupper(wc),
                     CODEPAGE);	/* Unicode ==> Up-convert ==> ANSI/OEM code */
  6954                        ;#endif
  Thu May 20 2021 21:37                                                Page 146


  6955                        ;		}
  6956                        ;
  6957                        ;		if (wc >= 0x100) {			
                    	/* Is this a DBC? */
  6958                        ;			if (i >= ni - 1) {		
                    	/* Field overflow? */
  6959                        ;				cf |= NS_LOSS | NS_LFN;
  6960                        ;				i = ni; continue;	
                    	/* Next field */
  6961                        ;			}
  6962                        ;			dp->fn[i++] = (BYTE)(wc >> 8);	
                    /* Put 1st byte */
  6963                        ;		} else {				
                    		/* SBC */
  6964                        ;			if (wc == 0 || strchr("+,;=[]", 
                    (int)wc)) {	/* Replace illegal characters for SFN */
  6965                        ;				wc = '_'; cf |= NS_LOSS 
                    | NS_LFN;/* Lossy conversion */
  6966                        ;			} else {
  6967                        ;				if (IsUpper(wc)) {	
                    	/* ASCII upper case? */
  6968                        ;					b |= 2;
  6969                        ;				}
  6970                        ;				if (IsLower(wc)) {	
                    	/* ASCII lower case? */
  6971                        ;					b |= 1; wc -= 0x
                    20;
  6972                        ;				}
  6973                        ;			}
  6974                        ;		}
  6975                        ;		dp->fn[i++] = (BYTE)wc;
  6976                        ;	}
  6977                        ;
  6978                        ;	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	
                    /* If the first character collides with DDEM, replace it wit
                    h RDDEM */
  6979                        ;
  6980                        ;	if (ni == 8) b <<= 2;				
                    /* Shift capital flags if no extension */
  6981                        ;	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf
                     |= NS_LFN;	/* LFN entry needs to be created if composite ca
                    pitals */
  6982                        ;	if (!(cf & NS_LFN)) {				
                    /* When LFN is in 8.3 format without extended character, NT 
                    flags are created */
  6983                        ;		if (b & 0x01) cf |= NS_EXT;		
                    /* NT flag (Extension has small capital letters only) */
  6984                        ;		if (b & 0x04) cf |= NS_BODY;	/* NT fl
                    ag (Body has small capital letters only) */
  6985                        ;	}
  6986                        ;
  6987                        ;	dp->fn[NSFLAG] = cf;	/* SFN is created into d
                    p->fn[] */
  6988                        ;
  6989                        ;	return FR_OK;
  6990                        ;
  6991                        ;
  6992                        ;#else	/* FF_USE_LFN : Non-LFN configuration */
  Thu May 20 2021 21:37                                                Page 147


  6993                        ;	BYTE c, d, *sfn;
  6994                        ;	UINT ni, si, i;
  6995                        ;	const char *p;
  6996                        ;
  6997                        ;	/* Create file name in directory form */
  6998                        ;	p = *path; sfn = dp->fn;
  6999             00000000   c_1	set	0
  7000             00000001   d_1	set	1
  7001             00000002   sfn_1	set	2
  7002             00000006   ni_1	set	6
  7003             00000008   si_1	set	8
  7004             0000000A   i_1	set	10
  7005             0000000C   p_1	set	12
  7006 00:1B90: A7 20        	lda	[<L258+path_0]
  7007 00:1B92: 85 15        	sta	<L259+p_1
  7008 00:1B94: A0 02 00     	ldy	#$2
  7009 00:1B97: B7 20        	lda	[<L258+path_0],Y
  7010 00:1B99: 85 17        	sta	<L259+p_1+2
  7011 00:1B9B: 18           	clc
  7012 00:1B9C: A9 20 00     	lda	#$20
  7013 00:1B9F: 65 1C        	adc	<L258+dp_0
  7014 00:1BA1: 85 0B        	sta	<L259+sfn_1
  7015 00:1BA3: A9 00 00     	lda	#$0
  7016 00:1BA6: 65 1E        	adc	<L258+dp_0+2
  7017 00:1BA8: 85 0D        	sta	<L259+sfn_1+2
  7018                        ;	memset(sfn, ' ', 11);
  7019 00:1BAA: F4 0B 00     	pea	#<$b
  7020 00:1BAD: F4 20 00     	pea	#<$20
  7021 00:1BB0: D4 0D        	pei	<L259+sfn_1+2
  7022 00:1BB2: D4 0B        	pei	<L259+sfn_1
  7023 00:1BB4: 22 xx xx xx  	jsl	~~memset
  7024                        ;	si = i = 0; ni = 8;
  7025 00:1BB8: 64 13        	stz	<L259+i_1
  7026 00:1BBA: 64 11        	stz	<L259+si_1
  7027 00:1BBC: A9 08 00     	lda	#$8
  7028 00:1BBF: 85 0F        	sta	<L259+ni_1
  7029                        ;#if FF_FS_RPATH != 0
  7030                        ;	if (p[si] == '.') { /* Is this a dot entry? */
  7031                        ;		for (;;) {
  7032                        ;			c = (BYTE)p[si++];
  7033                        ;			if (c != '.' || si >= 3) break;
  7034                        ;			sfn[i++] = c;
  7035                        ;		}
  7036                        ;		if (!IsSeparator(c) && c > ' ') return F
                    R_INVALID_NAME;
  7037                        ;		*path = p + si;				
                    	/* Return pointer to the next segment */
  7038                        ;		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_
                    DOT : NS_DOT;	/* Set last segment flag if end of the p
                    ath */
  7039                        ;		return FR_OK;
  7040                        ;	}
  7041                        ;#endif
  7042                        ;	for (;;) {
  7043                        L10122:
  7044                        ;		c = (BYTE)p[si++];			
                    	/* Get a byte */
  7045 00:1BC1: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 148


  7046                        	longa	off
  7047 00:1BC3: A4 11        	ldy	<L259+si_1
  7048 00:1BC5: B7 15        	lda	[<L259+p_1],Y
  7049 00:1BC7: 85 09        	sta	<L259+c_1
  7050 00:1BC9: C2 20        	rep	#$20
  7051                        	longa	on
  7052 00:1BCB: E6 11        	inc	<L259+si_1
  7053                        ;		if (c <= ' ') break; 			
                    /* Break if end of the path name */
  7054 00:1BCD: E2 20        	sep	#$20
  7055                        	longa	off
  7056 00:1BCF: A9 20        	lda	#$20
  7057 00:1BD1: C5 09        	cmp	<L259+c_1
  7058 00:1BD3: C2 20        	rep	#$20
  7059                        	longa	on
  7060 00:1BD5: 90 03        	bcc	L260
  7061 00:1BD7: 82 6C 01     	brl	L10123
  7062                        L260:
  7063                        ;		if (IsSeparator(c)) {			
                    /* Break if a separator is found */
  7064 00:1BDA: E2 20        	sep	#$20
  7065                        	longa	off
  7066 00:1BDC: A5 09        	lda	<L259+c_1
  7067 00:1BDE: C9 2F        	cmp	#<$2f
  7068 00:1BE0: C2 20        	rep	#$20
  7069                        	longa	on
  7070 00:1BE2: D0 03        	bne	L262
  7071 00:1BE4: 82 0D 00     	brl	L261
  7072                        L262:
  7073 00:1BE7: E2 20        	sep	#$20
  7074                        	longa	off
  7075 00:1BE9: A5 09        	lda	<L259+c_1
  7076 00:1BEB: C9 5C        	cmp	#<$5c
  7077 00:1BED: C2 20        	rep	#$20
  7078                        	longa	on
  7079 00:1BEF: F0 03        	beq	L263
  7080 00:1BF1: 82 26 00     	brl	L10124
  7081                        L263:
  7082                        L261:
  7083                        ;			while (IsSeparator(p[si])) si++;
                    	/* Skip duplicated separator if exist */
  7084                        L10125:
  7085 00:1BF4: E2 20        	sep	#$20
  7086                        	longa	off
  7087 00:1BF6: A4 11        	ldy	<L259+si_1
  7088 00:1BF8: B7 15        	lda	[<L259+p_1],Y
  7089 00:1BFA: C9 2F        	cmp	#<$2f
  7090 00:1BFC: C2 20        	rep	#$20
  7091                        	longa	on
  7092 00:1BFE: D0 03        	bne	L265
  7093 00:1C00: 82 0F 00     	brl	L264
  7094                        L265:
  7095 00:1C03: E2 20        	sep	#$20
  7096                        	longa	off
  7097 00:1C05: A4 11        	ldy	<L259+si_1
  7098 00:1C07: B7 15        	lda	[<L259+p_1],Y
  7099 00:1C09: C9 5C        	cmp	#<$5c
  7100 00:1C0B: C2 20        	rep	#$20
  Thu May 20 2021 21:37                                                Page 149


  7101                        	longa	on
  7102 00:1C0D: F0 03        	beq	L266
  7103 00:1C0F: 82 05 00     	brl	L10126
  7104                        L266:
  7105                        L264:
  7106 00:1C12: E6 11        	inc	<L259+si_1
  7107 00:1C14: 82 DD FF     	brl	L10125
  7108                        L10126:
  7109                        ;			break;
  7110 00:1C17: 82 2C 01     	brl	L10123
  7111                        ;		}
  7112                        ;		if (c == '.' || i >= ni) {		
                    /* End of body or field overflow? */
  7113                        L10124:
  7114 00:1C1A: E2 20        	sep	#$20
  7115                        	longa	off
  7116 00:1C1C: A5 09        	lda	<L259+c_1
  7117 00:1C1E: C9 2E        	cmp	#<$2e
  7118 00:1C20: C2 20        	rep	#$20
  7119                        	longa	on
  7120 00:1C22: D0 03        	bne	L268
  7121 00:1C24: 82 09 00     	brl	L267
  7122                        L268:
  7123 00:1C27: A5 13        	lda	<L259+i_1
  7124 00:1C29: C5 0F        	cmp	<L259+ni_1
  7125 00:1C2B: B0 03        	bcs	L269
  7126 00:1C2D: 82 39 00     	brl	L10127
  7127                        L269:
  7128                        L267:
  7129                        ;			if (ni == 11 || c != '.') return
                     FR_INVALID_NAME;	/* Field overflow or invalid dot? */
  7130 00:1C30: A5 0F        	lda	<L259+ni_1
  7131 00:1C32: C9 0B 00     	cmp	#<$b
  7132 00:1C35: D0 03        	bne	L271
  7133 00:1C37: 82 0D 00     	brl	L270
  7134                        L271:
  7135 00:1C3A: E2 20        	sep	#$20
  7136                        	longa	off
  7137 00:1C3C: A5 09        	lda	<L259+c_1
  7138 00:1C3E: C9 2E        	cmp	#<$2e
  7139 00:1C40: C2 20        	rep	#$20
  7140                        	longa	on
  7141 00:1C42: D0 03        	bne	L272
  7142 00:1C44: 82 15 00     	brl	L10128
  7143                        L272:
  7144                        L270:
  7145 00:1C47: A9 06 00     	lda	#$6
  7146                        L273:
  7147 00:1C4A: A8           	tay
  7148 00:1C4B: A5 1A        	lda	<L258+2
  7149 00:1C4D: 85 22        	sta	<L258+2+8
  7150 00:1C4F: A5 19        	lda	<L258+1
  7151 00:1C51: 85 21        	sta	<L258+1+8
  7152 00:1C53: 2B           	pld
  7153 00:1C54: 3B           	tsc
  7154 00:1C55: 18           	clc
  7155 00:1C56: 69 20 00     	adc	#L258+8
  7156 00:1C59: 1B           	tcs
  Thu May 20 2021 21:37                                                Page 150


  7157 00:1C5A: 98           	tya
  7158 00:1C5B: 6B           	rtl
  7159                        ;			i = 8; ni = 11;			
                    	/* Enter file extension field */
  7160                        L10128:
  7161 00:1C5C: A9 08 00     	lda	#$8
  7162 00:1C5F: 85 13        	sta	<L259+i_1
  7163 00:1C61: A9 0B 00     	lda	#$b
  7164 00:1C64: 85 0F        	sta	<L259+ni_1
  7165                        ;			continue;
  7166 00:1C66: 82 58 FF     	brl	L10122
  7167                        ;		}
  7168                        ;#if FF_CODE_PAGE == 0
  7169                        ;		if (ExCvt && c >= 0x80) {		
                    /* Is SBC extended character? */
  7170                        ;			c = ExCvt[c & 0x7F];		
                    /* To upper SBC extended character */
  7171                        ;		}
  7172                        ;#elif FF_CODE_PAGE < 900
  7173                        ;		if (c >= 0x80) {			
                    	/* Is SBC extended character? */
  7174                        L10127:
  7175 00:1C69: E2 20        	sep	#$20
  7176                        	longa	off
  7177 00:1C6B: A5 09        	lda	<L259+c_1
  7178 00:1C6D: C9 80        	cmp	#<$80
  7179 00:1C6F: C2 20        	rep	#$20
  7180                        	longa	on
  7181 00:1C71: B0 03        	bcs	L274
  7182 00:1C73: 82 17 00     	brl	L10129
  7183                        L274:
  7184                        ;			c = ExCvt[c & 0x7F];		
                    /* To upper SBC extended character */
  7185 00:1C76: A5 09        	lda	<L259+c_1
  7186 00:1C78: 29 7F 00     	and	#<$7f
  7187 00:1C7B: 85 01        	sta	<R0
  7188 00:1C7D: 18           	clc
  7189 00:1C7E: A9 xx xx     	lda	#<~~ExCvt
  7190 00:1C81: 65 01        	adc	<R0
  7191 00:1C83: 85 05        	sta	<R1
  7192 00:1C85: E2 20        	sep	#$20
  7193                        	longa	off
  7194 00:1C87: B2 05        	lda	(<R1)
  7195 00:1C89: 85 09        	sta	<L259+c_1
  7196 00:1C8B: C2 20        	rep	#$20
  7197                        	longa	on
  7198                        ;		}
  7199                        ;#endif
  7200                        ;		if (dbc_1st(c)) {			
                    	/* Check if it is a DBC 1st byte */
  7201                        L10129:
  7202 00:1C8D: D4 09        	pei	<L259+c_1
  7203 00:1C8F: 22 xx xx xx  	jsl	~~dbc_1st
  7204 00:1C93: AA           	tax
  7205 00:1C94: D0 03        	bne	L275
  7206 00:1C96: 82 4A 00     	brl	L10130
  7207                        L275:
  7208                        ;			d = (BYTE)p[si++];		
  Thu May 20 2021 21:37                                                Page 151


                    	/* Get 2nd byte */
  7209 00:1C99: E2 20        	sep	#$20
  7210                        	longa	off
  7211 00:1C9B: A4 11        	ldy	<L259+si_1
  7212 00:1C9D: B7 15        	lda	[<L259+p_1],Y
  7213 00:1C9F: 85 0A        	sta	<L259+d_1
  7214 00:1CA1: C2 20        	rep	#$20
  7215                        	longa	on
  7216 00:1CA3: E6 11        	inc	<L259+si_1
  7217                        ;			if (!dbc_2nd(d) || i >= ni - 1) 
                    return FR_INVALID_NAME;	/* Reject invalid DBC */
  7218 00:1CA5: D4 0A        	pei	<L259+d_1
  7219 00:1CA7: 22 xx xx xx  	jsl	~~dbc_2nd
  7220 00:1CAB: AA           	tax
  7221 00:1CAC: D0 03        	bne	L277
  7222 00:1CAE: 82 11 00     	brl	L276
  7223                        L277:
  7224 00:1CB1: 18           	clc
  7225 00:1CB2: A9 FF FF     	lda	#$ffff
  7226 00:1CB5: 65 0F        	adc	<L259+ni_1
  7227 00:1CB7: 85 01        	sta	<R0
  7228 00:1CB9: A5 13        	lda	<L259+i_1
  7229 00:1CBB: C5 01        	cmp	<R0
  7230 00:1CBD: B0 03        	bcs	L278
  7231 00:1CBF: 82 06 00     	brl	L10131
  7232                        L278:
  7233                        L276:
  7234 00:1CC2: A9 06 00     	lda	#$6
  7235 00:1CC5: 82 82 FF     	brl	L273
  7236                        ;			sfn[i++] = c;
  7237                        L10131:
  7238 00:1CC8: E2 20        	sep	#$20
  7239                        	longa	off
  7240 00:1CCA: A5 09        	lda	<L259+c_1
  7241 00:1CCC: A4 13        	ldy	<L259+i_1
  7242 00:1CCE: 97 0B        	sta	[<L259+sfn_1],Y
  7243 00:1CD0: C2 20        	rep	#$20
  7244                        	longa	on
  7245 00:1CD2: E6 13        	inc	<L259+i_1
  7246                        ;			sfn[i++] = d;
  7247 00:1CD4: E2 20        	sep	#$20
  7248                        	longa	off
  7249 00:1CD6: A5 0A        	lda	<L259+d_1
  7250 00:1CD8: A4 13        	ldy	<L259+i_1
  7251 00:1CDA: 97 0B        	sta	[<L259+sfn_1],Y
  7252 00:1CDC: C2 20        	rep	#$20
  7253                        	longa	on
  7254 00:1CDE: E6 13        	inc	<L259+i_1
  7255                        ;		} else {				
                    		/* SBC */
  7256 00:1CE0: 82 60 00     	brl	L10132
  7257                        L10130:
  7258                        ;			if (strchr("*+,:;<=>[]|\"\?\x7F"
                    , (int)c)) return FR_INVALID_NAME;	/* Reject illegal chrs f
                    or SFN */
  7259 00:1CE3: A5 09        	lda	<L259+c_1
  7260 00:1CE5: 29 FF 00     	and	#$ff
  7261 00:1CE8: 48           	pha
  Thu May 20 2021 21:37                                                Page 152


  7262 00:1CE9: F4 xx xx     	pea	#^L1
  7263 00:1CEC: F4 xx xx     	pea	#<L1
  7264 00:1CEF: 22 xx xx xx  	jsl	~~strchr
  7265 00:1CF3: 85 01        	sta	<R0
  7266 00:1CF5: 86 03        	stx	<R0+2
  7267 00:1CF7: A5 01        	lda	<R0
  7268 00:1CF9: 05 03        	ora	<R0+2
  7269 00:1CFB: D0 03        	bne	L279
  7270 00:1CFD: 82 06 00     	brl	L10133
  7271                        L279:
  7272 00:1D00: A9 06 00     	lda	#$6
  7273 00:1D03: 82 44 FF     	brl	L273
  7274                        ;			if (IsLower(c)) c -= 0x20;	
                    /* To upper */
  7275                        L10133:
  7276 00:1D06: E2 20        	sep	#$20
  7277                        	longa	off
  7278 00:1D08: A5 09        	lda	<L259+c_1
  7279 00:1D0A: C9 61        	cmp	#<$61
  7280 00:1D0C: C2 20        	rep	#$20
  7281                        	longa	on
  7282 00:1D0E: B0 03        	bcs	L280
  7283 00:1D10: 82 24 00     	brl	L10134
  7284                        L280:
  7285 00:1D13: E2 20        	sep	#$20
  7286                        	longa	off
  7287 00:1D15: A9 7A        	lda	#$7a
  7288 00:1D17: C5 09        	cmp	<L259+c_1
  7289 00:1D19: C2 20        	rep	#$20
  7290                        	longa	on
  7291 00:1D1B: B0 03        	bcs	L281
  7292 00:1D1D: 82 17 00     	brl	L10134
  7293                        L281:
  7294 00:1D20: A5 09        	lda	<L259+c_1
  7295 00:1D22: 29 FF 00     	and	#$ff
  7296 00:1D25: 85 01        	sta	<R0
  7297 00:1D27: 18           	clc
  7298 00:1D28: A9 E0 FF     	lda	#$ffe0
  7299 00:1D2B: 65 01        	adc	<R0
  7300 00:1D2D: 85 05        	sta	<R1
  7301 00:1D2F: E2 20        	sep	#$20
  7302                        	longa	off
  7303 00:1D31: A5 05        	lda	<R1
  7304 00:1D33: 85 09        	sta	<L259+c_1
  7305 00:1D35: C2 20        	rep	#$20
  7306                        	longa	on
  7307                        ;			sfn[i++] = c;
  7308                        L10134:
  7309 00:1D37: E2 20        	sep	#$20
  7310                        	longa	off
  7311 00:1D39: A5 09        	lda	<L259+c_1
  7312 00:1D3B: A4 13        	ldy	<L259+i_1
  7313 00:1D3D: 97 0B        	sta	[<L259+sfn_1],Y
  7314 00:1D3F: C2 20        	rep	#$20
  7315                        	longa	on
  7316 00:1D41: E6 13        	inc	<L259+i_1
  7317                        ;		}
  7318                        L10132:
  Thu May 20 2021 21:37                                                Page 153


  7319                        ;	}
  7320 00:1D43: 82 7B FE     	brl	L10122
  7321                        L10123:
  7322                        ;	*path = &p[si];					
                    	/* Return pointer to the next segment */
  7323 00:1D46: A5 11        	lda	<L259+si_1
  7324 00:1D48: 85 01        	sta	<R0
  7325 00:1D4A: 64 03        	stz	<R0+2
  7326 00:1D4C: 18           	clc
  7327 00:1D4D: A5 15        	lda	<L259+p_1
  7328 00:1D4F: 65 01        	adc	<R0
  7329 00:1D51: 85 05        	sta	<R1
  7330 00:1D53: A5 17        	lda	<L259+p_1+2
  7331 00:1D55: 65 03        	adc	<R0+2
  7332 00:1D57: 85 07        	sta	<R1+2
  7333 00:1D59: A5 05        	lda	<R1
  7334 00:1D5B: 87 20        	sta	[<L258+path_0]
  7335 00:1D5D: A5 07        	lda	<R1+2
  7336 00:1D5F: A0 02 00     	ldy	#$2
  7337 00:1D62: 97 20        	sta	[<L258+path_0],Y
  7338                        ;	if (i == 0) return FR_INVALID_NAME;	/* Rejec
                    t nul string */
  7339 00:1D64: A5 13        	lda	<L259+i_1
  7340 00:1D66: F0 03        	beq	L282
  7341 00:1D68: 82 06 00     	brl	L10135
  7342                        L282:
  7343 00:1D6B: A9 06 00     	lda	#$6
  7344 00:1D6E: 82 D9 FE     	brl	L273
  7345                        ;
  7346                        ;	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If th
                    e first character collides with DDEM, replace it with RDDEM 
                    */
  7347                        L10135:
  7348 00:1D71: E2 20        	sep	#$20
  7349                        	longa	off
  7350 00:1D73: A7 0B        	lda	[<L259+sfn_1]
  7351 00:1D75: C9 E5        	cmp	#<$e5
  7352 00:1D77: C2 20        	rep	#$20
  7353                        	longa	on
  7354 00:1D79: F0 03        	beq	L283
  7355 00:1D7B: 82 08 00     	brl	L10136
  7356                        L283:
  7357 00:1D7E: E2 20        	sep	#$20
  7358                        	longa	off
  7359 00:1D80: A9 05        	lda	#$5
  7360 00:1D82: 87 0B        	sta	[<L259+sfn_1]
  7361 00:1D84: C2 20        	rep	#$20
  7362                        	longa	on
  7363                        ;	sfn[NSFLAG] = (c <= ' ' || p[si] <= ' ') ? NS_LA
                    ST : 0;	/* Set last segment flag if end of the path */
  7364                        L10136:
  7365 00:1D86: E2 20        	sep	#$20
  7366                        	longa	off
  7367 00:1D88: A9 20        	lda	#$20
  7368 00:1D8A: C5 09        	cmp	<L259+c_1
  7369 00:1D8C: C2 20        	rep	#$20
  7370                        	longa	on
  7371 00:1D8E: 90 03        	bcc	L286
  Thu May 20 2021 21:37                                                Page 154


  7372 00:1D90: 82 0F 00     	brl	L285
  7373                        L286:
  7374 00:1D93: E2 20        	sep	#$20
  7375                        	longa	off
  7376 00:1D95: A9 20        	lda	#$20
  7377 00:1D97: A4 11        	ldy	<L259+si_1
  7378 00:1D99: D7 15        	cmp	[<L259+p_1],Y
  7379 00:1D9B: C2 20        	rep	#$20
  7380                        	longa	on
  7381 00:1D9D: B0 03        	bcs	L287
  7382 00:1D9F: 82 05 00     	brl	L284
  7383                        L287:
  7384                        L285:
  7385 00:1DA2: A9 04 00     	lda	#$4
  7386 00:1DA5: 80 03        	bra	L288
  7387                        L284:
  7388 00:1DA7: A9 00 00     	lda	#$0
  7389                        L288:
  7390 00:1DAA: E2 20        	sep	#$20
  7391                        	longa	off
  7392 00:1DAC: A0 0B 00     	ldy	#$b
  7393 00:1DAF: 97 0B        	sta	[<L259+sfn_1],Y
  7394 00:1DB1: C2 20        	rep	#$20
  7395                        	longa	on
  7396                        ;
  7397                        ;	return FR_OK;
  7398 00:1DB3: A9 00 00     	lda	#$0
  7399 00:1DB6: 82 91 FE     	brl	L273
  7400                        ;#endif /* FF_USE_LFN */
  7401                        ;}
  7402             00000018   L258	equ	24
  7403             00000009   L259	equ	9
  7404                        	ends
  7405                        	efunc
  7406                        	data
  7407                        L1:
  7408 00:0080: 2A 2B 2C 3A  	db	$2A,$2B,$2C,$3A,$3B,$3C,$3D,$3E,$5B,$5D,
                    $7C,$22,$3F,$7F,$00
       00:0084: 3B 3C 3D 3E 
       00:0088: 5B 5D 7C 22 
       00:008C: 3F 7F 00 
  7409 00:008F:              	ends
  7410                        ;
  7411                        ;
  7412                        ;
  7413                        ;
  7414                        ;/*-----------------------------------------------
                    ------------------------*/
  7415                        ;/* Follow a file path                            
                                            */
  7416                        ;/*-----------------------------------------------
                    ------------------------*/
  7417                        ;
  7418                        ;static FRESULT follow_path (	/* FR_OK(0): suc
                    cessful, !=0: error code */
  7419                        ;	DIR* dp,					
                    /* Directory object to return last directory and found objec
                    t */
  Thu May 20 2021 21:37                                                Page 155


  7420                        ;	const TCHAR* path			/* Full-
                    path string to find a file or directory */
  7421                        ;)
  7422                        ;{
  7423                        	code
  7424                        	func
  7425                        ~~follow_path:
  7426                        	longa	on
  7427                        	longi	on
  7428 00:1DB9: 3B           	tsc
  7429 00:1DBA: 38           	sec
  7430 00:1DBB: E9 13 00     	sbc	#L290
  7431 00:1DBE: 1B           	tcs
  7432 00:1DBF: 0B           	phd
  7433 00:1DC0: 5B           	tcd
  7434             00000004   dp_0	set	4
  7435             00000008   path_0	set	8
  7436                        ;	FRESULT res;
  7437                        ;	BYTE ns;
  7438                        ;	FATFS *fs = dp->obj.fs;
  7439                        ;
  7440                        ;
  7441                        ;#if FF_FS_RPATH != 0
  7442                        ;	if (!IsSeparator(*path) && (FF_STR_VOLUME_ID != 
                    2 || !IsTerminator(*path))) {	/* Without heading separ
                    ator */
  7443                        ;		dp->obj.sclust = fs->cdir;		
                    	/* Start at the current directory */
  7444                        ;	} else
  7445                        ;#endif
  7446                        ;	{						
                    				/* With heading separator */
  7447             00000000   res_1	set	0
  7448             00000002   ns_1	set	2
  7449             00000003   fs_1	set	3
  7450 00:1DC1: A7 17        	lda	[<L290+dp_0]
  7451 00:1DC3: 85 10        	sta	<L291+fs_1
  7452 00:1DC5: A0 02 00     	ldy	#$2
  7453 00:1DC8: B7 17        	lda	[<L290+dp_0],Y
  7454 00:1DCA: 85 12        	sta	<L291+fs_1+2
  7455                        ;		while (IsSeparator(*path)) path++;	
                    /* Strip separators */
  7456                        L10137:
  7457 00:1DCC: E2 20        	sep	#$20
  7458                        	longa	off
  7459 00:1DCE: A7 1B        	lda	[<L290+path_0]
  7460 00:1DD0: C9 2F        	cmp	#<$2f
  7461 00:1DD2: C2 20        	rep	#$20
  7462                        	longa	on
  7463 00:1DD4: D0 03        	bne	L293
  7464 00:1DD6: 82 0D 00     	brl	L292
  7465                        L293:
  7466 00:1DD9: E2 20        	sep	#$20
  7467                        	longa	off
  7468 00:1DDB: A7 1B        	lda	[<L290+path_0]
  7469 00:1DDD: C9 5C        	cmp	#<$5c
  7470 00:1DDF: C2 20        	rep	#$20
  7471                        	longa	on
  Thu May 20 2021 21:37                                                Page 156


  7472 00:1DE1: F0 03        	beq	L294
  7473 00:1DE3: 82 09 00     	brl	L10138
  7474                        L294:
  7475                        L292:
  7476 00:1DE6: E6 1B        	inc	<L290+path_0
  7477 00:1DE8: D0 02        	bne	L295
  7478 00:1DEA: E6 1D        	inc	<L290+path_0+2
  7479                        L295:
  7480 00:1DEC: 82 DD FF     	brl	L10137
  7481                        L10138:
  7482                        ;		dp->obj.sclust = 0;			
                    		/* Start from the root directory */
  7483 00:1DEF: A9 00 00     	lda	#$0
  7484 00:1DF2: A0 08 00     	ldy	#$8
  7485 00:1DF5: 97 17        	sta	[<L290+dp_0],Y
  7486 00:1DF7: A9 00 00     	lda	#$0
  7487 00:1DFA: A0 0A 00     	ldy	#$a
  7488 00:1DFD: 97 17        	sta	[<L290+dp_0],Y
  7489                        ;	}
  7490                        ;#if FF_FS_EXFAT
  7491                        ;	dp->obj.n_frag = 0;	/* Invalidate last fragm
                    ent counter of the object */
  7492                        ;#if FF_FS_RPATH != 0
  7493                        ;	if (fs->fs_type == FS_EXFAT && dp->obj.sclust) {
                    	/* exFAT: Retrieve the sub-directory's status */
  7494                        ;		DIR dj;
  7495                        ;
  7496                        ;		dp->obj.c_scl = fs->cdc_scl;
  7497                        ;		dp->obj.c_size = fs->cdc_size;
  7498                        ;		dp->obj.c_ofs = fs->cdc_ofs;
  7499                        ;		res = load_obj_xdir(&dj, &dp->obj);
  7500                        ;		if (res != FR_OK) return res;
  7501                        ;		dp->obj.objsize = ld_dword(fs->dirbuf + 
                    XDIR_FileSize);
  7502                        ;		dp->obj.stat = fs->dirbuf[XDIR_GenFlags]
                     & 2;
  7503                        ;	}
  7504                        ;#endif
  7505                        ;#endif
  7506                        ;
  7507                        ;	if ((UINT)*path < ' ') {			
                    	/* Null path name is the origin directory itself */
  7508 00:1DFF: E2 20        	sep	#$20
  7509                        	longa	off
  7510 00:1E01: A7 1B        	lda	[<L290+path_0]
  7511 00:1E03: C9 20        	cmp	#<$20
  7512 00:1E05: C2 20        	rep	#$20
  7513                        	longa	on
  7514 00:1E07: 90 03        	bcc	L296
  7515 00:1E09: 82 1E 00     	brl	L10139
  7516                        L296:
  7517                        ;		dp->fn[NSFLAG] = NS_NONAME;
  7518 00:1E0C: E2 20        	sep	#$20
  7519                        	longa	off
  7520 00:1E0E: A9 80        	lda	#$80
  7521 00:1E10: A0 2B 00     	ldy	#$2b
  7522 00:1E13: 97 17        	sta	[<L290+dp_0],Y
  7523 00:1E15: C2 20        	rep	#$20
  Thu May 20 2021 21:37                                                Page 157


  7524                        	longa	on
  7525                        ;		res = dir_sdi(dp, 0);
  7526 00:1E17: F4 00 00     	pea	#^$0
  7527 00:1E1A: F4 00 00     	pea	#<$0
  7528 00:1E1D: D4 19        	pei	<L290+dp_0+2
  7529 00:1E1F: D4 17        	pei	<L290+dp_0
  7530 00:1E21: 22 xx xx xx  	jsl	~~dir_sdi
  7531 00:1E25: 85 0D        	sta	<L291+res_1
  7532                        ;
  7533                        ;	} else {					
                    			/* Follow path */
  7534 00:1E27: 82 F0 00     	brl	L10140
  7535                        L10139:
  7536                        ;		for (;;) {
  7537                        L10141:
  7538                        ;			res = create_name(dp, &path);	
                    /* Get a segment name of the path */
  7539 00:1E2A: F4 00 00     	pea	#0
  7540 00:1E2D: 18           	clc
  7541 00:1E2E: 7B           	tdc
  7542 00:1E2F: 69 1B 00     	adc	#<L290+path_0
  7543 00:1E32: 48           	pha
  7544 00:1E33: D4 19        	pei	<L290+dp_0+2
  7545 00:1E35: D4 17        	pei	<L290+dp_0
  7546 00:1E37: 22 xx xx xx  	jsl	~~create_name
  7547 00:1E3B: 85 0D        	sta	<L291+res_1
  7548                        ;			if (res != FR_OK) break;
  7549 00:1E3D: A5 0D        	lda	<L291+res_1
  7550 00:1E3F: F0 03        	beq	L297
  7551 00:1E41: 82 D6 00     	brl	L10142
  7552                        L297:
  7553                        ;			res = dir_find(dp);		
                    		/* Find an object with the segment name */
  7554 00:1E44: D4 19        	pei	<L290+dp_0+2
  7555 00:1E46: D4 17        	pei	<L290+dp_0
  7556 00:1E48: 22 xx xx xx  	jsl	~~dir_find
  7557 00:1E4C: 85 0D        	sta	<L291+res_1
  7558                        ;			ns = dp->fn[NSFLAG];
  7559 00:1E4E: E2 20        	sep	#$20
  7560                        	longa	off
  7561 00:1E50: A0 2B 00     	ldy	#$2b
  7562 00:1E53: B7 17        	lda	[<L290+dp_0],Y
  7563 00:1E55: 85 0F        	sta	<L291+ns_1
  7564 00:1E57: C2 20        	rep	#$20
  7565                        	longa	on
  7566                        ;			if (res != FR_OK) {		
                    		/* Failed to find the object */
  7567 00:1E59: A5 0D        	lda	<L291+res_1
  7568 00:1E5B: D0 03        	bne	L298
  7569 00:1E5D: 82 4C 00     	brl	L10143
  7570                        L298:
  7571                        ;				if (res == FR_NO_FILE) {
                    	/* Object is not found */
  7572 00:1E60: A5 0D        	lda	<L291+res_1
  7573 00:1E62: C9 04 00     	cmp	#<$4
  7574 00:1E65: F0 03        	beq	L299
  7575 00:1E67: 82 3F 00     	brl	L10144
  7576                        L299:
  Thu May 20 2021 21:37                                                Page 158


  7577                        ;					if (FF_FS_RPATH 
                    && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there
                     */
  7578 00:1E6A: 82 2A 00     	brl	L10145
  7579 00:1E6D: E2 20        	sep	#$20
  7580                        	longa	off
  7581 00:1E6F: A5 0F        	lda	<L291+ns_1
  7582 00:1E71: 29 20        	and	#<$20
  7583 00:1E73: C2 20        	rep	#$20
  7584                        	longa	on
  7585 00:1E75: D0 03        	bne	L300
  7586 00:1E77: 82 1D 00     	brl	L10145
  7587                        L300:
  7588                        ;						if (!(ns
                     & NS_LAST)) continue;	/* Continue to follow if not las
                    t segment */
  7589 00:1E7A: E2 20        	sep	#$20
  7590                        	longa	off
  7591 00:1E7C: A5 0F        	lda	<L291+ns_1
  7592 00:1E7E: 29 04        	and	#<$4
  7593 00:1E80: C2 20        	rep	#$20
  7594                        	longa	on
  7595 00:1E82: D0 03        	bne	L301
  7596 00:1E84: 82 A3 FF     	brl	L10141
  7597                        L301:
  7598                        ;						dp->fn[N
                    SFLAG] = NS_NONAME;
  7599 00:1E87: E2 20        	sep	#$20
  7600                        	longa	off
  7601 00:1E89: A9 80        	lda	#$80
  7602 00:1E8B: A0 2B 00     	ldy	#$2b
  7603 00:1E8E: 97 17        	sta	[<L290+dp_0],Y
  7604 00:1E90: C2 20        	rep	#$20
  7605                        	longa	on
  7606                        ;						res = FR
                    _OK;
  7607 00:1E92: 64 0D        	stz	<L291+res_1
  7608                        ;					} else {	
                    						/* Could not fin
                    d the object */
  7609 00:1E94: 82 12 00     	brl	L10146
  7610                        L10145:
  7611                        ;						if (!(ns
                     & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if 
                    not last segment */
  7612 00:1E97: E2 20        	sep	#$20
  7613                        	longa	off
  7614 00:1E99: A5 0F        	lda	<L291+ns_1
  7615 00:1E9B: 29 04        	and	#<$4
  7616 00:1E9D: C2 20        	rep	#$20
  7617                        	longa	on
  7618 00:1E9F: F0 03        	beq	L302
  7619 00:1EA1: 82 05 00     	brl	L10147
  7620                        L302:
  7621 00:1EA4: A9 05 00     	lda	#$5
  7622 00:1EA7: 85 0D        	sta	<L291+res_1
  7623                        ;					}
  7624                        L10147:
  Thu May 20 2021 21:37                                                Page 159


  7625                        L10146:
  7626                        ;				}
  7627                        ;				break;
  7628                        L10144:
  7629 00:1EA9: 82 6E 00     	brl	L10142
  7630                        ;			}
  7631                        ;			if (ns & NS_LAST) break;	
                    	/* Last segment matched. Function completed. */
  7632                        L10143:
  7633 00:1EAC: E2 20        	sep	#$20
  7634                        	longa	off
  7635 00:1EAE: A5 0F        	lda	<L291+ns_1
  7636 00:1EB0: 29 04        	and	#<$4
  7637 00:1EB2: C2 20        	rep	#$20
  7638                        	longa	on
  7639 00:1EB4: F0 03        	beq	L303
  7640 00:1EB6: 82 61 00     	brl	L10142
  7641                        L303:
  7642                        ;			/* Get into the sub-directory */
  7643                        ;			if (!(dp->obj.attr & AM_DIR)) {	
                    /* It is not a sub-directory and cannot follow */
  7644 00:1EB9: E2 20        	sep	#$20
  7645                        	longa	off
  7646 00:1EBB: A0 06 00     	ldy	#$6
  7647 00:1EBE: B7 17        	lda	[<L290+dp_0],Y
  7648 00:1EC0: 29 10        	and	#<$10
  7649 00:1EC2: C2 20        	rep	#$20
  7650                        	longa	on
  7651 00:1EC4: F0 03        	beq	L304
  7652 00:1EC6: 82 08 00     	brl	L10148
  7653                        L304:
  7654                        ;				res = FR_NO_PATH; break;
  7655 00:1EC9: A9 05 00     	lda	#$5
  7656 00:1ECC: 85 0D        	sta	<L291+res_1
  7657 00:1ECE: 82 49 00     	brl	L10142
  7658                        ;			}
  7659                        ;#if FF_FS_EXFAT
  7660                        ;			if (fs->fs_type == FS_EXFAT) {	
                    /* Save containing directory information for next dir */
  7661                        ;				dp->obj.c_scl = dp->obj.
                    sclust;
  7662                        ;				dp->obj.c_size = ((DWORD
                    )dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
  7663                        ;				dp->obj.c_ofs = dp->blk_
                    ofs;
  7664                        ;				init_alloc_info(fs, &dp-
                    >obj);	/* Open next directory */
  7665                        ;			} else
  7666                        ;#endif
  7667                        ;			{
  7668                        L10148:
  7669                        ;				dp->obj.sclust = ld_clus
                    t(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory *
                    /
  7670 00:1ED1: A0 10 00     	ldy	#$10
  7671 00:1ED4: B7 17        	lda	[<L290+dp_0],Y
  7672 00:1ED6: 29 FF 01     	and	#<$1ff
  7673 00:1ED9: 85 01        	sta	<R0
  Thu May 20 2021 21:37                                                Page 160


  7674 00:1EDB: 64 03        	stz	<R0+2
  7675 00:1EDD: 18           	clc
  7676 00:1EDE: A9 2F 00     	lda	#$2f
  7677 00:1EE1: 65 01        	adc	<R0
  7678 00:1EE3: 85 05        	sta	<R1
  7679 00:1EE5: A9 00 00     	lda	#$0
  7680 00:1EE8: 65 03        	adc	<R0+2
  7681 00:1EEA: 85 07        	sta	<R1+2
  7682 00:1EEC: 18           	clc
  7683 00:1EED: A5 10        	lda	<L291+fs_1
  7684 00:1EEF: 65 05        	adc	<R1
  7685 00:1EF1: 85 01        	sta	<R0
  7686 00:1EF3: A5 12        	lda	<L291+fs_1+2
  7687 00:1EF5: 65 07        	adc	<R1+2
  7688 00:1EF7: 85 03        	sta	<R0+2
  7689 00:1EF9: D4 03        	pei	<R0+2
  7690 00:1EFB: D4 01        	pei	<R0
  7691 00:1EFD: D4 12        	pei	<L291+fs_1+2
  7692 00:1EFF: D4 10        	pei	<L291+fs_1
  7693 00:1F01: 22 xx xx xx  	jsl	~~ld_clust
  7694 00:1F05: 85 09        	sta	<R2
  7695 00:1F07: 86 0B        	stx	<R2+2
  7696 00:1F09: A5 09        	lda	<R2
  7697 00:1F0B: A0 08 00     	ldy	#$8
  7698 00:1F0E: 97 17        	sta	[<L290+dp_0],Y
  7699 00:1F10: A5 0B        	lda	<R2+2
  7700 00:1F12: A0 0A 00     	ldy	#$a
  7701 00:1F15: 97 17        	sta	[<L290+dp_0],Y
  7702                        ;			}
  7703                        ;		}
  7704 00:1F17: 82 10 FF     	brl	L10141
  7705                        L10142:
  7706                        ;	}
  7707                        L10140:
  7708                        ;
  7709                        ;	return res;
  7710 00:1F1A: A5 0D        	lda	<L291+res_1
  7711                        L305:
  7712 00:1F1C: A8           	tay
  7713 00:1F1D: A5 15        	lda	<L290+2
  7714 00:1F1F: 85 1D        	sta	<L290+2+8
  7715 00:1F21: A5 14        	lda	<L290+1
  7716 00:1F23: 85 1C        	sta	<L290+1+8
  7717 00:1F25: 2B           	pld
  7718 00:1F26: 3B           	tsc
  7719 00:1F27: 18           	clc
  7720 00:1F28: 69 1B 00     	adc	#L290+8
  7721 00:1F2B: 1B           	tcs
  7722 00:1F2C: 98           	tya
  7723 00:1F2D: 6B           	rtl
  7724                        ;}
  7725             00000013   L290	equ	19
  7726             0000000D   L291	equ	13
  7727                        	ends
  7728                        	efunc
  7729                        ;
  7730                        ;
  7731                        ;
  Thu May 20 2021 21:37                                                Page 161


  7732                        ;
  7733                        ;/*-----------------------------------------------
                    ------------------------*/
  7734                        ;/* Get logical drive number from path name       
                                            */
  7735                        ;/*-----------------------------------------------
                    ------------------------*/
  7736                        ;
  7737                        ;static int get_ldnumber (	/* Returns logic
                    al drive number (-1:invalid drive number or null pointer) */
  7738                        ;	const TCHAR** path		/* Pointer to po
                    inter to the path name */
  7739                        ;)
  7740                        ;{
  7741                        	code
  7742                        	func
  7743                        ~~get_ldnumber:
  7744                        	longa	on
  7745                        	longi	on
  7746 00:1F2E: 3B           	tsc
  7747 00:1F2F: 38           	sec
  7748 00:1F30: E9 11 00     	sbc	#L306
  7749 00:1F33: 1B           	tcs
  7750 00:1F34: 0B           	phd
  7751 00:1F35: 5B           	tcd
  7752             00000004   path_0	set	4
  7753                        ;	const TCHAR *tp, *tt;
  7754                        ;	TCHAR tc;
  7755                        ;	int i;
  7756                        ;	int vol = -1;
  7757                        ;#if FF_STR_VOLUME_ID		/* Find string v
                    olume ID */
  7758                        ;	const char *sp;
  7759                        ;	char c;
  7760                        ;#endif
  7761                        ;
  7762                        ;	tt = tp = *path;
  7763             00000000   tp_1	set	0
  7764             00000004   tt_1	set	4
  7765             00000008   tc_1	set	8
  7766             00000009   i_1	set	9
  7767             0000000B   vol_1	set	11
  7768 00:1F36: A9 FF FF     	lda	#$ffff
  7769 00:1F39: 85 10        	sta	<L307+vol_1
  7770 00:1F3B: A7 15        	lda	[<L306+path_0]
  7771 00:1F3D: 85 05        	sta	<L307+tp_1
  7772 00:1F3F: A0 02 00     	ldy	#$2
  7773 00:1F42: B7 15        	lda	[<L306+path_0],Y
  7774 00:1F44: 85 07        	sta	<L307+tp_1+2
  7775 00:1F46: A5 05        	lda	<L307+tp_1
  7776 00:1F48: 85 09        	sta	<L307+tt_1
  7777 00:1F4A: A5 07        	lda	<L307+tp_1+2
  7778 00:1F4C: 85 0B        	sta	<L307+tt_1+2
  7779                        ;	if (!tp) return vol;	/* Invalid path name? */
  7780 00:1F4E: A5 05        	lda	<L307+tp_1
  7781 00:1F50: 05 07        	ora	<L307+tp_1+2
  7782 00:1F52: F0 03        	beq	L308
  7783 00:1F54: 82 14 00     	brl	L10149
  Thu May 20 2021 21:37                                                Page 162


  7784                        L308:
  7785 00:1F57: A5 10        	lda	<L307+vol_1
  7786                        L309:
  7787 00:1F59: A8           	tay
  7788 00:1F5A: A5 13        	lda	<L306+2
  7789 00:1F5C: 85 17        	sta	<L306+2+4
  7790 00:1F5E: A5 12        	lda	<L306+1
  7791 00:1F60: 85 16        	sta	<L306+1+4
  7792 00:1F62: 2B           	pld
  7793 00:1F63: 3B           	tsc
  7794 00:1F64: 18           	clc
  7795 00:1F65: 69 15 00     	adc	#L306+4
  7796 00:1F68: 1B           	tcs
  7797 00:1F69: 98           	tya
  7798 00:1F6A: 6B           	rtl
  7799                        ;	do tc = *tt++; while (!IsTerminator(tc) && tc !=
                     ':');	/* Find a colon in the path */
  7800                        L10149:
  7801                        L10152:
  7802 00:1F6B: E2 20        	sep	#$20
  7803                        	longa	off
  7804 00:1F6D: A7 09        	lda	[<L307+tt_1]
  7805 00:1F6F: 85 0D        	sta	<L307+tc_1
  7806 00:1F71: C2 20        	rep	#$20
  7807                        	longa	on
  7808 00:1F73: E6 09        	inc	<L307+tt_1
  7809 00:1F75: D0 02        	bne	L310
  7810 00:1F77: E6 0B        	inc	<L307+tt_1+2
  7811                        L310:
  7812                        L10150:
  7813 00:1F79: E2 20        	sep	#$20
  7814                        	longa	off
  7815 00:1F7B: A5 0D        	lda	<L307+tc_1
  7816 00:1F7D: C9 21        	cmp	#<$21
  7817 00:1F7F: C2 20        	rep	#$20
  7818                        	longa	on
  7819 00:1F81: B0 03        	bcs	L312
  7820 00:1F83: 82 0D 00     	brl	L311
  7821                        L312:
  7822 00:1F86: E2 20        	sep	#$20
  7823                        	longa	off
  7824 00:1F88: A5 0D        	lda	<L307+tc_1
  7825 00:1F8A: C9 3A        	cmp	#<$3a
  7826 00:1F8C: C2 20        	rep	#$20
  7827                        	longa	on
  7828 00:1F8E: F0 03        	beq	L313
  7829 00:1F90: 82 D8 FF     	brl	L10152
  7830                        L313:
  7831                        L311:
  7832                        L10151:
  7833                        ;
  7834                        ;	if (tc == ':') {	/* DOS/Windows style vol
                    ume ID? */
  7835 00:1F93: E2 20        	sep	#$20
  7836                        	longa	off
  7837 00:1F95: A5 0D        	lda	<L307+tc_1
  7838 00:1F97: C9 3A        	cmp	#<$3a
  7839 00:1F99: C2 20        	rep	#$20
  Thu May 20 2021 21:37                                                Page 163


  7840                        	longa	on
  7841 00:1F9B: F0 03        	beq	L314
  7842 00:1F9D: 82 6A 00     	brl	L10153
  7843                        L314:
  7844                        ;		i = FF_VOLUMES;
  7845 00:1FA0: A9 01 00     	lda	#$1
  7846 00:1FA3: 85 0E        	sta	<L307+i_1
  7847                        ;		if (IsDigit(*tp) && tp + 2 == tt) {	
                    /* Is there a numeric volume ID + colon? */
  7848 00:1FA5: E2 20        	sep	#$20
  7849                        	longa	off
  7850 00:1FA7: A7 05        	lda	[<L307+tp_1]
  7851 00:1FA9: C9 30        	cmp	#<$30
  7852 00:1FAB: C2 20        	rep	#$20
  7853                        	longa	on
  7854 00:1FAD: B0 03        	bcs	L315
  7855 00:1FAF: 82 3A 00     	brl	L10154
  7856                        L315:
  7857 00:1FB2: E2 20        	sep	#$20
  7858                        	longa	off
  7859 00:1FB4: A9 39        	lda	#$39
  7860 00:1FB6: C7 05        	cmp	[<L307+tp_1]
  7861 00:1FB8: C2 20        	rep	#$20
  7862                        	longa	on
  7863 00:1FBA: B0 03        	bcs	L316
  7864 00:1FBC: 82 2D 00     	brl	L10154
  7865                        L316:
  7866 00:1FBF: 18           	clc
  7867 00:1FC0: A9 02 00     	lda	#$2
  7868 00:1FC3: 65 05        	adc	<L307+tp_1
  7869 00:1FC5: 85 01        	sta	<R0
  7870 00:1FC7: A9 00 00     	lda	#$0
  7871 00:1FCA: 65 07        	adc	<L307+tp_1+2
  7872 00:1FCC: 85 03        	sta	<R0+2
  7873 00:1FCE: A5 09        	lda	<L307+tt_1
  7874 00:1FD0: C5 01        	cmp	<R0
  7875 00:1FD2: D0 04        	bne	L317
  7876 00:1FD4: A5 0B        	lda	<L307+tt_1+2
  7877 00:1FD6: C5 03        	cmp	<R0+2
  7878                        L317:
  7879 00:1FD8: F0 03        	beq	L318
  7880 00:1FDA: 82 0F 00     	brl	L10154
  7881                        L318:
  7882                        ;			i = (int)*tp - '0';	/* Get t
                    he LD number */
  7883 00:1FDD: A7 05        	lda	[<L307+tp_1]
  7884 00:1FDF: 29 FF 00     	and	#$ff
  7885 00:1FE2: 85 01        	sta	<R0
  7886 00:1FE4: 18           	clc
  7887 00:1FE5: A9 D0 FF     	lda	#$ffd0
  7888 00:1FE8: 65 01        	adc	<R0
  7889 00:1FEA: 85 0E        	sta	<L307+i_1
  7890                        ;		}
  7891                        ;#if FF_STR_VOLUME_ID == 1	/* Arbitrary str
                    ing is enabled */
  7892                        ;		else {
  7893                        ;			i = 0;
  7894                        ;			do {
  Thu May 20 2021 21:37                                                Page 164


  7895                        ;				sp = VolumeStr[i]; tp = 
                    *path;	/* This string volume ID and path name */
  7896                        ;				do {	/* Compare the v
                    olume ID with path name */
  7897                        ;					c = *sp++; tc = 
                    *tp++;
  7898                        ;					if (IsLower(c)) 
                    c -= 0x20;
  7899                        ;					if (IsLower(tc))
                     tc -= 0x20;
  7900                        ;				} while (c && (TCHAR)c =
                    = tc);
  7901                        ;			} while ((c || tp != tt) && ++i 
                    < FF_VOLUMES);	/* Repeat for each id until pattern matc
                    h */
  7902                        ;		}
  7903                        ;#endif
  7904                        ;		if (i < FF_VOLUMES) {	/* If a volume I
                    D is found, get the drive number and strip it */
  7905                        L10154:
  7906 00:1FEC: A5 0E        	lda	<L307+i_1
  7907 00:1FEE: 30 06        	bmi	L319
  7908 00:1FF0: 3A           	dea
  7909 00:1FF1: 30 03        	bmi	L319
  7910 00:1FF3: 82 0F 00     	brl	L10155
  7911                        L319:
  7912                        ;			vol = i;		/* Drive
                     number */
  7913 00:1FF6: A5 0E        	lda	<L307+i_1
  7914 00:1FF8: 85 10        	sta	<L307+vol_1
  7915                        ;			*path = tt;		/* Snip 
                    the drive prefix off */
  7916 00:1FFA: A5 09        	lda	<L307+tt_1
  7917 00:1FFC: 87 15        	sta	[<L306+path_0]
  7918 00:1FFE: A5 0B        	lda	<L307+tt_1+2
  7919 00:2000: A0 02 00     	ldy	#$2
  7920 00:2003: 97 15        	sta	[<L306+path_0],Y
  7921                        ;		}
  7922                        ;		return vol;
  7923                        L10155:
  7924 00:2005: A5 10        	lda	<L307+vol_1
  7925 00:2007: 82 4F FF     	brl	L309
  7926                        ;	}
  7927                        ;#if FF_STR_VOLUME_ID == 2		/* Unix 
                    style volume ID is enabled */
  7928                        ;	if (*tp == '/') {			/* Is th
                    ere a volume ID? */
  7929                        ;		while (*(tp + 1) == '/') tp++;	/* Skip 
                    duplicated separator */
  7930                        ;		i = 0;
  7931                        ;		do {
  7932                        ;			tt = tp; sp = VolumeStr[i]; /* P
                    ath name and this string volume ID */
  7933                        ;			do {	/* Compare the volume ID
                     with path name */
  7934                        ;				c = *sp++; tc = *(++tt);
  7935                        ;				if (IsLower(c)) c -= 0x2
                    0;
  Thu May 20 2021 21:37                                                Page 165


  7936                        ;				if (IsLower(tc)) tc -= 0
                    x20;
  7937                        ;			} while (c && (TCHAR)c == tc);
  7938                        ;		} while ((c || (tc != '/' && !IsTerminat
                    or(tc))) && ++i < FF_VOLUMES);	/* Repeat for each ID un
                    til pattern match */
  7939                        ;		if (i < FF_VOLUMES) {	/* If a volume I
                    D is found, get the drive number and strip it */
  7940                        ;			vol = i;		/* Drive
                     number */
  7941                        ;			*path = tt;		/* Snip 
                    the drive prefix off */
  7942                        ;		}
  7943                        ;		return vol;
  7944                        ;	}
  7945                        ;#endif
  7946                        ;	/* No drive prefix is found */
  7947                        ;#if FF_FS_RPATH != 0
  7948                        ;	vol = CurrVol;	/* Default drive is current driv
                    e */
  7949                        ;#else
  7950                        ;	vol = 0;		/* Default drive is 0 */
  7951                        L10153:
  7952 00:200A: 64 10        	stz	<L307+vol_1
  7953                        ;#endif
  7954                        ;	return vol;		/* Return the default dr
                    ive */
  7955 00:200C: A5 10        	lda	<L307+vol_1
  7956 00:200E: 82 48 FF     	brl	L309
  7957                        ;}
  7958             00000011   L306	equ	17
  7959             00000005   L307	equ	5
  7960                        	ends
  7961                        	efunc
  7962                        ;
  7963                        ;
  7964                        ;
  7965                        ;
  7966                        ;/*-----------------------------------------------
                    ------------------------*/
  7967                        ;/* GPT support functions                         
                                            */
  7968                        ;/*-----------------------------------------------
                    ------------------------*/
  7969                        ;
  7970                        ;#if FF_LBA64
  7971                        ;
  7972                        ;/* Calculate CRC32 in byte-by-byte */
  7973                        ;
  7974                        ;static DWORD crc32 (	/* Returns next CRC valu
                    e */
  7975                        ;	DWORD crc,			/* Current CRC v
                    alue */
  7976                        ;	BYTE d				/* A byte to be 
                    processed */
  7977                        ;)
  7978                        ;{
  7979                        ;	BYTE b;
  Thu May 20 2021 21:37                                                Page 166


  7980                        ;
  7981                        ;
  7982                        ;	for (b = 1; b; b <<= 1) {
  7983                        ;		crc ^= (d & b) ? 1 : 0;
  7984                        ;		crc = (crc & 1) ? crc >> 1 ^ 0xEDB88320 
                    : crc >> 1;
  7985                        ;	}
  7986                        ;	return crc;
  7987                        ;}
  7988                        ;
  7989                        ;
  7990                        ;/* Check validity of GPT header */
  7991                        ;
  7992                        ;static int test_gpt_header (	/* 0:Invalid, 1:
                    Valid */
  7993                        ;	const BYTE* gpth			/* Point
                    er to the GPT header */
  7994                        ;)
  7995                        ;{
  7996                        ;	UINT i;
  7997                        ;	DWORD bcc;
  7998                        ;
  7999                        ;
  8000                        ;	if (memcmp(gpth + GPTH_Sign, "EFI PART" "\0\0\1\
                    0" "\x5C\0\0", 16)) return 0;	/* Check sign, version (
                    1.0) and length (92) */
  8001                        ;	for (i = 0, bcc = 0xFFFFFFFF; i < 92; i++) {	
                    	/* Check header BCC */
  8002                        ;		bcc = crc32(bcc, i - GPTH_Bcc < 4 ? 0 : 
                    gpth[i]);
  8003                        ;	}
  8004                        ;	if (~bcc != ld_dword(gpth + GPTH_Bcc)) return 0;
  8005                        ;	if (ld_dword(gpth + GPTH_PteSize) != SZ_GPTE) re
                    turn 0;	/* Table entry size (must be SZ_GPTE bytes) */
  8006                        ;	if (ld_dword(gpth + GPTH_PtNum) > 128) return 0;
                    	/* Table size (must be 128 entries or less) */
  8007                        ;
  8008                        ;	return 1;
  8009                        ;}
  8010                        ;
  8011                        ;#if !FF_FS_READONLY && FF_USE_MKFS
  8012                        ;
  8013                        ;/* Generate random value */
  8014                        ;static DWORD make_rand (
  8015                        ;	DWORD seed,		/* Seed value */
  8016                        ;	BYTE* buff,		/* Output buffer */
  8017                        ;	UINT n			/* Data length */
  8018                        ;)
  8019                        ;{
  8020                        ;	UINT r;
  8021                        ;
  8022                        ;
  8023                        ;	if (seed == 0) seed = 1;
  8024                        ;	do {
  8025                        ;		for (r = 0; r < 8; r++) seed = seed & 1 
                    ? seed >> 1 ^ 0xA3000000 : seed >> 1;	/* Shift 8 bits 
                    the 32-bit LFSR */
  8026                        ;		*buff++ = (BYTE)seed;
  Thu May 20 2021 21:37                                                Page 167


  8027                        ;	} while (--n);
  8028                        ;	return seed;
  8029                        ;}
  8030                        ;
  8031                        ;#endif
  8032                        ;#endif
  8033                        ;
  8034                        ;
  8035                        ;
  8036                        ;/*-----------------------------------------------
                    ------------------------*/
  8037                        ;/* Load a sector and check if it is an FAT VBR   
                                            */
  8038                        ;/*-----------------------------------------------
                    ------------------------*/
  8039                        ;
  8040                        ;/* Check what the sector is */
  8041                        ;
  8042                        ;static UINT check_fs (	/* 0:FAT/FAT32 VBR, 1:ex
                    FAT VBR, 2:Not FAT and valid BS, 3:Not FAT and invalid BS, 4
                    :Disk error */
  8043                        ;	FATFS* fs,			/* Filesystem ob
                    ject */
  8044                        ;	LBA_t sect			/* Sector to loa
                    d and check if it is an FAT-VBR or not */
  8045                        ;)
  8046                        ;{
  8047                        	code
  8048                        	func
  8049                        ~~check_fs:
  8050                        	longa	on
  8051                        	longi	on
  8052 00:2011: 3B           	tsc
  8053 00:2012: 38           	sec
  8054 00:2013: E9 19 00     	sbc	#L320
  8055 00:2016: 1B           	tcs
  8056 00:2017: 0B           	phd
  8057 00:2018: 5B           	tcd
  8058             00000004   fs_0	set	4
  8059             00000008   sect_0	set	8
  8060                        ;	WORD w, sign;
  8061                        ;	BYTE b;
  8062                        ;
  8063                        ;
  8064                        ;	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;	
                    	/* Invaidate window */
  8065             00000000   w_1	set	0
  8066             00000002   sign_1	set	2
  8067             00000004   b_1	set	4
  8068 00:2019: E2 20        	sep	#$20
  8069                        	longa	off
  8070 00:201B: A9 00        	lda	#$0
  8071 00:201D: A0 03 00     	ldy	#$3
  8072 00:2020: 97 1D        	sta	[<L320+fs_0],Y
  8073 00:2022: C2 20        	rep	#$20
  8074                        	longa	on
  8075 00:2024: A9 FF FF     	lda	#$ffff
  8076 00:2027: A0 2B 00     	ldy	#$2b
  Thu May 20 2021 21:37                                                Page 168


  8077 00:202A: 97 1D        	sta	[<L320+fs_0],Y
  8078 00:202C: A9 FF FF     	lda	#$ffff
  8079 00:202F: A0 2D 00     	ldy	#$2d
  8080 00:2032: 97 1D        	sta	[<L320+fs_0],Y
  8081                        ;	if (move_window(fs, sect) != FR_OK) return 4;	
                    /* Load the boot sector */
  8082 00:2034: D4 23        	pei	<L320+sect_0+2
  8083 00:2036: D4 21        	pei	<L320+sect_0
  8084 00:2038: D4 1F        	pei	<L320+fs_0+2
  8085 00:203A: D4 1D        	pei	<L320+fs_0
  8086 00:203C: 22 xx xx xx  	jsl	~~move_window
  8087 00:2040: AA           	tax
  8088 00:2041: D0 03        	bne	L322
  8089 00:2043: 82 15 00     	brl	L10156
  8090                        L322:
  8091 00:2046: A9 04 00     	lda	#$4
  8092                        L323:
  8093 00:2049: A8           	tay
  8094 00:204A: A5 1B        	lda	<L320+2
  8095 00:204C: 85 23        	sta	<L320+2+8
  8096 00:204E: A5 1A        	lda	<L320+1
  8097 00:2050: 85 22        	sta	<L320+1+8
  8098 00:2052: 2B           	pld
  8099 00:2053: 3B           	tsc
  8100 00:2054: 18           	clc
  8101 00:2055: 69 21 00     	adc	#L320+8
  8102 00:2058: 1B           	tcs
  8103 00:2059: 98           	tya
  8104 00:205A: 6B           	rtl
  8105                        ;	sign = ld_word(fs->win + BS_55AA);
  8106                        L10156:
  8107 00:205B: 18           	clc
  8108 00:205C: A9 2D 02     	lda	#$22d
  8109 00:205F: 65 1D        	adc	<L320+fs_0
  8110 00:2061: 85 01        	sta	<R0
  8111 00:2063: A9 00 00     	lda	#$0
  8112 00:2066: 65 1F        	adc	<L320+fs_0+2
  8113 00:2068: 85 03        	sta	<R0+2
  8114 00:206A: D4 03        	pei	<R0+2
  8115 00:206C: D4 01        	pei	<R0
  8116 00:206E: 22 xx xx xx  	jsl	~~ld_word
  8117 00:2072: 85 17        	sta	<L321+sign_1
  8118                        ;#if FF_FS_EXFAT
  8119                        ;	if (sign == 0xAA55 && !memcmp(fs->win + BS_JmpBo
                    ot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* It is
                     an exFAT VBR */
  8120                        ;#endif
  8121                        ;	b = fs->win[BS_JmpBoot];
  8122 00:2074: E2 20        	sep	#$20
  8123                        	longa	off
  8124 00:2076: A0 2F 00     	ldy	#$2f
  8125 00:2079: B7 1D        	lda	[<L320+fs_0],Y
  8126 00:207B: 85 19        	sta	<L321+b_1
  8127 00:207D: C2 20        	rep	#$20
  8128                        	longa	on
  8129                        ;	if (b == 0xEB || b == 0xE9 || b == 0xE8) {	
                    /* Valid JumpBoot code? (short jump, near jump or near call)
                     */
  Thu May 20 2021 21:37                                                Page 169


  8130 00:207F: E2 20        	sep	#$20
  8131                        	longa	off
  8132 00:2081: A5 19        	lda	<L321+b_1
  8133 00:2083: C9 EB        	cmp	#<$eb
  8134 00:2085: C2 20        	rep	#$20
  8135                        	longa	on
  8136 00:2087: D0 03        	bne	L325
  8137 00:2089: 82 1A 00     	brl	L324
  8138                        L325:
  8139 00:208C: E2 20        	sep	#$20
  8140                        	longa	off
  8141 00:208E: A5 19        	lda	<L321+b_1
  8142 00:2090: C9 E9        	cmp	#<$e9
  8143 00:2092: C2 20        	rep	#$20
  8144                        	longa	on
  8145 00:2094: D0 03        	bne	L326
  8146 00:2096: 82 0D 00     	brl	L324
  8147                        L326:
  8148 00:2099: E2 20        	sep	#$20
  8149                        	longa	off
  8150 00:209B: A5 19        	lda	<L321+b_1
  8151 00:209D: C9 E8        	cmp	#<$e8
  8152 00:209F: C2 20        	rep	#$20
  8153                        	longa	on
  8154 00:20A1: F0 03        	beq	L327
  8155 00:20A3: 82 6E 01     	brl	L10157
  8156                        L327:
  8157                        L324:
  8158                        ;		if (sign == 0xAA55 && !memcmp(fs->win + 
                    BS_FilSysType32, "FAT32   ", 8)) {
  8159 00:20A6: A5 17        	lda	<L321+sign_1
  8160 00:20A8: C9 55 AA     	cmp	#<$aa55
  8161 00:20AB: F0 03        	beq	L328
  8162 00:20AD: 82 2C 00     	brl	L10158
  8163                        L328:
  8164 00:20B0: F4 08 00     	pea	#<$8
  8165 00:20B3: F4 xx xx     	pea	#^L289
  8166 00:20B6: F4 xx xx     	pea	#<L289
  8167 00:20B9: 18           	clc
  8168 00:20BA: A9 81 00     	lda	#$81
  8169 00:20BD: 65 1D        	adc	<L320+fs_0
  8170 00:20BF: 85 01        	sta	<R0
  8171 00:20C1: A9 00 00     	lda	#$0
  8172 00:20C4: 65 1F        	adc	<L320+fs_0+2
  8173 00:20C6: 85 03        	sta	<R0+2
  8174 00:20C8: D4 03        	pei	<R0+2
  8175 00:20CA: D4 01        	pei	<R0
  8176 00:20CC: 22 xx xx xx  	jsl	~~memcmp
  8177 00:20D0: AA           	tax
  8178 00:20D1: F0 03        	beq	L329
  8179 00:20D3: 82 06 00     	brl	L10158
  8180                        L329:
  8181                        ;			return 0;	/* It is an FAT3
                    2 VBR */
  8182 00:20D6: A9 00 00     	lda	#$0
  8183 00:20D9: 82 6D FF     	brl	L323
  8184                        ;		}
  8185                        ;		/* FAT volumes formatted with early MS-D
  Thu May 20 2021 21:37                                                Page 170


                    OS lack BS_55AA and BS_FilSysType, so FAT VBR needs to be id
                    entified without them. */
  8186                        ;		w = ld_word(fs->win + BPB_BytsPerSec);
  8187                        L10158:
  8188 00:20DC: 18           	clc
  8189 00:20DD: A9 3A 00     	lda	#$3a
  8190 00:20E0: 65 1D        	adc	<L320+fs_0
  8191 00:20E2: 85 01        	sta	<R0
  8192 00:20E4: A9 00 00     	lda	#$0
  8193 00:20E7: 65 1F        	adc	<L320+fs_0+2
  8194 00:20E9: 85 03        	sta	<R0+2
  8195 00:20EB: D4 03        	pei	<R0+2
  8196 00:20ED: D4 01        	pei	<R0
  8197 00:20EF: 22 xx xx xx  	jsl	~~ld_word
  8198 00:20F3: 85 15        	sta	<L321+w_1
  8199                        ;		b = fs->win[BPB_SecPerClus];
  8200 00:20F5: E2 20        	sep	#$20
  8201                        	longa	off
  8202 00:20F7: A0 3C 00     	ldy	#$3c
  8203 00:20FA: B7 1D        	lda	[<L320+fs_0],Y
  8204 00:20FC: 85 19        	sta	<L321+b_1
  8205 00:20FE: C2 20        	rep	#$20
  8206                        	longa	on
  8207                        ;		if ((w & (w - 1)) == 0 && w >= FF_MIN_SS
                     && w <= FF_MAX_SS	/* Properness of sector size (512-4096 a
                    nd 2^n) */
  8208                        ;			&& b != 0 && (b & (b - 1)) == 0	
                    			/* Properness of cluster size (2^n) */
  8209                        ;			&& ld_word(fs->win + BPB_RsvdSec
                    Cnt) != 0	/* Properness of reserved sectors (MNBZ) */
  8210                        ;			&& (UINT)fs->win[BPB_NumFATs] - 
                    1 <= 1		/* Properness of FATs (1 or 2) */
  8211                        ;			&& ld_word(fs->win + BPB_RootEnt
                    Cnt) != 0	/* Properness of root dir entries (MNBZ) */
  8212                        ;			&& (ld_word(fs->win + BPB_TotSec
                    16) >= 128 || ld_dword(fs->win + BPB_TotSec32) >= 0x10000)	
                    /* Properness of volume sectors (>=128) */
  8213                        ;			&& ld_word(fs->win + BPB_FATSz16
                    ) != 0) {	/* Properness of FAT size (MNBZ) */
  8214 00:2100: 18           	clc
  8215 00:2101: A9 FF FF     	lda	#$ffff
  8216 00:2104: 65 15        	adc	<L321+w_1
  8217 00:2106: 85 01        	sta	<R0
  8218 00:2108: A5 15        	lda	<L321+w_1
  8219 00:210A: 25 01        	and	<R0
  8220 00:210C: F0 03        	beq	L330
  8221 00:210E: 82 03 01     	brl	L10159
  8222                        L330:
  8223 00:2111: A5 15        	lda	<L321+w_1
  8224 00:2113: C9 00 02     	cmp	#<$200
  8225 00:2116: B0 03        	bcs	L331
  8226 00:2118: 82 F9 00     	brl	L10159
  8227                        L331:
  8228 00:211B: A9 00 02     	lda	#$200
  8229 00:211E: C5 15        	cmp	<L321+w_1
  8230 00:2120: B0 03        	bcs	L332
  8231 00:2122: 82 EF 00     	brl	L10159
  8232                        L332:
  Thu May 20 2021 21:37                                                Page 171


  8233 00:2125: A5 19        	lda	<L321+b_1
  8234 00:2127: 29 FF 00     	and	#$ff
  8235 00:212A: D0 03        	bne	L333
  8236 00:212C: 82 E5 00     	brl	L10159
  8237                        L333:
  8238 00:212F: A5 19        	lda	<L321+b_1
  8239 00:2131: 29 FF 00     	and	#$ff
  8240 00:2134: 85 01        	sta	<R0
  8241 00:2136: A5 19        	lda	<L321+b_1
  8242 00:2138: 29 FF 00     	and	#$ff
  8243 00:213B: 85 05        	sta	<R1
  8244 00:213D: 18           	clc
  8245 00:213E: A9 FF FF     	lda	#$ffff
  8246 00:2141: 65 05        	adc	<R1
  8247 00:2143: 85 09        	sta	<R2
  8248 00:2145: A5 09        	lda	<R2
  8249 00:2147: 25 01        	and	<R0
  8250 00:2149: F0 03        	beq	L334
  8251 00:214B: 82 C6 00     	brl	L10159
  8252                        L334:
  8253 00:214E: 18           	clc
  8254 00:214F: A9 3D 00     	lda	#$3d
  8255 00:2152: 65 1D        	adc	<L320+fs_0
  8256 00:2154: 85 01        	sta	<R0
  8257 00:2156: A9 00 00     	lda	#$0
  8258 00:2159: 65 1F        	adc	<L320+fs_0+2
  8259 00:215B: 85 03        	sta	<R0+2
  8260 00:215D: D4 03        	pei	<R0+2
  8261 00:215F: D4 01        	pei	<R0
  8262 00:2161: 22 xx xx xx  	jsl	~~ld_word
  8263 00:2165: AA           	tax
  8264 00:2166: D0 03        	bne	L335
  8265 00:2168: 82 A9 00     	brl	L10159
  8266                        L335:
  8267 00:216B: A0 3F 00     	ldy	#$3f
  8268 00:216E: B7 1D        	lda	[<L320+fs_0],Y
  8269 00:2170: 29 FF 00     	and	#$ff
  8270 00:2173: 85 05        	sta	<R1
  8271 00:2175: 18           	clc
  8272 00:2176: A9 FF FF     	lda	#$ffff
  8273 00:2179: 65 05        	adc	<R1
  8274 00:217B: 85 09        	sta	<R2
  8275 00:217D: A9 01 00     	lda	#$1
  8276 00:2180: C5 09        	cmp	<R2
  8277 00:2182: B0 03        	bcs	L336
  8278 00:2184: 82 8D 00     	brl	L10159
  8279                        L336:
  8280 00:2187: 18           	clc
  8281 00:2188: A9 40 00     	lda	#$40
  8282 00:218B: 65 1D        	adc	<L320+fs_0
  8283 00:218D: 85 05        	sta	<R1
  8284 00:218F: A9 00 00     	lda	#$0
  8285 00:2192: 65 1F        	adc	<L320+fs_0+2
  8286 00:2194: 85 07        	sta	<R1+2
  8287 00:2196: D4 07        	pei	<R1+2
  8288 00:2198: D4 05        	pei	<R1
  8289 00:219A: 22 xx xx xx  	jsl	~~ld_word
  8290 00:219E: AA           	tax
  Thu May 20 2021 21:37                                                Page 172


  8291 00:219F: D0 03        	bne	L337
  8292 00:21A1: 82 70 00     	brl	L10159
  8293                        L337:
  8294 00:21A4: 18           	clc
  8295 00:21A5: A9 42 00     	lda	#$42
  8296 00:21A8: 65 1D        	adc	<L320+fs_0
  8297 00:21AA: 85 09        	sta	<R2
  8298 00:21AC: A9 00 00     	lda	#$0
  8299 00:21AF: 65 1F        	adc	<L320+fs_0+2
  8300 00:21B1: 85 0B        	sta	<R2+2
  8301 00:21B3: D4 0B        	pei	<R2+2
  8302 00:21B5: D4 09        	pei	<R2
  8303 00:21B7: 22 xx xx xx  	jsl	~~ld_word
  8304 00:21BB: 85 0D        	sta	<R3
  8305 00:21BD: A5 0D        	lda	<R3
  8306 00:21BF: C9 80 00     	cmp	#<$80
  8307 00:21C2: 90 03        	bcc	L339
  8308 00:21C4: 82 2A 00     	brl	L338
  8309                        L339:
  8310 00:21C7: 18           	clc
  8311 00:21C8: A9 4F 00     	lda	#$4f
  8312 00:21CB: 65 1D        	adc	<L320+fs_0
  8313 00:21CD: 85 0D        	sta	<R3
  8314 00:21CF: A9 00 00     	lda	#$0
  8315 00:21D2: 65 1F        	adc	<L320+fs_0+2
  8316 00:21D4: 85 0F        	sta	<R3+2
  8317 00:21D6: D4 0F        	pei	<R3+2
  8318 00:21D8: D4 0D        	pei	<R3
  8319 00:21DA: 22 xx xx xx  	jsl	~~ld_dword
  8320 00:21DE: 85 11        	sta	<17
  8321 00:21E0: 86 13        	stx	<17+2
  8322 00:21E2: A5 11        	lda	<17
  8323 00:21E4: C9 00 00     	cmp	#<$10000
  8324 00:21E7: A5 13        	lda	<17+2
  8325 00:21E9: E9 01 00     	sbc	#^$10000
  8326 00:21EC: B0 03        	bcs	L340
  8327 00:21EE: 82 23 00     	brl	L10159
  8328                        L340:
  8329                        L338:
  8330 00:21F1: 18           	clc
  8331 00:21F2: A9 45 00     	lda	#$45
  8332 00:21F5: 65 1D        	adc	<L320+fs_0
  8333 00:21F7: 85 11        	sta	<17
  8334 00:21F9: A9 00 00     	lda	#$0
  8335 00:21FC: 65 1F        	adc	<L320+fs_0+2
  8336 00:21FE: 85 13        	sta	<17+2
  8337 00:2200: D4 13        	pei	<17+2
  8338 00:2202: D4 11        	pei	<17
  8339 00:2204: 22 xx xx xx  	jsl	~~ld_word
  8340 00:2208: AA           	tax
  8341 00:2209: D0 03        	bne	L341
  8342 00:220B: 82 06 00     	brl	L10159
  8343                        L341:
  8344                        ;				return 0;	/* It ca
                    n be presumed an FAT VBR */
  8345 00:220E: A9 00 00     	lda	#$0
  8346 00:2211: 82 35 FE     	brl	L323
  8347                        ;		}
  Thu May 20 2021 21:37                                                Page 173


  8348                        ;	}
  8349                        L10159:
  8350                        ;	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VB
                    R (valid or invalid BS) */
  8351                        L10157:
  8352 00:2214: A5 17        	lda	<L321+sign_1
  8353 00:2216: C9 55 AA     	cmp	#<$aa55
  8354 00:2219: F0 03        	beq	L343
  8355 00:221B: 82 05 00     	brl	L342
  8356                        L343:
  8357 00:221E: A9 02 00     	lda	#$2
  8358 00:2221: 80 03        	bra	L344
  8359                        L342:
  8360 00:2223: A9 03 00     	lda	#$3
  8361                        L344:
  8362 00:2226: 82 20 FE     	brl	L323
  8363                        ;}
  8364             00000019   L320	equ	25
  8365             00000015   L321	equ	21
  8366                        	ends
  8367                        	efunc
  8368                        	data
  8369                        L289:
  8370 00:008F: 46 41 54 33  	db	$46,$41,$54,$33,$32,$20,$20,$20,$00
       00:0093: 32 20 20 20 
       00:0097: 00 
  8371 00:0098:              	ends
  8372                        ;
  8373                        ;
  8374                        ;/* Find an FAT volume */
  8375                        ;/* (It supports only generic partitioning rules, 
                    MBR, GPT and SFD) */
  8376                        ;
  8377                        ;static UINT find_volume (	/* Returns BS st
                    atus found in the hosting drive */
  8378                        ;	FATFS* fs,		/* Filesystem object */
  8379                        ;	UINT part		/* Partition to fined = 
                    0:auto, 1..:forced */
  8380                        ;)
  8381                        ;{
  8382                        	code
  8383                        	func
  8384                        ~~find_volume:
  8385                        	longa	on
  8386                        	longi	on
  8387 00:2229: 3B           	tsc
  8388 00:222A: 38           	sec
  8389 00:222B: E9 28 00     	sbc	#L346
  8390 00:222E: 1B           	tcs
  8391 00:222F: 0B           	phd
  8392 00:2230: 5B           	tcd
  8393             00000004   fs_0	set	4
  8394             00000008   part_0	set	8
  8395                        ;	UINT fmt, i;
  8396                        ;	DWORD mbr_pt[4];
  8397                        ;
  8398                        ;
  8399                        ;	fmt = check_fs(fs, 0);				
  Thu May 20 2021 21:37                                                Page 174


                    /* Load sector 0 and check if it is an FAT VBR as SFD format
                     */
  8400             00000000   fmt_1	set	0
  8401             00000002   i_1	set	2
  8402             00000004   mbr_pt_1	set	4
  8403 00:2231: F4 00 00     	pea	#^$0
  8404 00:2234: F4 00 00     	pea	#<$0
  8405 00:2237: D4 2E        	pei	<L346+fs_0+2
  8406 00:2239: D4 2C        	pei	<L346+fs_0
  8407 00:223B: 22 xx xx xx  	jsl	~~check_fs
  8408 00:223F: 85 15        	sta	<L347+fmt_1
  8409                        ;	if (fmt != 2 && (fmt >= 3 || part == 0)) return 
                    fmt;	/* Returns if it is an FAT VBR as auto scan, not
                     a BS or disk error */
  8410 00:2241: A5 15        	lda	<L347+fmt_1
  8411 00:2243: C9 02 00     	cmp	#<$2
  8412 00:2246: D0 03        	bne	L348
  8413 00:2248: 82 25 00     	brl	L10160
  8414                        L348:
  8415 00:224B: A5 15        	lda	<L347+fmt_1
  8416 00:224D: C9 03 00     	cmp	#<$3
  8417 00:2250: 90 03        	bcc	L350
  8418 00:2252: 82 07 00     	brl	L349
  8419                        L350:
  8420 00:2255: A5 30        	lda	<L346+part_0
  8421 00:2257: F0 03        	beq	L351
  8422 00:2259: 82 14 00     	brl	L10160
  8423                        L351:
  8424                        L349:
  8425 00:225C: A5 15        	lda	<L347+fmt_1
  8426                        L352:
  8427 00:225E: A8           	tay
  8428 00:225F: A5 2A        	lda	<L346+2
  8429 00:2261: 85 30        	sta	<L346+2+6
  8430 00:2263: A5 29        	lda	<L346+1
  8431 00:2265: 85 2F        	sta	<L346+1+6
  8432 00:2267: 2B           	pld
  8433 00:2268: 3B           	tsc
  8434 00:2269: 18           	clc
  8435 00:226A: 69 2E 00     	adc	#L346+6
  8436 00:226D: 1B           	tcs
  8437 00:226E: 98           	tya
  8438 00:226F: 6B           	rtl
  8439                        ;
  8440                        ;	/* Sector 0 is not an FAT VBR or forced partitio
                    n number wants a partition */
  8441                        ;
  8442                        ;#if FF_LBA64
  8443                        ;	if (fs->win[MBR_Table + PTE_System] == 0xEE) {	
                    /* GPT protective MBR? */
  8444                        ;		DWORD n_ent, v_ent, ofs;
  8445                        ;		QWORD pt_lba;
  8446                        ;
  8447                        ;		if (move_window(fs, 1) != FR_OK) return 
                    4;	/* Load GPT header sector (next to MBR) */
  8448                        ;		if (!test_gpt_header(fs->win)) return 3;
                    	/* Check if GPT header is valid */
  8449                        ;		n_ent = ld_dword(fs->win + GPTH_PtNum);	
  Thu May 20 2021 21:37                                                Page 175


                    	/* Number of entries */
  8450                        ;		pt_lba = ld_qword(fs->win + GPTH_PtOfs);
                    	/* Table location */
  8451                        ;		for (v_ent = i = 0; i < n_ent; i++) {	
                    	/* Find FAT partition */
  8452                        ;			if (move_window(fs, pt_lba + i *
                     SZ_GPTE / SS(fs)) != FR_OK) return 4;	/* PT sector */
  8453                        ;			ofs = i * SZ_GPTE % SS(fs);	
                    								
                    			/* Offset in the sector */
  8454                        ;			if (!memcmp(fs->win + ofs + GPTE
                    _PtGuid, GUID_MS_Basic, 16)) {	/* MS basic data partiti
                    on? */
  8455                        ;				v_ent++;
  8456                        ;				fmt = check_fs(fs, ld_qw
                    ord(fs->win + ofs + GPTE_FstLba));	/* Load VBR and check st
                    atus */
  8457                        ;				if (part == 0 && fmt <= 
                    1) return fmt;			/* Auto search (valid FA
                    T volume found first) */
  8458                        ;				if (part != 0 && v_ent =
                    = part) return fmt;		/* Forced partition order (regar
                    dless of it is valid or not) */
  8459                        ;			}
  8460                        ;		}
  8461                        ;		return 3;	/* Not found */
  8462                        ;	}
  8463                        ;#endif
  8464                        ;	if (FF_MULTI_PARTITION && part > 4) return 3;	
                    /* MBR has 4 partitions max */
  8465                        L10160:
  8466 00:2270: 82 10 00     	brl	L10161
  8467 00:2273: A9 04 00     	lda	#$4
  8468 00:2276: C5 30        	cmp	<L346+part_0
  8469 00:2278: 90 03        	bcc	L353
  8470 00:227A: 82 06 00     	brl	L10161
  8471                        L353:
  8472 00:227D: A9 03 00     	lda	#$3
  8473 00:2280: 82 DB FF     	brl	L352
  8474                        ;	for (i = 0; i < 4; i++) {		/* Load 
                    partition offset in the MBR */
  8475                        L10161:
  8476 00:2283: 64 17        	stz	<L347+i_1
  8477 00:2285: 82 02 00     	brl	L10163
  8478                        L10162:
  8479 00:2288: E6 17        	inc	<L347+i_1
  8480                        L10163:
  8481 00:228A: A5 17        	lda	<L347+i_1
  8482 00:228C: C9 04 00     	cmp	#<$4
  8483 00:228F: 90 03        	bcc	L354
  8484 00:2291: 82 72 00     	brl	L10164
  8485                        L354:
  8486                        ;		mbr_pt[i] = ld_dword(fs->win + MBR_Table
                     + i * SZ_PTE + PTE_StLba);
  8487 00:2294: A5 17        	lda	<L347+i_1
  8488 00:2296: 85 05        	sta	<R1
  8489 00:2298: 64 07        	stz	<R1+2
  8490 00:229A: D4 07        	pei	<R1+2
  Thu May 20 2021 21:37                                                Page 176


  8491 00:229C: D4 05        	pei	<R1
  8492 00:229E: A9 02 00     	lda	#$2
  8493                        	xref	~~~lasl
  8494 00:22A1: 22 xx xx xx  	jsl	~~~lasl
  8495 00:22A5: 85 01        	sta	<R0
  8496 00:22A7: 86 03        	stx	<R0+2
  8497 00:22A9: 18           	clc
  8498 00:22AA: 7B           	tdc
  8499 00:22AB: 69 19 00     	adc	#<L347+mbr_pt_1
  8500 00:22AE: 85 09        	sta	<R2
  8501 00:22B0: A9 00 00     	lda	#$0
  8502 00:22B3: 85 0B        	sta	<R2+2
  8503 00:22B5: 18           	clc
  8504 00:22B6: A5 09        	lda	<R2
  8505 00:22B8: 65 01        	adc	<R0
  8506 00:22BA: 85 0D        	sta	<R3
  8507 00:22BC: A5 0B        	lda	<R2+2
  8508 00:22BE: 65 03        	adc	<R0+2
  8509 00:22C0: 85 0F        	sta	<R3+2
  8510 00:22C2: A5 17        	lda	<L347+i_1
  8511 00:22C4: 0A           	asl	A
  8512 00:22C5: 0A           	asl	A
  8513 00:22C6: 0A           	asl	A
  8514 00:22C7: 0A           	asl	A
  8515 00:22C8: 85 01        	sta	<R0
  8516 00:22CA: A5 01        	lda	<R0
  8517 00:22CC: 85 01        	sta	<R0
  8518 00:22CE: 64 03        	stz	<R0+2
  8519 00:22D0: 18           	clc
  8520 00:22D1: A9 F5 01     	lda	#$1f5
  8521 00:22D4: 65 01        	adc	<R0
  8522 00:22D6: 85 09        	sta	<R2
  8523 00:22D8: A9 00 00     	lda	#$0
  8524 00:22DB: 65 03        	adc	<R0+2
  8525 00:22DD: 85 0B        	sta	<R2+2
  8526 00:22DF: 18           	clc
  8527 00:22E0: A5 2C        	lda	<L346+fs_0
  8528 00:22E2: 65 09        	adc	<R2
  8529 00:22E4: 85 01        	sta	<R0
  8530 00:22E6: A5 2E        	lda	<L346+fs_0+2
  8531 00:22E8: 65 0B        	adc	<R2+2
  8532 00:22EA: 85 03        	sta	<R0+2
  8533 00:22EC: D4 03        	pei	<R0+2
  8534 00:22EE: D4 01        	pei	<R0
  8535 00:22F0: 22 xx xx xx  	jsl	~~ld_dword
  8536 00:22F4: 85 11        	sta	<17
  8537 00:22F6: 86 13        	stx	<17+2
  8538 00:22F8: A5 11        	lda	<17
  8539 00:22FA: 87 0D        	sta	[<R3]
  8540 00:22FC: A5 13        	lda	<17+2
  8541 00:22FE: A0 02 00     	ldy	#$2
  8542 00:2301: 97 0D        	sta	[<R3],Y
  8543                        ;	}
  8544 00:2303: 82 82 FF     	brl	L10162
  8545                        L10164:
  8546                        ;	i = part ? part - 1 : 0;		/* Table
                     index to find first */
  8547 00:2306: A5 30        	lda	<L346+part_0
  Thu May 20 2021 21:37                                                Page 177


  8548 00:2308: D0 03        	bne	L356
  8549 00:230A: 82 08 00     	brl	L355
  8550                        L356:
  8551 00:230D: 18           	clc
  8552 00:230E: A9 FF FF     	lda	#$ffff
  8553 00:2311: 65 30        	adc	<L346+part_0
  8554 00:2313: 80 03        	bra	L357
  8555                        L355:
  8556 00:2315: A9 00 00     	lda	#$0
  8557                        L357:
  8558 00:2318: 85 17        	sta	<L347+i_1
  8559                        ;	do {						
                    	/* Find an FAT volume */
  8560                        L10167:
  8561                        ;		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]
                    ) : 3;	/* Check if the partition is FAT */
  8562 00:231A: A5 17        	lda	<L347+i_1
  8563 00:231C: 85 05        	sta	<R1
  8564 00:231E: 64 07        	stz	<R1+2
  8565 00:2320: D4 07        	pei	<R1+2
  8566 00:2322: D4 05        	pei	<R1
  8567 00:2324: A9 02 00     	lda	#$2
  8568                        	xref	~~~lasl
  8569 00:2327: 22 xx xx xx  	jsl	~~~lasl
  8570 00:232B: 85 01        	sta	<R0
  8571 00:232D: 86 03        	stx	<R0+2
  8572 00:232F: 18           	clc
  8573 00:2330: 7B           	tdc
  8574 00:2331: 69 19 00     	adc	#<L347+mbr_pt_1
  8575 00:2334: 85 09        	sta	<R2
  8576 00:2336: A9 00 00     	lda	#$0
  8577 00:2339: 85 0B        	sta	<R2+2
  8578 00:233B: 18           	clc
  8579 00:233C: A5 09        	lda	<R2
  8580 00:233E: 65 01        	adc	<R0
  8581 00:2340: 85 0D        	sta	<R3
  8582 00:2342: A5 0B        	lda	<R2+2
  8583 00:2344: 65 03        	adc	<R0+2
  8584 00:2346: 85 0F        	sta	<R3+2
  8585 00:2348: A7 0D        	lda	[<R3]
  8586 00:234A: A0 02 00     	ldy	#$2
  8587 00:234D: 17 0D        	ora	[<R3],Y
  8588 00:234F: D0 03        	bne	L359
  8589 00:2351: 82 41 00     	brl	L358
  8590                        L359:
  8591 00:2354: A5 17        	lda	<L347+i_1
  8592 00:2356: 85 09        	sta	<R2
  8593 00:2358: 64 0B        	stz	<R2+2
  8594 00:235A: D4 0B        	pei	<R2+2
  8595 00:235C: D4 09        	pei	<R2
  8596 00:235E: A9 02 00     	lda	#$2
  8597                        	xref	~~~lasl
  8598 00:2361: 22 xx xx xx  	jsl	~~~lasl
  8599 00:2365: 85 01        	sta	<R0
  8600 00:2367: 86 03        	stx	<R0+2
  8601 00:2369: 18           	clc
  8602 00:236A: 7B           	tdc
  8603 00:236B: 69 19 00     	adc	#<L347+mbr_pt_1
  Thu May 20 2021 21:37                                                Page 178


  8604 00:236E: 85 0D        	sta	<R3
  8605 00:2370: A9 00 00     	lda	#$0
  8606 00:2373: 85 0F        	sta	<R3+2
  8607 00:2375: 18           	clc
  8608 00:2376: A5 0D        	lda	<R3
  8609 00:2378: 65 01        	adc	<R0
  8610 00:237A: 85 11        	sta	<17
  8611 00:237C: A5 0F        	lda	<R3+2
  8612 00:237E: 65 03        	adc	<R0+2
  8613 00:2380: 85 13        	sta	<17+2
  8614 00:2382: A0 02 00     	ldy	#$2
  8615 00:2385: B7 11        	lda	[<17],Y
  8616 00:2387: 48           	pha
  8617 00:2388: A7 11        	lda	[<17]
  8618 00:238A: 48           	pha
  8619 00:238B: D4 2E        	pei	<L346+fs_0+2
  8620 00:238D: D4 2C        	pei	<L346+fs_0
  8621 00:238F: 22 xx xx xx  	jsl	~~check_fs
  8622 00:2393: 80 03        	bra	L360
  8623                        L358:
  8624 00:2395: A9 03 00     	lda	#$3
  8625                        L360:
  8626 00:2398: 85 15        	sta	<L347+fmt_1
  8627                        ;	} while (part == 0 && fmt >= 2 && ++i < 4);
  8628                        L10165:
  8629 00:239A: A5 30        	lda	<L346+part_0
  8630 00:239C: F0 03        	beq	L362
  8631 00:239E: 82 16 00     	brl	L361
  8632                        L362:
  8633 00:23A1: A5 15        	lda	<L347+fmt_1
  8634 00:23A3: C9 02 00     	cmp	#<$2
  8635 00:23A6: B0 03        	bcs	L363
  8636 00:23A8: 82 0C 00     	brl	L361
  8637                        L363:
  8638 00:23AB: E6 17        	inc	<L347+i_1
  8639 00:23AD: A5 17        	lda	<L347+i_1
  8640 00:23AF: C9 04 00     	cmp	#<$4
  8641 00:23B2: B0 03        	bcs	L364
  8642 00:23B4: 82 63 FF     	brl	L10167
  8643                        L364:
  8644                        L361:
  8645                        L10166:
  8646                        ;	return fmt;
  8647 00:23B7: A5 15        	lda	<L347+fmt_1
  8648 00:23B9: 82 A2 FE     	brl	L352
  8649                        ;}
  8650             00000028   L346	equ	40
  8651             00000015   L347	equ	21
  8652                        	ends
  8653                        	efunc
  8654                        ;
  8655                        ;
  8656                        ;
  8657                        ;
  8658                        ;/*-----------------------------------------------
                    ------------------------*/
  8659                        ;/* Determine logical drive number and mount the v
                    olume if needed         */
  Thu May 20 2021 21:37                                                Page 179


  8660                        ;/*-----------------------------------------------
                    ------------------------*/
  8661                        ;
  8662                        ;static FRESULT mount_volume (	/* FR_OK(0): suc
                    cessful, !=0: an error occurred */
  8663                        ;	const TCHAR** path,			/* Point
                    er to pointer to the path name (drive number) */
  8664                        ;	FATFS** rfs,				/* Point
                    er to pointer to the found filesystem object */
  8665                        ;	BYTE mode					
                    /* !=0: Check write protection for write access */
  8666                        ;)
  8667                        ;{
  8668                        	code
  8669                        	func
  8670                        ~~mount_volume:
  8671                        	longa	on
  8672                        	longi	on
  8673 00:23BC: 3B           	tsc
  8674 00:23BD: 38           	sec
  8675 00:23BE: E9 33 00     	sbc	#L365
  8676 00:23C1: 1B           	tcs
  8677 00:23C2: 0B           	phd
  8678 00:23C3: 5B           	tcd
  8679             00000004   path_0	set	4
  8680             00000008   rfs_0	set	8
  8681             0000000C   mode_0	set	12
  8682                        ;	int vol;
  8683                        ;	DSTATUS stat;
  8684                        ;	LBA_t bsect;
  8685                        ;	DWORD tsect, sysect, fasize, nclst, szbfat;
  8686                        ;	WORD nrsv;
  8687                        ;	FATFS *fs;
  8688                        ;	UINT fmt;
  8689                        ;
  8690                        ;
  8691                        ;	/* Get logical drive number */
  8692                        ;	*rfs = 0;
  8693             00000000   vol_1	set	0
  8694             00000002   stat_1	set	2
  8695             00000003   bsect_1	set	3
  8696             00000007   tsect_1	set	7
  8697             0000000B   sysect_1	set	11
  8698             0000000F   fasize_1	set	15
  8699             00000013   nclst_1	set	19
  8700             00000017   szbfat_1	set	23
  8701             0000001B   nrsv_1	set	27
  8702             0000001D   fs_1	set	29
  8703             00000021   fmt_1	set	33
  8704 00:23C4: A9 00 00     	lda	#$0
  8705 00:23C7: 87 3B        	sta	[<L365+rfs_0]
  8706 00:23C9: A9 00 00     	lda	#$0
  8707 00:23CC: A0 02 00     	ldy	#$2
  8708 00:23CF: 97 3B        	sta	[<L365+rfs_0],Y
  8709                        ;	vol = get_ldnumber(path);
  8710 00:23D1: D4 39        	pei	<L365+path_0+2
  8711 00:23D3: D4 37        	pei	<L365+path_0
  8712 00:23D5: 22 xx xx xx  	jsl	~~get_ldnumber
  Thu May 20 2021 21:37                                                Page 180


  8713 00:23D9: 85 11        	sta	<L366+vol_1
  8714                        ;	if (vol < 0) return FR_INVALID_DRIVE;
  8715 00:23DB: A5 11        	lda	<L366+vol_1
  8716 00:23DD: 30 03        	bmi	L367
  8717 00:23DF: 82 15 00     	brl	L10168
  8718                        L367:
  8719 00:23E2: A9 0B 00     	lda	#$b
  8720                        L368:
  8721 00:23E5: A8           	tay
  8722 00:23E6: A5 35        	lda	<L365+2
  8723 00:23E8: 85 3F        	sta	<L365+2+10
  8724 00:23EA: A5 34        	lda	<L365+1
  8725 00:23EC: 85 3E        	sta	<L365+1+10
  8726 00:23EE: 2B           	pld
  8727 00:23EF: 3B           	tsc
  8728 00:23F0: 18           	clc
  8729 00:23F1: 69 3D 00     	adc	#L365+10
  8730 00:23F4: 1B           	tcs
  8731 00:23F5: 98           	tya
  8732 00:23F6: 6B           	rtl
  8733                        ;
  8734                        ;	/* Check if the filesystem object is valid or no
                    t */
  8735                        ;	fs = FatFs[vol];				
                    	/* Get pointer to the filesystem object */
  8736                        L10168:
  8737 00:23F7: A5 11        	lda	<L366+vol_1
  8738 00:23F9: 0A           	asl	A
  8739 00:23FA: 0A           	asl	A
  8740 00:23FB: 85 01        	sta	<R0
  8741 00:23FD: 18           	clc
  8742 00:23FE: A9 xx xx     	lda	#<~~FatFs
  8743 00:2401: 65 01        	adc	<R0
  8744 00:2403: 85 05        	sta	<R1
  8745 00:2405: B2 05        	lda	(<R1)
  8746 00:2407: 85 2E        	sta	<L366+fs_1
  8747 00:2409: A0 02 00     	ldy	#$2
  8748 00:240C: B1 05        	lda	(<R1),Y
  8749 00:240E: 85 30        	sta	<L366+fs_1+2
  8750                        ;	if (!fs) return FR_NOT_ENABLED;		/* Is th
                    e filesystem object available? */
  8751 00:2410: A5 2E        	lda	<L366+fs_1
  8752 00:2412: 05 30        	ora	<L366+fs_1+2
  8753 00:2414: F0 03        	beq	L369
  8754 00:2416: 82 06 00     	brl	L10169
  8755                        L369:
  8756 00:2419: A9 0C 00     	lda	#$c
  8757 00:241C: 82 C6 FF     	brl	L368
  8758                        ;#if FF_FS_REENTRANT
  8759                        ;	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock 
                    the volume */
  8760                        ;#endif
  8761                        ;	*rfs = fs;					
                    		/* Return pointer to the filesystem object */
  8762                        L10169:
  8763 00:241F: A5 2E        	lda	<L366+fs_1
  8764 00:2421: 87 3B        	sta	[<L365+rfs_0]
  8765 00:2423: A5 30        	lda	<L366+fs_1+2
  Thu May 20 2021 21:37                                                Page 181


  8766 00:2425: A0 02 00     	ldy	#$2
  8767 00:2428: 97 3B        	sta	[<L365+rfs_0],Y
  8768                        ;
  8769                        ;	mode &= (BYTE)~FA_READ;				
                    /* Desired access mode, write access or not */
  8770 00:242A: E2 20        	sep	#$20
  8771                        	longa	off
  8772 00:242C: A9 01        	lda	#$1
  8773 00:242E: 14 3F        	trb	<L365+mode_0
  8774 00:2430: C2 20        	rep	#$20
  8775                        	longa	on
  8776                        ;	if (fs->fs_type != 0) {				
                    /* If the volume has been mounted */
  8777 00:2432: A7 2E        	lda	[<L366+fs_1]
  8778 00:2434: 29 FF 00     	and	#$ff
  8779 00:2437: D0 03        	bne	L370
  8780 00:2439: 82 40 00     	brl	L10170
  8781                        L370:
  8782                        ;		stat = disk_status(fs->pdrv);
  8783 00:243C: A0 01 00     	ldy	#$1
  8784 00:243F: B7 2E        	lda	[<L366+fs_1],Y
  8785 00:2441: 48           	pha
  8786 00:2442: 22 xx xx xx  	jsl	~~disk_status
  8787 00:2446: E2 20        	sep	#$20
  8788                        	longa	off
  8789 00:2448: 85 13        	sta	<L366+stat_1
  8790 00:244A: C2 20        	rep	#$20
  8791                        	longa	on
  8792                        ;		if (!(stat & STA_NOINIT)) {		
                    /* and the physical drive is kept initialized */
  8793 00:244C: E2 20        	sep	#$20
  8794                        	longa	off
  8795 00:244E: A5 13        	lda	<L366+stat_1
  8796 00:2450: 29 01        	and	#<$1
  8797 00:2452: C2 20        	rep	#$20
  8798                        	longa	on
  8799 00:2454: F0 03        	beq	L371
  8800 00:2456: 82 23 00     	brl	L10171
  8801                        L371:
  8802                        ;			if (!FF_FS_READONLY && mode && (
                    stat & STA_PROTECT)) {	/* Check write protection if nee
                    ded */
  8803 00:2459: A5 3F        	lda	<L365+mode_0
  8804 00:245B: 29 FF 00     	and	#$ff
  8805 00:245E: D0 03        	bne	L372
  8806 00:2460: 82 13 00     	brl	L10172
  8807                        L372:
  8808 00:2463: E2 20        	sep	#$20
  8809                        	longa	off
  8810 00:2465: A5 13        	lda	<L366+stat_1
  8811 00:2467: 29 04        	and	#<$4
  8812 00:2469: C2 20        	rep	#$20
  8813                        	longa	on
  8814 00:246B: D0 03        	bne	L373
  8815 00:246D: 82 06 00     	brl	L10172
  8816                        L373:
  8817                        ;				return FR_WRITE_PROTECTE
                    D;
  Thu May 20 2021 21:37                                                Page 182


  8818 00:2470: A9 0A 00     	lda	#$a
  8819 00:2473: 82 6F FF     	brl	L368
  8820                        ;			}
  8821                        ;			return FR_OK;			
                    	/* The filesystem object is already valid */
  8822                        L10172:
  8823 00:2476: A9 00 00     	lda	#$0
  8824 00:2479: 82 69 FF     	brl	L368
  8825                        ;		}
  8826                        ;	}
  8827                        L10171:
  8828                        ;
  8829                        ;	/* The filesystem object is not valid. */
  8830                        ;	/* Following code attempts to mount the volume. 
                    (find an FAT volume, analyze the BPB and initialize the file
                    system object) */
  8831                        ;
  8832                        ;	fs->fs_type = 0;				
                    	/* Clear the filesystem object */
  8833                        L10170:
  8834 00:247C: E2 20        	sep	#$20
  8835                        	longa	off
  8836 00:247E: A9 00        	lda	#$0
  8837 00:2480: 87 2E        	sta	[<L366+fs_1]
  8838 00:2482: C2 20        	rep	#$20
  8839                        	longa	on
  8840                        ;	fs->pdrv = LD2PD(vol);				
                    /* Volume hosting physical drive */
  8841 00:2484: E2 20        	sep	#$20
  8842                        	longa	off
  8843 00:2486: A5 11        	lda	<L366+vol_1
  8844 00:2488: A0 01 00     	ldy	#$1
  8845 00:248B: 97 2E        	sta	[<L366+fs_1],Y
  8846 00:248D: C2 20        	rep	#$20
  8847                        	longa	on
  8848                        ;	stat = disk_initialize(fs->pdrv);	/* Initi
                    alize the physical drive */
  8849 00:248F: A0 01 00     	ldy	#$1
  8850 00:2492: B7 2E        	lda	[<L366+fs_1],Y
  8851 00:2494: 48           	pha
  8852 00:2495: 22 xx xx xx  	jsl	~~disk_initialize
  8853 00:2499: E2 20        	sep	#$20
  8854                        	longa	off
  8855 00:249B: 85 13        	sta	<L366+stat_1
  8856 00:249D: C2 20        	rep	#$20
  8857                        	longa	on
  8858                        ;	if (stat & STA_NOINIT) { 			
                    /* Check if the initialization succeeded */
  8859 00:249F: E2 20        	sep	#$20
  8860                        	longa	off
  8861 00:24A1: A5 13        	lda	<L366+stat_1
  8862 00:24A3: 29 01        	and	#<$1
  8863 00:24A5: C2 20        	rep	#$20
  8864                        	longa	on
  8865 00:24A7: D0 03        	bne	L374
  8866 00:24A9: 82 06 00     	brl	L10173
  8867                        L374:
  8868                        ;		return FR_NOT_READY;			
  Thu May 20 2021 21:37                                                Page 183


                    /* Failed to initialize due to no medium or hard error */
  8869 00:24AC: A9 03 00     	lda	#$3
  8870 00:24AF: 82 33 FF     	brl	L368
  8871                        ;	}
  8872                        ;	if (!FF_FS_READONLY && mode && (stat & STA_PROTE
                    CT)) { /* Check disk write protection if needed */
  8873                        L10173:
  8874 00:24B2: A5 3F        	lda	<L365+mode_0
  8875 00:24B4: 29 FF 00     	and	#$ff
  8876 00:24B7: D0 03        	bne	L375
  8877 00:24B9: 82 13 00     	brl	L10174
  8878                        L375:
  8879 00:24BC: E2 20        	sep	#$20
  8880                        	longa	off
  8881 00:24BE: A5 13        	lda	<L366+stat_1
  8882 00:24C0: 29 04        	and	#<$4
  8883 00:24C2: C2 20        	rep	#$20
  8884                        	longa	on
  8885 00:24C4: D0 03        	bne	L376
  8886 00:24C6: 82 06 00     	brl	L10174
  8887                        L376:
  8888                        ;		return FR_WRITE_PROTECTED;
  8889 00:24C9: A9 0A 00     	lda	#$a
  8890 00:24CC: 82 16 FF     	brl	L368
  8891                        ;	}
  8892                        ;#if FF_MAX_SS != FF_MIN_SS			
                    	/* Get sector size (multiple sector size cfg only) */
  8893                        ;	if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs
                    )) != RES_OK) return FR_DISK_ERR;
  8894                        ;	if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || 
                    (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
  8895                        ;#endif
  8896                        ;
  8897                        ;	/* Find an FAT volume on the drive */
  8898                        ;	fmt = find_volume(fs, LD2PT(vol));
  8899                        L10174:
  8900 00:24CF: F4 00 00     	pea	#<$0
  8901 00:24D2: D4 30        	pei	<L366+fs_1+2
  8902 00:24D4: D4 2E        	pei	<L366+fs_1
  8903 00:24D6: 22 xx xx xx  	jsl	~~find_volume
  8904 00:24DA: 85 32        	sta	<L366+fmt_1
  8905                        ;	if (fmt == 4) return FR_DISK_ERR;		
                    /* An error occured in the disk I/O layer */
  8906 00:24DC: A5 32        	lda	<L366+fmt_1
  8907 00:24DE: C9 04 00     	cmp	#<$4
  8908 00:24E1: F0 03        	beq	L377
  8909 00:24E3: 82 06 00     	brl	L10175
  8910                        L377:
  8911 00:24E6: A9 01 00     	lda	#$1
  8912 00:24E9: 82 F9 FE     	brl	L368
  8913                        ;	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FA
                    T volume is found */
  8914                        L10175:
  8915 00:24EC: A5 32        	lda	<L366+fmt_1
  8916 00:24EE: C9 02 00     	cmp	#<$2
  8917 00:24F1: B0 03        	bcs	L378
  8918 00:24F3: 82 06 00     	brl	L10176
  8919                        L378:
  Thu May 20 2021 21:37                                                Page 184


  8920 00:24F6: A9 0D 00     	lda	#$d
  8921 00:24F9: 82 E9 FE     	brl	L368
  8922                        ;	bsect = fs->winsect;				
                    	/* Volume offset */
  8923                        L10176:
  8924 00:24FC: A0 2B 00     	ldy	#$2b
  8925 00:24FF: B7 2E        	lda	[<L366+fs_1],Y
  8926 00:2501: 85 14        	sta	<L366+bsect_1
  8927 00:2503: A0 2D 00     	ldy	#$2d
  8928 00:2506: B7 2E        	lda	[<L366+fs_1],Y
  8929 00:2508: 85 16        	sta	<L366+bsect_1+2
  8930                        ;
  8931                        ;	/* An FAT volume is found (bsect). Following cod
                    e initializes the filesystem object */
  8932                        ;
  8933                        ;#if FF_FS_EXFAT
  8934                        ;	if (fmt == 1) {
  8935                        ;		QWORD maxlba;
  8936                        ;		DWORD so, cv, bcl, i;
  8937                        ;
  8938                        ;		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx 
                    + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
  8939                        ;		if (i < BPB_ZeroedEx + 53) return FR_NO_
                    FILESYSTEM;
  8940                        ;
  8941                        ;		if (ld_word(fs->win + BPB_FSVerEx) != 0x
                    100) return FR_NO_FILESYSTEM;	/* Check exFAT version (
                    must be version 1.0) */
  8942                        ;
  8943                        ;		if (1 << fs->win[BPB_BytsPerSecEx] != SS
                    (fs)) {	/* (BPB_BytsPerSecEx must be equal to the physic
                    al sector size) */
  8944                        ;			return FR_NO_FILESYSTEM;
  8945                        ;		}
  8946                        ;
  8947                        ;		maxlba = ld_qword(fs->win + BPB_TotSecEx
                    ) + bsect;	/* Last LBA of the volume + 1 */
  8948                        ;		if (!FF_LBA64 && maxlba >= 0x100000000) 
                    return FR_NO_FILESYSTEM;	/* (It cannot be accessed in 32-
                    bit LBA) */
  8949                        ;
  8950                        ;		fs->fsize = ld_dword(fs->win + BPB_FatSz
                    Ex);	/* Number of sectors per FAT */
  8951                        ;
  8952                        ;		fs->n_fats = fs->win[BPB_NumFATsEx];	
                    		/* Number of FATs */
  8953                        ;		if (fs->n_fats != 1) return FR_NO_FILESY
                    STEM;	/* (Supports only 1 FAT) */
  8954                        ;
  8955                        ;		fs->csize = 1 << fs->win[BPB_SecPerClusE
                    x];		/* Cluster size */
  8956                        ;		if (fs->csize == 0)	return FR_NO_FIL
                    ESYSTEM;	/* (Must be 1..32768 sectors) */
  8957                        ;
  8958                        ;		nclst = ld_dword(fs->win + BPB_NumClusEx
                    );		/* Number of clusters */
  8959                        ;		if (nclst > MAX_EXFAT) return FR_NO_FILE
                    SYSTEM;	/* (Too many clusters) */
  Thu May 20 2021 21:37                                                Page 185


  8960                        ;		fs->n_fatent = nclst + 2;
  8961                        ;
  8962                        ;		/* Boundaries and Limits */
  8963                        ;		fs->volbase = bsect;
  8964                        ;		fs->database = bsect + ld_dword(fs->win 
                    + BPB_DataOfsEx);
  8965                        ;		fs->fatbase = bsect + ld_dword(fs->win +
                     BPB_FatOfsEx);
  8966                        ;		if (maxlba < (QWORD)fs->database + nclst
                     * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size 
                    must not be smaller than the size requiered) */
  8967                        ;		fs->dirbase = ld_dword(fs->win + BPB_Roo
                    tClusEx);
  8968                        ;
  8969                        ;		/* Get bitmap location and check if it i
                    s contiguous (implementation assumption) */
  8970                        ;		so = i = 0;
  8971                        ;		for (;;) {	/* Find the bitmap entry
                     in the root directory (in only first cluster) */
  8972                        ;			if (i == 0) {
  8973                        ;				if (so >= fs->csize) ret
                    urn FR_NO_FILESYSTEM;	/* Not found? */
  8974                        ;				if (move_window(fs, clst
                    2sect(fs, (DWORD)fs->dirbase) + so) != FR_OK) return FR_DISK
                    _ERR;
  8975                        ;				so++;
  8976                        ;			}
  8977                        ;			if (fs->win[i] == ET_BITMAP) bre
                    ak;			/* Is it a bitmap entry? */
  8978                        ;			i = (i + SZDIRE) % SS(fs);	
                    /* Next entry */
  8979                        ;		}
  8980                        ;		bcl = ld_dword(fs->win + i + 20);	
                    			/* Bitmap cluster */
  8981                        ;		if (bcl < 2 || bcl >= fs->n_fatent) retu
                    rn FR_NO_FILESYSTEM;	/* (Wrong cluster#) */
  8982                        ;		fs->bitbase = fs->database + fs->csize *
                     (bcl - 2);	/* Bitmap sector */
  8983                        ;		for (;;) {	/* Check if bitmap is co
                    ntiguous */
  8984                        ;			if (move_window(fs, fs->fatbase 
                    + bcl / (SS(fs) / 4)) != FR_OK) return FR_DISK_ERR;
  8985                        ;			cv = ld_dword(fs->win + bcl % (S
                    S(fs) / 4) * 4);
  8986                        ;			if (cv == 0xFFFFFFFF) break;	
                    			/* Last link? */
  8987                        ;			if (cv != ++bcl) return FR_NO_FI
                    LESYSTEM;	/* Fragmented? */
  8988                        ;		}
  8989                        ;
  8990                        ;#if !FF_FS_READONLY
  8991                        ;		fs->last_clst = fs->free_clst = 0xFFFFFF
                    FF;		/* Initialize cluster allocation information */
  8992                        ;#endif
  8993                        ;		fmt = FS_EXFAT;			/* FAT s
                    ub-type */
  8994                        ;	} else
  8995                        ;#endif	/* FF_FS_EXFAT */
  Thu May 20 2021 21:37                                                Page 186


  8996                        ;	{
  8997                        ;		if (ld_word(fs->win + BPB_BytsPerSec) !=
                     SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must 
                    be equal to the physical sector size) */
  8998 00:250A: 18           	clc
  8999 00:250B: A9 3A 00     	lda	#$3a
  9000 00:250E: 65 2E        	adc	<L366+fs_1
  9001 00:2510: 85 01        	sta	<R0
  9002 00:2512: A9 00 00     	lda	#$0
  9003 00:2515: 65 30        	adc	<L366+fs_1+2
  9004 00:2517: 85 03        	sta	<R0+2
  9005 00:2519: D4 03        	pei	<R0+2
  9006 00:251B: D4 01        	pei	<R0
  9007 00:251D: 22 xx xx xx  	jsl	~~ld_word
  9008 00:2521: 85 05        	sta	<R1
  9009 00:2523: A5 05        	lda	<R1
  9010 00:2525: C9 00 02     	cmp	#<$200
  9011 00:2528: D0 03        	bne	L379
  9012 00:252A: 82 06 00     	brl	L10177
  9013                        L379:
  9014 00:252D: A9 0D 00     	lda	#$d
  9015 00:2530: 82 B2 FE     	brl	L368
  9016                        ;
  9017                        ;		fasize = ld_word(fs->win + BPB_FATSz16);
                    		/* Number of sectors per FAT */
  9018                        L10177:
  9019 00:2533: 18           	clc
  9020 00:2534: A9 45 00     	lda	#$45
  9021 00:2537: 65 2E        	adc	<L366+fs_1
  9022 00:2539: 85 01        	sta	<R0
  9023 00:253B: A9 00 00     	lda	#$0
  9024 00:253E: 65 30        	adc	<L366+fs_1+2
  9025 00:2540: 85 03        	sta	<R0+2
  9026 00:2542: D4 03        	pei	<R0+2
  9027 00:2544: D4 01        	pei	<R0
  9028 00:2546: 22 xx xx xx  	jsl	~~ld_word
  9029 00:254A: 85 05        	sta	<R1
  9030 00:254C: A5 05        	lda	<R1
  9031 00:254E: 85 20        	sta	<L366+fasize_1
  9032 00:2550: 64 22        	stz	<L366+fasize_1+2
  9033                        ;		if (fasize == 0) fasize = ld_dword(fs->w
                    in + BPB_FATSz32);
  9034 00:2552: A5 20        	lda	<L366+fasize_1
  9035 00:2554: 05 22        	ora	<L366+fasize_1+2
  9036 00:2556: F0 03        	beq	L380
  9037 00:2558: 82 1B 00     	brl	L10178
  9038                        L380:
  9039 00:255B: 18           	clc
  9040 00:255C: A9 53 00     	lda	#$53
  9041 00:255F: 65 2E        	adc	<L366+fs_1
  9042 00:2561: 85 01        	sta	<R0
  9043 00:2563: A9 00 00     	lda	#$0
  9044 00:2566: 65 30        	adc	<L366+fs_1+2
  9045 00:2568: 85 03        	sta	<R0+2
  9046 00:256A: D4 03        	pei	<R0+2
  9047 00:256C: D4 01        	pei	<R0
  9048 00:256E: 22 xx xx xx  	jsl	~~ld_dword
  9049 00:2572: 85 20        	sta	<L366+fasize_1
  Thu May 20 2021 21:37                                                Page 187


  9050 00:2574: 86 22        	stx	<L366+fasize_1+2
  9051                        ;		fs->fsize = fasize;
  9052                        L10178:
  9053 00:2576: A5 20        	lda	<L366+fasize_1
  9054 00:2578: A0 17 00     	ldy	#$17
  9055 00:257B: 97 2E        	sta	[<L366+fs_1],Y
  9056 00:257D: A5 22        	lda	<L366+fasize_1+2
  9057 00:257F: A0 19 00     	ldy	#$19
  9058 00:2582: 97 2E        	sta	[<L366+fs_1],Y
  9059                        ;
  9060                        ;		fs->n_fats = fs->win[BPB_NumFATs];	
                    			/* Number of FATs */
  9061 00:2584: E2 20        	sep	#$20
  9062                        	longa	off
  9063 00:2586: A0 3F 00     	ldy	#$3f
  9064 00:2589: B7 2E        	lda	[<L366+fs_1],Y
  9065 00:258B: A0 02 00     	ldy	#$2
  9066 00:258E: 97 2E        	sta	[<L366+fs_1],Y
  9067 00:2590: C2 20        	rep	#$20
  9068                        	longa	on
  9069                        ;		if (fs->n_fats != 1 && fs->n_fats != 2) 
                    return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
  9070 00:2592: E2 20        	sep	#$20
  9071                        	longa	off
  9072 00:2594: A0 02 00     	ldy	#$2
  9073 00:2597: B7 2E        	lda	[<L366+fs_1],Y
  9074 00:2599: C9 01        	cmp	#<$1
  9075 00:259B: C2 20        	rep	#$20
  9076                        	longa	on
  9077 00:259D: D0 03        	bne	L381
  9078 00:259F: 82 16 00     	brl	L10179
  9079                        L381:
  9080 00:25A2: E2 20        	sep	#$20
  9081                        	longa	off
  9082 00:25A4: A0 02 00     	ldy	#$2
  9083 00:25A7: B7 2E        	lda	[<L366+fs_1],Y
  9084 00:25A9: C9 02        	cmp	#<$2
  9085 00:25AB: C2 20        	rep	#$20
  9086                        	longa	on
  9087 00:25AD: D0 03        	bne	L382
  9088 00:25AF: 82 06 00     	brl	L10179
  9089                        L382:
  9090 00:25B2: A9 0D 00     	lda	#$d
  9091 00:25B5: 82 2D FE     	brl	L368
  9092                        ;		fasize *= fs->n_fats;			
                    				/* Number of sectors for FAT are
                    a */
  9093                        L10179:
  9094 00:25B8: A0 02 00     	ldy	#$2
  9095 00:25BB: B7 2E        	lda	[<L366+fs_1],Y
  9096 00:25BD: 29 FF 00     	and	#$ff
  9097 00:25C0: 85 01        	sta	<R0
  9098 00:25C2: 64 03        	stz	<R0+2
  9099 00:25C4: D4 22        	pei	<L366+fasize_1+2
  9100 00:25C6: D4 20        	pei	<L366+fasize_1
  9101 00:25C8: D4 03        	pei	<R0+2
  9102 00:25CA: D4 01        	pei	<R0
  9103                        	xref	~~~lmul
  Thu May 20 2021 21:37                                                Page 188


  9104 00:25CC: 22 xx xx xx  	jsl	~~~lmul
  9105 00:25D0: 85 20        	sta	<L366+fasize_1
  9106 00:25D2: 86 22        	stx	<L366+fasize_1+2
  9107                        ;
  9108                        ;		fs->csize = fs->win[BPB_SecPerClus];	
                    		/* Cluster size */
  9109 00:25D4: A0 3C 00     	ldy	#$3c
  9110 00:25D7: B7 2E        	lda	[<L366+fs_1],Y
  9111 00:25D9: 29 FF 00     	and	#$ff
  9112 00:25DC: A0 09 00     	ldy	#$9
  9113 00:25DF: 97 2E        	sta	[<L366+fs_1],Y
  9114                        ;		if (fs->csize == 0 || (fs->csize & (fs->
                    csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be powe
                    r of 2) */
  9115 00:25E1: A0 09 00     	ldy	#$9
  9116 00:25E4: B7 2E        	lda	[<L366+fs_1],Y
  9117 00:25E6: D0 03        	bne	L384
  9118 00:25E8: 82 17 00     	brl	L383
  9119                        L384:
  9120 00:25EB: 18           	clc
  9121 00:25EC: A9 FF FF     	lda	#$ffff
  9122 00:25EF: A0 09 00     	ldy	#$9
  9123 00:25F2: 77 2E        	adc	[<L366+fs_1],Y
  9124 00:25F4: 85 01        	sta	<R0
  9125 00:25F6: A0 09 00     	ldy	#$9
  9126 00:25F9: B7 2E        	lda	[<L366+fs_1],Y
  9127 00:25FB: 25 01        	and	<R0
  9128 00:25FD: D0 03        	bne	L385
  9129 00:25FF: 82 06 00     	brl	L10180
  9130                        L385:
  9131                        L383:
  9132 00:2602: A9 0D 00     	lda	#$d
  9133 00:2605: 82 DD FD     	brl	L368
  9134                        ;
  9135                        ;		fs->n_rootdir = ld_word(fs->win + BPB_Ro
                    otEntCnt);	/* Number of root directory entries */
  9136                        L10180:
  9137 00:2608: 18           	clc
  9138 00:2609: A9 40 00     	lda	#$40
  9139 00:260C: 65 2E        	adc	<L366+fs_1
  9140 00:260E: 85 01        	sta	<R0
  9141 00:2610: A9 00 00     	lda	#$0
  9142 00:2613: 65 30        	adc	<L366+fs_1+2
  9143 00:2615: 85 03        	sta	<R0+2
  9144 00:2617: D4 03        	pei	<R0+2
  9145 00:2619: D4 01        	pei	<R0
  9146 00:261B: 22 xx xx xx  	jsl	~~ld_word
  9147 00:261F: A0 07 00     	ldy	#$7
  9148 00:2622: 97 2E        	sta	[<L366+fs_1],Y
  9149                        ;		if (fs->n_rootdir % (SS(fs) / SZDIRE)) r
                    eturn FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
  9150 00:2624: A0 07 00     	ldy	#$7
  9151 00:2627: B7 2E        	lda	[<L366+fs_1],Y
  9152 00:2629: 29 0F 00     	and	#<$f
  9153 00:262C: D0 03        	bne	L386
  9154 00:262E: 82 06 00     	brl	L10181
  9155                        L386:
  9156 00:2631: A9 0D 00     	lda	#$d
  Thu May 20 2021 21:37                                                Page 189


  9157 00:2634: 82 AE FD     	brl	L368
  9158                        ;
  9159                        ;		tsect = ld_word(fs->win + BPB_TotSec16);
                    		/* Number of sectors on the volume */
  9160                        L10181:
  9161 00:2637: 18           	clc
  9162 00:2638: A9 42 00     	lda	#$42
  9163 00:263B: 65 2E        	adc	<L366+fs_1
  9164 00:263D: 85 01        	sta	<R0
  9165 00:263F: A9 00 00     	lda	#$0
  9166 00:2642: 65 30        	adc	<L366+fs_1+2
  9167 00:2644: 85 03        	sta	<R0+2
  9168 00:2646: D4 03        	pei	<R0+2
  9169 00:2648: D4 01        	pei	<R0
  9170 00:264A: 22 xx xx xx  	jsl	~~ld_word
  9171 00:264E: 85 05        	sta	<R1
  9172 00:2650: A5 05        	lda	<R1
  9173 00:2652: 85 18        	sta	<L366+tsect_1
  9174 00:2654: 64 1A        	stz	<L366+tsect_1+2
  9175                        ;		if (tsect == 0) tsect = ld_dword(fs->win
                     + BPB_TotSec32);
  9176 00:2656: A5 18        	lda	<L366+tsect_1
  9177 00:2658: 05 1A        	ora	<L366+tsect_1+2
  9178 00:265A: F0 03        	beq	L387
  9179 00:265C: 82 1B 00     	brl	L10182
  9180                        L387:
  9181 00:265F: 18           	clc
  9182 00:2660: A9 4F 00     	lda	#$4f
  9183 00:2663: 65 2E        	adc	<L366+fs_1
  9184 00:2665: 85 01        	sta	<R0
  9185 00:2667: A9 00 00     	lda	#$0
  9186 00:266A: 65 30        	adc	<L366+fs_1+2
  9187 00:266C: 85 03        	sta	<R0+2
  9188 00:266E: D4 03        	pei	<R0+2
  9189 00:2670: D4 01        	pei	<R0
  9190 00:2672: 22 xx xx xx  	jsl	~~ld_dword
  9191 00:2676: 85 18        	sta	<L366+tsect_1
  9192 00:2678: 86 1A        	stx	<L366+tsect_1+2
  9193                        ;
  9194                        ;		nrsv = ld_word(fs->win + BPB_RsvdSecCnt)
                    ;		/* Number of reserved sectors */
  9195                        L10182:
  9196 00:267A: 18           	clc
  9197 00:267B: A9 3D 00     	lda	#$3d
  9198 00:267E: 65 2E        	adc	<L366+fs_1
  9199 00:2680: 85 01        	sta	<R0
  9200 00:2682: A9 00 00     	lda	#$0
  9201 00:2685: 65 30        	adc	<L366+fs_1+2
  9202 00:2687: 85 03        	sta	<R0+2
  9203 00:2689: D4 03        	pei	<R0+2
  9204 00:268B: D4 01        	pei	<R0
  9205 00:268D: 22 xx xx xx  	jsl	~~ld_word
  9206 00:2691: 85 2C        	sta	<L366+nrsv_1
  9207                        ;		if (nrsv == 0) return FR_NO_FILESYSTEM;	
                    		/* (Must not be 0) */
  9208 00:2693: A5 2C        	lda	<L366+nrsv_1
  9209 00:2695: F0 03        	beq	L388
  9210 00:2697: 82 06 00     	brl	L10183
  Thu May 20 2021 21:37                                                Page 190


  9211                        L388:
  9212 00:269A: A9 0D 00     	lda	#$d
  9213 00:269D: 82 45 FD     	brl	L368
  9214                        ;
  9215                        ;		/* Determine the FAT sub type */
  9216                        ;		sysect = nrsv + fasize + fs->n_rootdir /
                     (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
  9217                        L10183:
  9218 00:26A0: A0 07 00     	ldy	#$7
  9219 00:26A3: B7 2E        	lda	[<L366+fs_1],Y
  9220 00:26A5: 4A           	lsr	A
  9221 00:26A6: 4A           	lsr	A
  9222 00:26A7: 4A           	lsr	A
  9223 00:26A8: 4A           	lsr	A
  9224 00:26A9: 85 01        	sta	<R0
  9225 00:26AB: A5 01        	lda	<R0
  9226 00:26AD: 85 01        	sta	<R0
  9227 00:26AF: 64 03        	stz	<R0+2
  9228 00:26B1: A5 2C        	lda	<L366+nrsv_1
  9229 00:26B3: 85 05        	sta	<R1
  9230 00:26B5: 64 07        	stz	<R1+2
  9231 00:26B7: 18           	clc
  9232 00:26B8: A5 05        	lda	<R1
  9233 00:26BA: 65 01        	adc	<R0
  9234 00:26BC: 85 09        	sta	<R2
  9235 00:26BE: A5 07        	lda	<R1+2
  9236 00:26C0: 65 03        	adc	<R0+2
  9237 00:26C2: 85 0B        	sta	<R2+2
  9238 00:26C4: 18           	clc
  9239 00:26C5: A5 09        	lda	<R2
  9240 00:26C7: 65 20        	adc	<L366+fasize_1
  9241 00:26C9: 85 1C        	sta	<L366+sysect_1
  9242 00:26CB: A5 0B        	lda	<R2+2
  9243 00:26CD: 65 22        	adc	<L366+fasize_1+2
  9244 00:26CF: 85 1E        	sta	<L366+sysect_1+2
  9245                        ;		if (tsect < sysect) return FR_NO_FILESYS
                    TEM;	/* (Invalid volume size) */
  9246 00:26D1: A5 18        	lda	<L366+tsect_1
  9247 00:26D3: C5 1C        	cmp	<L366+sysect_1
  9248 00:26D5: A5 1A        	lda	<L366+tsect_1+2
  9249 00:26D7: E5 1E        	sbc	<L366+sysect_1+2
  9250 00:26D9: 90 03        	bcc	L389
  9251 00:26DB: 82 06 00     	brl	L10184
  9252                        L389:
  9253 00:26DE: A9 0D 00     	lda	#$d
  9254 00:26E1: 82 01 FD     	brl	L368
  9255                        ;		nclst = (tsect - sysect) / fs->csize;	
                    		/* Number of clusters */
  9256                        L10184:
  9257 00:26E4: A0 09 00     	ldy	#$9
  9258 00:26E7: B7 2E        	lda	[<L366+fs_1],Y
  9259 00:26E9: 85 01        	sta	<R0
  9260 00:26EB: 64 03        	stz	<R0+2
  9261 00:26ED: 38           	sec
  9262 00:26EE: A5 18        	lda	<L366+tsect_1
  9263 00:26F0: E5 1C        	sbc	<L366+sysect_1
  9264 00:26F2: 85 05        	sta	<R1
  9265 00:26F4: A5 1A        	lda	<L366+tsect_1+2
  Thu May 20 2021 21:37                                                Page 191


  9266 00:26F6: E5 1E        	sbc	<L366+sysect_1+2
  9267 00:26F8: 85 07        	sta	<R1+2
  9268 00:26FA: D4 03        	pei	<R0+2
  9269 00:26FC: D4 01        	pei	<R0
  9270 00:26FE: D4 07        	pei	<R1+2
  9271 00:2700: D4 05        	pei	<R1
  9272                        	xref	~~~ludv
  9273 00:2702: 22 xx xx xx  	jsl	~~~ludv
  9274 00:2706: 85 24        	sta	<L366+nclst_1
  9275 00:2708: 86 26        	stx	<L366+nclst_1+2
  9276                        ;		if (nclst == 0) return FR_NO_FILESYSTEM;
                    		/* (Invalid volume size) */
  9277 00:270A: A5 24        	lda	<L366+nclst_1
  9278 00:270C: 05 26        	ora	<L366+nclst_1+2
  9279 00:270E: F0 03        	beq	L390
  9280 00:2710: 82 06 00     	brl	L10185
  9281                        L390:
  9282 00:2713: A9 0D 00     	lda	#$d
  9283 00:2716: 82 CC FC     	brl	L368
  9284                        ;		fmt = 0;
  9285                        L10185:
  9286 00:2719: 64 32        	stz	<L366+fmt_1
  9287                        ;		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
  9288 00:271B: A9 F5 FF     	lda	#$fff5
  9289 00:271E: C5 24        	cmp	<L366+nclst_1
  9290 00:2720: A9 FF 0F     	lda	#$fff
  9291 00:2723: E5 26        	sbc	<L366+nclst_1+2
  9292 00:2725: B0 03        	bcs	L391
  9293 00:2727: 82 05 00     	brl	L10186
  9294                        L391:
  9295 00:272A: A9 03 00     	lda	#$3
  9296 00:272D: 85 32        	sta	<L366+fmt_1
  9297                        ;		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
  9298                        L10186:
  9299 00:272F: A9 F5 FF     	lda	#$fff5
  9300 00:2732: C5 24        	cmp	<L366+nclst_1
  9301 00:2734: A9 00 00     	lda	#$0
  9302 00:2737: E5 26        	sbc	<L366+nclst_1+2
  9303 00:2739: B0 03        	bcs	L392
  9304 00:273B: 82 05 00     	brl	L10187
  9305                        L392:
  9306 00:273E: A9 02 00     	lda	#$2
  9307 00:2741: 85 32        	sta	<L366+fmt_1
  9308                        ;		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
  9309                        L10187:
  9310 00:2743: A9 F5 0F     	lda	#$ff5
  9311 00:2746: C5 24        	cmp	<L366+nclst_1
  9312 00:2748: A9 00 00     	lda	#$0
  9313 00:274B: E5 26        	sbc	<L366+nclst_1+2
  9314 00:274D: B0 03        	bcs	L393
  9315 00:274F: 82 05 00     	brl	L10188
  9316                        L393:
  9317 00:2752: A9 01 00     	lda	#$1
  9318 00:2755: 85 32        	sta	<L366+fmt_1
  9319                        ;		if (fmt == 0) return FR_NO_FILESYSTEM;
  9320                        L10188:
  9321 00:2757: A5 32        	lda	<L366+fmt_1
  9322 00:2759: F0 03        	beq	L394
  Thu May 20 2021 21:37                                                Page 192


  9323 00:275B: 82 06 00     	brl	L10189
  9324                        L394:
  9325 00:275E: A9 0D 00     	lda	#$d
  9326 00:2761: 82 81 FC     	brl	L368
  9327                        ;
  9328                        ;		/* Boundaries and Limits */
  9329                        ;		fs->n_fatent = nclst + 2;		
                    				/* Number of FAT entries */
  9330                        L10189:
  9331 00:2764: 18           	clc
  9332 00:2765: A9 02 00     	lda	#$2
  9333 00:2768: 65 24        	adc	<L366+nclst_1
  9334 00:276A: 85 01        	sta	<R0
  9335 00:276C: A9 00 00     	lda	#$0
  9336 00:276F: 65 26        	adc	<L366+nclst_1+2
  9337 00:2771: 85 03        	sta	<R0+2
  9338 00:2773: A5 01        	lda	<R0
  9339 00:2775: A0 13 00     	ldy	#$13
  9340 00:2778: 97 2E        	sta	[<L366+fs_1],Y
  9341 00:277A: A5 03        	lda	<R0+2
  9342 00:277C: A0 15 00     	ldy	#$15
  9343 00:277F: 97 2E        	sta	[<L366+fs_1],Y
  9344                        ;		fs->volbase = bsect;			
                    				/* Volume start sector */
  9345 00:2781: A5 14        	lda	<L366+bsect_1
  9346 00:2783: A0 1B 00     	ldy	#$1b
  9347 00:2786: 97 2E        	sta	[<L366+fs_1],Y
  9348 00:2788: A5 16        	lda	<L366+bsect_1+2
  9349 00:278A: A0 1D 00     	ldy	#$1d
  9350 00:278D: 97 2E        	sta	[<L366+fs_1],Y
  9351                        ;		fs->fatbase = bsect + nrsv; 		
                    			/* FAT start sector */
  9352 00:278F: A5 2C        	lda	<L366+nrsv_1
  9353 00:2791: 85 01        	sta	<R0
  9354 00:2793: 64 03        	stz	<R0+2
  9355 00:2795: 18           	clc
  9356 00:2796: A5 01        	lda	<R0
  9357 00:2798: 65 14        	adc	<L366+bsect_1
  9358 00:279A: 85 05        	sta	<R1
  9359 00:279C: A5 03        	lda	<R0+2
  9360 00:279E: 65 16        	adc	<L366+bsect_1+2
  9361 00:27A0: 85 07        	sta	<R1+2
  9362 00:27A2: A5 05        	lda	<R1
  9363 00:27A4: A0 1F 00     	ldy	#$1f
  9364 00:27A7: 97 2E        	sta	[<L366+fs_1],Y
  9365 00:27A9: A5 07        	lda	<R1+2
  9366 00:27AB: A0 21 00     	ldy	#$21
  9367 00:27AE: 97 2E        	sta	[<L366+fs_1],Y
  9368                        ;		fs->database = bsect + sysect;		
                    			/* Data start sector */
  9369 00:27B0: 18           	clc
  9370 00:27B1: A5 14        	lda	<L366+bsect_1
  9371 00:27B3: 65 1C        	adc	<L366+sysect_1
  9372 00:27B5: 85 01        	sta	<R0
  9373 00:27B7: A5 16        	lda	<L366+bsect_1+2
  9374 00:27B9: 65 1E        	adc	<L366+sysect_1+2
  9375 00:27BB: 85 03        	sta	<R0+2
  9376 00:27BD: A5 01        	lda	<R0
  Thu May 20 2021 21:37                                                Page 193


  9377 00:27BF: A0 27 00     	ldy	#$27
  9378 00:27C2: 97 2E        	sta	[<L366+fs_1],Y
  9379 00:27C4: A5 03        	lda	<R0+2
  9380 00:27C6: A0 29 00     	ldy	#$29
  9381 00:27C9: 97 2E        	sta	[<L366+fs_1],Y
  9382                        ;		if (fmt == FS_FAT32) {
  9383 00:27CB: A5 32        	lda	<L366+fmt_1
  9384 00:27CD: C9 03 00     	cmp	#<$3
  9385 00:27D0: F0 03        	beq	L395
  9386 00:27D2: 82 76 00     	brl	L10190
  9387                        L395:
  9388                        ;			if (ld_word(fs->win + BPB_FSVer3
                    2) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revisi
                    on 0.0) */
  9389 00:27D5: 18           	clc
  9390 00:27D6: A9 59 00     	lda	#$59
  9391 00:27D9: 65 2E        	adc	<L366+fs_1
  9392 00:27DB: 85 01        	sta	<R0
  9393 00:27DD: A9 00 00     	lda	#$0
  9394 00:27E0: 65 30        	adc	<L366+fs_1+2
  9395 00:27E2: 85 03        	sta	<R0+2
  9396 00:27E4: D4 03        	pei	<R0+2
  9397 00:27E6: D4 01        	pei	<R0
  9398 00:27E8: 22 xx xx xx  	jsl	~~ld_word
  9399 00:27EC: AA           	tax
  9400 00:27ED: D0 03        	bne	L396
  9401 00:27EF: 82 06 00     	brl	L10191
  9402                        L396:
  9403 00:27F2: A9 0D 00     	lda	#$d
  9404 00:27F5: 82 ED FB     	brl	L368
  9405                        ;			if (fs->n_rootdir != 0) return F
                    R_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
  9406                        L10191:
  9407 00:27F8: A0 07 00     	ldy	#$7
  9408 00:27FB: B7 2E        	lda	[<L366+fs_1],Y
  9409 00:27FD: D0 03        	bne	L397
  9410 00:27FF: 82 06 00     	brl	L10192
  9411                        L397:
  9412 00:2802: A9 0D 00     	lda	#$d
  9413 00:2805: 82 DD FB     	brl	L368
  9414                        ;			fs->dirbase = ld_dword(fs->win +
                     BPB_RootClus32);	/* Root directory start cluster */
  9415                        L10192:
  9416 00:2808: 18           	clc
  9417 00:2809: A9 5B 00     	lda	#$5b
  9418 00:280C: 65 2E        	adc	<L366+fs_1
  9419 00:280E: 85 01        	sta	<R0
  9420 00:2810: A9 00 00     	lda	#$0
  9421 00:2813: 65 30        	adc	<L366+fs_1+2
  9422 00:2815: 85 03        	sta	<R0+2
  9423 00:2817: D4 03        	pei	<R0+2
  9424 00:2819: D4 01        	pei	<R0
  9425 00:281B: 22 xx xx xx  	jsl	~~ld_dword
  9426 00:281F: 85 05        	sta	<R1
  9427 00:2821: 86 07        	stx	<R1+2
  9428 00:2823: A5 05        	lda	<R1
  9429 00:2825: A0 23 00     	ldy	#$23
  9430 00:2828: 97 2E        	sta	[<L366+fs_1],Y
  Thu May 20 2021 21:37                                                Page 194


  9431 00:282A: A5 07        	lda	<R1+2
  9432 00:282C: A0 25 00     	ldy	#$25
  9433 00:282F: 97 2E        	sta	[<L366+fs_1],Y
  9434                        ;			szbfat = fs->n_fatent * 4;	
                    				/* (Needed FAT size) */
  9435 00:2831: A0 15 00     	ldy	#$15
  9436 00:2834: B7 2E        	lda	[<L366+fs_1],Y
  9437 00:2836: 48           	pha
  9438 00:2837: A0 13 00     	ldy	#$13
  9439 00:283A: B7 2E        	lda	[<L366+fs_1],Y
  9440 00:283C: 48           	pha
  9441 00:283D: A9 02 00     	lda	#$2
  9442                        	xref	~~~lasl
  9443 00:2840: 22 xx xx xx  	jsl	~~~lasl
  9444 00:2844: 85 28        	sta	<L366+szbfat_1
  9445 00:2846: 86 2A        	stx	<L366+szbfat_1+2
  9446                        ;		} else {
  9447 00:2848: 82 AA 00     	brl	L10193
  9448                        L10190:
  9449                        ;			if (fs->n_rootdir == 0)	return F
                    R_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  9450 00:284B: A0 07 00     	ldy	#$7
  9451 00:284E: B7 2E        	lda	[<L366+fs_1],Y
  9452 00:2850: F0 03        	beq	L398
  9453 00:2852: 82 06 00     	brl	L10194
  9454                        L398:
  9455 00:2855: A9 0D 00     	lda	#$d
  9456 00:2858: 82 8A FB     	brl	L368
  9457                        ;			fs->dirbase = fs->fatbase + fasi
                    ze;			/* Root directory start sector */
  9458                        L10194:
  9459 00:285B: 18           	clc
  9460 00:285C: A0 1F 00     	ldy	#$1f
  9461 00:285F: B7 2E        	lda	[<L366+fs_1],Y
  9462 00:2861: 65 20        	adc	<L366+fasize_1
  9463 00:2863: 85 01        	sta	<R0
  9464 00:2865: A0 21 00     	ldy	#$21
  9465 00:2868: B7 2E        	lda	[<L366+fs_1],Y
  9466 00:286A: 65 22        	adc	<L366+fasize_1+2
  9467 00:286C: 85 03        	sta	<R0+2
  9468 00:286E: A5 01        	lda	<R0
  9469 00:2870: A0 23 00     	ldy	#$23
  9470 00:2873: 97 2E        	sta	[<L366+fs_1],Y
  9471 00:2875: A5 03        	lda	<R0+2
  9472 00:2877: A0 25 00     	ldy	#$25
  9473 00:287A: 97 2E        	sta	[<L366+fs_1],Y
  9474                        ;			szbfat = (fmt == FS_FAT16) ?	
                    			/* (Needed FAT size) */
  9475                        ;				fs->n_fatent * 2 : fs->n
                    _fatent * 3 / 2 + (fs->n_fatent & 1);
  9476 00:287C: A5 32        	lda	<L366+fmt_1
  9477 00:287E: C9 02 00     	cmp	#<$2
  9478 00:2881: F0 03        	beq	L400
  9479 00:2883: 82 1D 00     	brl	L399
  9480                        L400:
  9481 00:2886: A0 15 00     	ldy	#$15
  9482 00:2889: B7 2E        	lda	[<L366+fs_1],Y
  9483 00:288B: 48           	pha
  Thu May 20 2021 21:37                                                Page 195


  9484 00:288C: A0 13 00     	ldy	#$13
  9485 00:288F: B7 2E        	lda	[<L366+fs_1],Y
  9486 00:2891: 48           	pha
  9487 00:2892: A9 01 00     	lda	#$1
  9488                        	xref	~~~lasl
  9489 00:2895: 22 xx xx xx  	jsl	~~~lasl
  9490 00:2899: 85 01        	sta	<R0
  9491 00:289B: 86 03        	stx	<R0+2
  9492 00:289D: A6 03        	ldx	<R0+2
  9493 00:289F: A5 01        	lda	<R0
  9494 00:28A1: 80 46        	bra	L401
  9495                        L399:
  9496 00:28A3: A0 13 00     	ldy	#$13
  9497 00:28A6: B7 2E        	lda	[<L366+fs_1],Y
  9498 00:28A8: 29 01 00     	and	#<$1
  9499 00:28AB: 85 01        	sta	<R0
  9500 00:28AD: 64 03        	stz	<R0+2
  9501 00:28AF: F4 00 00     	pea	#^$3
  9502 00:28B2: F4 03 00     	pea	#<$3
  9503 00:28B5: A0 15 00     	ldy	#$15
  9504 00:28B8: B7 2E        	lda	[<L366+fs_1],Y
  9505 00:28BA: 48           	pha
  9506 00:28BB: A0 13 00     	ldy	#$13
  9507 00:28BE: B7 2E        	lda	[<L366+fs_1],Y
  9508 00:28C0: 48           	pha
  9509                        	xref	~~~lmul
  9510 00:28C1: 22 xx xx xx  	jsl	~~~lmul
  9511 00:28C5: 85 09        	sta	<R2
  9512 00:28C7: 86 0B        	stx	<R2+2
  9513 00:28C9: D4 0B        	pei	<R2+2
  9514 00:28CB: D4 09        	pei	<R2
  9515 00:28CD: A9 01 00     	lda	#$1
  9516                        	xref	~~~llsr
  9517 00:28D0: 22 xx xx xx  	jsl	~~~llsr
  9518 00:28D4: 85 05        	sta	<R1
  9519 00:28D6: 86 07        	stx	<R1+2
  9520 00:28D8: 18           	clc
  9521 00:28D9: A5 05        	lda	<R1
  9522 00:28DB: 65 01        	adc	<R0
  9523 00:28DD: 85 0D        	sta	<R3
  9524 00:28DF: A5 07        	lda	<R1+2
  9525 00:28E1: 65 03        	adc	<R0+2
  9526 00:28E3: 85 0F        	sta	<R3+2
  9527 00:28E5: A6 0F        	ldx	<R3+2
  9528 00:28E7: A5 0D        	lda	<R3
  9529                        L401:
  9530 00:28E9: 85 01        	sta	<R0
  9531 00:28EB: 86 03        	stx	<R0+2
  9532 00:28ED: A5 01        	lda	<R0
  9533 00:28EF: 85 28        	sta	<L366+szbfat_1
  9534 00:28F1: A5 03        	lda	<R0+2
  9535 00:28F3: 85 2A        	sta	<L366+szbfat_1+2
  9536                        ;		}
  9537                        L10193:
  9538                        ;		if (fs->fsize < (szbfat + (SS(fs) - 1)) 
                    / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not b
                    e less than the size needed) */
  9539 00:28F5: 18           	clc
  Thu May 20 2021 21:37                                                Page 196


  9540 00:28F6: A9 FF 01     	lda	#$1ff
  9541 00:28F9: 65 28        	adc	<L366+szbfat_1
  9542 00:28FB: 85 05        	sta	<R1
  9543 00:28FD: A9 00 00     	lda	#$0
  9544 00:2900: 65 2A        	adc	<L366+szbfat_1+2
  9545 00:2902: 85 07        	sta	<R1+2
  9546 00:2904: D4 07        	pei	<R1+2
  9547 00:2906: D4 05        	pei	<R1
  9548 00:2908: A9 09 00     	lda	#$9
  9549                        	xref	~~~llsr
  9550 00:290B: 22 xx xx xx  	jsl	~~~llsr
  9551 00:290F: 85 01        	sta	<R0
  9552 00:2911: 86 03        	stx	<R0+2
  9553 00:2913: A0 17 00     	ldy	#$17
  9554 00:2916: B7 2E        	lda	[<L366+fs_1],Y
  9555 00:2918: C5 01        	cmp	<R0
  9556 00:291A: A0 19 00     	ldy	#$19
  9557 00:291D: B7 2E        	lda	[<L366+fs_1],Y
  9558 00:291F: E5 03        	sbc	<R0+2
  9559 00:2921: 90 03        	bcc	L402
  9560 00:2923: 82 06 00     	brl	L10195
  9561                        L402:
  9562 00:2926: A9 0D 00     	lda	#$d
  9563 00:2929: 82 B9 FA     	brl	L368
  9564                        ;
  9565                        ;#if !FF_FS_READONLY
  9566                        ;		/* Get FSInfo if available */
  9567                        ;		fs->last_clst = fs->free_clst = 0xFFFFFF
                    FF;		/* Initialize cluster allocation information */
  9568                        L10195:
  9569 00:292C: A9 FF FF     	lda	#$ffff
  9570 00:292F: A0 0F 00     	ldy	#$f
  9571 00:2932: 97 2E        	sta	[<L366+fs_1],Y
  9572 00:2934: A9 FF FF     	lda	#$ffff
  9573 00:2937: A0 11 00     	ldy	#$11
  9574 00:293A: 97 2E        	sta	[<L366+fs_1],Y
  9575 00:293C: A9 FF FF     	lda	#$ffff
  9576 00:293F: A0 0B 00     	ldy	#$b
  9577 00:2942: 97 2E        	sta	[<L366+fs_1],Y
  9578 00:2944: A9 FF FF     	lda	#$ffff
  9579 00:2947: A0 0D 00     	ldy	#$d
  9580 00:294A: 97 2E        	sta	[<L366+fs_1],Y
  9581                        ;		fs->fsi_flag = 0x80;
  9582 00:294C: E2 20        	sep	#$20
  9583                        	longa	off
  9584 00:294E: A9 80        	lda	#$80
  9585 00:2950: A0 04 00     	ldy	#$4
  9586 00:2953: 97 2E        	sta	[<L366+fs_1],Y
  9587 00:2955: C2 20        	rep	#$20
  9588                        	longa	on
  9589                        ;#if (FF_FS_NOFSINFO & 3) != 3
  9590                        ;		if (fmt == FS_FAT32			
                    	/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
  9591                        ;			&& ld_word(fs->win + BPB_FSInfo3
                    2) == 1
  9592                        ;			&& move_window(fs, bsect + 1) ==
                     FR_OK)
  9593                        ;		{
  Thu May 20 2021 21:37                                                Page 197


  9594 00:2957: A5 32        	lda	<L366+fmt_1
  9595 00:2959: C9 03 00     	cmp	#<$3
  9596 00:295C: F0 03        	beq	L403
  9597 00:295E: 82 1C 01     	brl	L10196
  9598                        L403:
  9599 00:2961: 18           	clc
  9600 00:2962: A9 5F 00     	lda	#$5f
  9601 00:2965: 65 2E        	adc	<L366+fs_1
  9602 00:2967: 85 01        	sta	<R0
  9603 00:2969: A9 00 00     	lda	#$0
  9604 00:296C: 65 30        	adc	<L366+fs_1+2
  9605 00:296E: 85 03        	sta	<R0+2
  9606 00:2970: D4 03        	pei	<R0+2
  9607 00:2972: D4 01        	pei	<R0
  9608 00:2974: 22 xx xx xx  	jsl	~~ld_word
  9609 00:2978: 85 05        	sta	<R1
  9610 00:297A: A5 05        	lda	<R1
  9611 00:297C: C9 01 00     	cmp	#<$1
  9612 00:297F: F0 03        	beq	L404
  9613 00:2981: 82 F9 00     	brl	L10196
  9614                        L404:
  9615 00:2984: 18           	clc
  9616 00:2985: A9 01 00     	lda	#$1
  9617 00:2988: 65 14        	adc	<L366+bsect_1
  9618 00:298A: 85 05        	sta	<R1
  9619 00:298C: A9 00 00     	lda	#$0
  9620 00:298F: 65 16        	adc	<L366+bsect_1+2
  9621 00:2991: 85 07        	sta	<R1+2
  9622 00:2993: D4 07        	pei	<R1+2
  9623 00:2995: D4 05        	pei	<R1
  9624 00:2997: D4 30        	pei	<L366+fs_1+2
  9625 00:2999: D4 2E        	pei	<L366+fs_1
  9626 00:299B: 22 xx xx xx  	jsl	~~move_window
  9627 00:299F: AA           	tax
  9628 00:29A0: F0 03        	beq	L405
  9629 00:29A2: 82 D8 00     	brl	L10196
  9630                        L405:
  9631                        ;			fs->fsi_flag = 0;
  9632 00:29A5: E2 20        	sep	#$20
  9633                        	longa	off
  9634 00:29A7: A9 00        	lda	#$0
  9635 00:29A9: A0 04 00     	ldy	#$4
  9636 00:29AC: 97 2E        	sta	[<L366+fs_1],Y
  9637 00:29AE: C2 20        	rep	#$20
  9638                        	longa	on
  9639                        ;			if (ld_word(fs->win + BS_55AA) =
                    = 0xAA55	/* Load FSInfo data if available */
  9640                        ;				&& ld_dword(fs->win + FS
                    I_LeadSig) == 0x41615252
  9641                        ;				&& ld_dword(fs->win + FS
                    I_StrucSig) == 0x61417272)
  9642                        ;			{
  9643 00:29B0: 18           	clc
  9644 00:29B1: A9 2D 02     	lda	#$22d
  9645 00:29B4: 65 2E        	adc	<L366+fs_1
  9646 00:29B6: 85 01        	sta	<R0
  9647 00:29B8: A9 00 00     	lda	#$0
  9648 00:29BB: 65 30        	adc	<L366+fs_1+2
  Thu May 20 2021 21:37                                                Page 198


  9649 00:29BD: 85 03        	sta	<R0+2
  9650 00:29BF: D4 03        	pei	<R0+2
  9651 00:29C1: D4 01        	pei	<R0
  9652 00:29C3: 22 xx xx xx  	jsl	~~ld_word
  9653 00:29C7: 85 05        	sta	<R1
  9654 00:29C9: A5 05        	lda	<R1
  9655 00:29CB: C9 55 AA     	cmp	#<$aa55
  9656 00:29CE: F0 03        	beq	L406
  9657 00:29D0: 82 AA 00     	brl	L10197
  9658                        L406:
  9659 00:29D3: 18           	clc
  9660 00:29D4: A9 2F 00     	lda	#$2f
  9661 00:29D7: 65 2E        	adc	<L366+fs_1
  9662 00:29D9: 85 05        	sta	<R1
  9663 00:29DB: A9 00 00     	lda	#$0
  9664 00:29DE: 65 30        	adc	<L366+fs_1+2
  9665 00:29E0: 85 07        	sta	<R1+2
  9666 00:29E2: D4 07        	pei	<R1+2
  9667 00:29E4: D4 05        	pei	<R1
  9668 00:29E6: 22 xx xx xx  	jsl	~~ld_dword
  9669 00:29EA: 85 09        	sta	<R2
  9670 00:29EC: 86 0B        	stx	<R2+2
  9671 00:29EE: A5 09        	lda	<R2
  9672 00:29F0: C9 52 52     	cmp	#<$41615252
  9673 00:29F3: D0 05        	bne	L407
  9674 00:29F5: A5 0B        	lda	<R2+2
  9675 00:29F7: C9 61 41     	cmp	#^$41615252
  9676                        L407:
  9677 00:29FA: F0 03        	beq	L408
  9678 00:29FC: 82 7E 00     	brl	L10197
  9679                        L408:
  9680 00:29FF: 18           	clc
  9681 00:2A00: A9 13 02     	lda	#$213
  9682 00:2A03: 65 2E        	adc	<L366+fs_1
  9683 00:2A05: 85 09        	sta	<R2
  9684 00:2A07: A9 00 00     	lda	#$0
  9685 00:2A0A: 65 30        	adc	<L366+fs_1+2
  9686 00:2A0C: 85 0B        	sta	<R2+2
  9687 00:2A0E: D4 0B        	pei	<R2+2
  9688 00:2A10: D4 09        	pei	<R2
  9689 00:2A12: 22 xx xx xx  	jsl	~~ld_dword
  9690 00:2A16: 85 0D        	sta	<R3
  9691 00:2A18: 86 0F        	stx	<R3+2
  9692 00:2A1A: A5 0D        	lda	<R3
  9693 00:2A1C: C9 72 72     	cmp	#<$61417272
  9694 00:2A1F: D0 05        	bne	L409
  9695 00:2A21: A5 0F        	lda	<R3+2
  9696 00:2A23: C9 41 61     	cmp	#^$61417272
  9697                        L409:
  9698 00:2A26: F0 03        	beq	L410
  9699 00:2A28: 82 52 00     	brl	L10197
  9700                        L410:
  9701                        ;#if (FF_FS_NOFSINFO & 1) == 0
  9702                        ;				fs->free_clst = ld_dword
                    (fs->win + FSI_Free_Count);
  9703 00:2A2B: 18           	clc
  9704 00:2A2C: A9 17 02     	lda	#$217
  9705 00:2A2F: 65 2E        	adc	<L366+fs_1
  Thu May 20 2021 21:37                                                Page 199


  9706 00:2A31: 85 01        	sta	<R0
  9707 00:2A33: A9 00 00     	lda	#$0
  9708 00:2A36: 65 30        	adc	<L366+fs_1+2
  9709 00:2A38: 85 03        	sta	<R0+2
  9710 00:2A3A: D4 03        	pei	<R0+2
  9711 00:2A3C: D4 01        	pei	<R0
  9712 00:2A3E: 22 xx xx xx  	jsl	~~ld_dword
  9713 00:2A42: 85 05        	sta	<R1
  9714 00:2A44: 86 07        	stx	<R1+2
  9715 00:2A46: A5 05        	lda	<R1
  9716 00:2A48: A0 0F 00     	ldy	#$f
  9717 00:2A4B: 97 2E        	sta	[<L366+fs_1],Y
  9718 00:2A4D: A5 07        	lda	<R1+2
  9719 00:2A4F: A0 11 00     	ldy	#$11
  9720 00:2A52: 97 2E        	sta	[<L366+fs_1],Y
  9721                        ;#endif
  9722                        ;#if (FF_FS_NOFSINFO & 2) == 0
  9723                        ;				fs->last_clst = ld_dword
                    (fs->win + FSI_Nxt_Free);
  9724 00:2A54: 18           	clc
  9725 00:2A55: A9 1B 02     	lda	#$21b
  9726 00:2A58: 65 2E        	adc	<L366+fs_1
  9727 00:2A5A: 85 01        	sta	<R0
  9728 00:2A5C: A9 00 00     	lda	#$0
  9729 00:2A5F: 65 30        	adc	<L366+fs_1+2
  9730 00:2A61: 85 03        	sta	<R0+2
  9731 00:2A63: D4 03        	pei	<R0+2
  9732 00:2A65: D4 01        	pei	<R0
  9733 00:2A67: 22 xx xx xx  	jsl	~~ld_dword
  9734 00:2A6B: 85 05        	sta	<R1
  9735 00:2A6D: 86 07        	stx	<R1+2
  9736 00:2A6F: A5 05        	lda	<R1
  9737 00:2A71: A0 0B 00     	ldy	#$b
  9738 00:2A74: 97 2E        	sta	[<L366+fs_1],Y
  9739 00:2A76: A5 07        	lda	<R1+2
  9740 00:2A78: A0 0D 00     	ldy	#$d
  9741 00:2A7B: 97 2E        	sta	[<L366+fs_1],Y
  9742                        ;#endif
  9743                        ;			}
  9744                        ;		}
  9745                        L10197:
  9746                        ;#endif	/* (FF_FS_NOFSINFO & 3) != 3 */
  9747                        ;#endif	/* !FF_FS_READONLY */
  9748                        ;	}
  9749                        L10196:
  9750                        ;
  9751                        ;	fs->fs_type = (BYTE)fmt;/* FAT sub-type */
  9752 00:2A7D: E2 20        	sep	#$20
  9753                        	longa	off
  9754 00:2A7F: A5 32        	lda	<L366+fmt_1
  9755 00:2A81: 87 2E        	sta	[<L366+fs_1]
  9756 00:2A83: C2 20        	rep	#$20
  9757                        	longa	on
  9758                        ;	fs->id = ++Fsid;		/* Volume mount 
                    ID */
  9759 00:2A85: EE xx xx     	inc	|~~Fsid
  9760 00:2A88: AD xx xx     	lda	|~~Fsid
  9761 00:2A8B: A0 05 00     	ldy	#$5
  Thu May 20 2021 21:37                                                Page 200


  9762 00:2A8E: 97 2E        	sta	[<L366+fs_1],Y
  9763                        ;#if FF_USE_LFN == 1
  9764                        ;	fs->lfnbuf = LfnBuf;	/* Static LFN working bu
                    ffer */
  9765                        ;#if FF_FS_EXFAT
  9766                        ;	fs->dirbuf = DirBuf;	/* Static directory bloc
                    k scratchpad buuffer */
  9767                        ;#endif
  9768                        ;#endif
  9769                        ;#if FF_FS_RPATH != 0
  9770                        ;	fs->cdir = 0;			/* Initialize cu
                    rrent directory */
  9771                        ;#endif
  9772                        ;#if FF_FS_LOCK != 0			/* Clear
                     file lock semaphores */
  9773                        ;	clear_lock(fs);
  9774                        ;#endif
  9775                        ;	return FR_OK;
  9776 00:2A90: A9 00 00     	lda	#$0
  9777 00:2A93: 82 4F F9     	brl	L368
  9778                        ;}
  9779             00000033   L365	equ	51
  9780             00000011   L366	equ	17
  9781                        	ends
  9782                        	efunc
  9783                        ;
  9784                        ;
  9785                        ;
  9786                        ;
  9787                        ;/*-----------------------------------------------
                    ------------------------*/
  9788                        ;/* Check if the file/directory object is valid or
                     not                    */
  9789                        ;/*-----------------------------------------------
                    ------------------------*/
  9790                        ;
  9791                        ;static FRESULT validate (	/* Returns FR_OK
                     or FR_INVALID_OBJECT */
  9792                        ;	FFOBJID* obj,			/* Pointer to th
                    e FFOBJID, the 1st member in the FIL/DIR object, to check va
                    lidity */
  9793                        ;	FATFS** rfs				/* Point
                    er to pointer to the owner filesystem object to return */
  9794                        ;)
  9795                        ;{
  9796                        	code
  9797                        	func
  9798                        ~~validate:
  9799                        	longa	on
  9800                        	longi	on
  9801 00:2A96: 3B           	tsc
  9802 00:2A97: 38           	sec
  9803 00:2A98: E9 06 00     	sbc	#L411
  9804 00:2A9B: 1B           	tcs
  9805 00:2A9C: 0B           	phd
  9806 00:2A9D: 5B           	tcd
  9807             00000004   obj_0	set	4
  9808             00000008   rfs_0	set	8
  Thu May 20 2021 21:37                                                Page 201


  9809                        ;	FRESULT res = FR_INVALID_OBJECT;
  9810                        ;
  9811                        ;
  9812                        ;	if (obj && obj->fs && obj->fs->fs_type && obj->i
                    d == obj->fs->id) {	/* Test if the object is valid */
  9813             00000000   res_1	set	0
  9814 00:2A9E: A9 09 00     	lda	#$9
  9815 00:2AA1: 85 05        	sta	<L412+res_1
  9816 00:2AA3: A5 0A        	lda	<L411+obj_0
  9817 00:2AA5: 05 0C        	ora	<L411+obj_0+2
  9818 00:2AA7: D0 03        	bne	L413
  9819 00:2AA9: 82 5D 00     	brl	L10198
  9820                        L413:
  9821 00:2AAC: A7 0A        	lda	[<L411+obj_0]
  9822 00:2AAE: A0 02 00     	ldy	#$2
  9823 00:2AB1: 17 0A        	ora	[<L411+obj_0],Y
  9824 00:2AB3: D0 03        	bne	L414
  9825 00:2AB5: 82 51 00     	brl	L10198
  9826                        L414:
  9827 00:2AB8: A7 0A        	lda	[<L411+obj_0]
  9828 00:2ABA: 85 01        	sta	<R0
  9829 00:2ABC: A0 02 00     	ldy	#$2
  9830 00:2ABF: B7 0A        	lda	[<L411+obj_0],Y
  9831 00:2AC1: 85 03        	sta	<R0+2
  9832 00:2AC3: A7 01        	lda	[<R0]
  9833 00:2AC5: 29 FF 00     	and	#$ff
  9834 00:2AC8: D0 03        	bne	L415
  9835 00:2ACA: 82 3C 00     	brl	L10198
  9836                        L415:
  9837 00:2ACD: A7 0A        	lda	[<L411+obj_0]
  9838 00:2ACF: 85 01        	sta	<R0
  9839 00:2AD1: A0 02 00     	ldy	#$2
  9840 00:2AD4: B7 0A        	lda	[<L411+obj_0],Y
  9841 00:2AD6: 85 03        	sta	<R0+2
  9842 00:2AD8: A0 04 00     	ldy	#$4
  9843 00:2ADB: B7 0A        	lda	[<L411+obj_0],Y
  9844 00:2ADD: A0 05 00     	ldy	#$5
  9845 00:2AE0: D7 01        	cmp	[<R0],Y
  9846 00:2AE2: F0 03        	beq	L416
  9847 00:2AE4: 82 22 00     	brl	L10198
  9848                        L416:
  9849                        ;#if FF_FS_REENTRANT
  9850                        ;		if (lock_fs(obj->fs)) {	/* Obtain the fi
                    lesystem object */
  9851                        ;			if (!(disk_status(obj->fs->pdrv)
                     & STA_NOINIT)) { /* Test if the phsical drive is kept initi
                    alized */
  9852                        ;				res = FR_OK;
  9853                        ;			} else {
  9854                        ;				unlock_fs(obj->fs, FR_OK
                    );
  9855                        ;			}
  9856                        ;		} else {
  9857                        ;			res = FR_TIMEOUT;
  9858                        ;		}
  9859                        ;#else
  9860                        ;		if (!(disk_status(obj->fs->pdrv) & STA_N
                    OINIT)) { /* Test if the phsical drive is kept initialized *
  Thu May 20 2021 21:37                                                Page 202


                    /
  9861 00:2AE7: A7 0A        	lda	[<L411+obj_0]
  9862 00:2AE9: 85 01        	sta	<R0
  9863 00:2AEB: A0 02 00     	ldy	#$2
  9864 00:2AEE: B7 0A        	lda	[<L411+obj_0],Y
  9865 00:2AF0: 85 03        	sta	<R0+2
  9866 00:2AF2: A0 01 00     	ldy	#$1
  9867 00:2AF5: B7 01        	lda	[<R0],Y
  9868 00:2AF7: 48           	pha
  9869 00:2AF8: 22 xx xx xx  	jsl	~~disk_status
  9870 00:2AFC: E2 20        	sep	#$20
  9871                        	longa	off
  9872 00:2AFE: 29 01        	and	#<$1
  9873 00:2B00: C2 20        	rep	#$20
  9874                        	longa	on
  9875 00:2B02: F0 03        	beq	L417
  9876 00:2B04: 82 02 00     	brl	L10199
  9877                        L417:
  9878                        ;			res = FR_OK;
  9879 00:2B07: 64 05        	stz	<L412+res_1
  9880                        ;		}
  9881                        ;#endif
  9882                        ;	}
  9883                        L10199:
  9884                        ;	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corre
                    sponding filesystem object */
  9885                        L10198:
  9886 00:2B09: A5 05        	lda	<L412+res_1
  9887 00:2B0B: F0 03        	beq	L419
  9888 00:2B0D: 82 0A 00     	brl	L418
  9889                        L419:
  9890 00:2B10: A0 02 00     	ldy	#$2
  9891 00:2B13: B7 0A        	lda	[<L411+obj_0],Y
  9892 00:2B15: AA           	tax
  9893 00:2B16: A7 0A        	lda	[<L411+obj_0]
  9894 00:2B18: 80 07        	bra	L420
  9895                        L418:
  9896 00:2B1A: A9 00 00     	lda	#$0
  9897 00:2B1D: AA           	tax
  9898 00:2B1E: A9 00 00     	lda	#$0
  9899                        L420:
  9900 00:2B21: 85 01        	sta	<R0
  9901 00:2B23: 86 03        	stx	<R0+2
  9902 00:2B25: A5 01        	lda	<R0
  9903 00:2B27: 87 0E        	sta	[<L411+rfs_0]
  9904 00:2B29: A5 03        	lda	<R0+2
  9905 00:2B2B: A0 02 00     	ldy	#$2
  9906 00:2B2E: 97 0E        	sta	[<L411+rfs_0],Y
  9907                        ;	return res;
  9908 00:2B30: A5 05        	lda	<L412+res_1
  9909                        L421:
  9910 00:2B32: A8           	tay
  9911 00:2B33: A5 08        	lda	<L411+2
  9912 00:2B35: 85 10        	sta	<L411+2+8
  9913 00:2B37: A5 07        	lda	<L411+1
  9914 00:2B39: 85 0F        	sta	<L411+1+8
  9915 00:2B3B: 2B           	pld
  9916 00:2B3C: 3B           	tsc
  Thu May 20 2021 21:37                                                Page 203


  9917 00:2B3D: 18           	clc
  9918 00:2B3E: 69 0E 00     	adc	#L411+8
  9919 00:2B41: 1B           	tcs
  9920 00:2B42: 98           	tya
  9921 00:2B43: 6B           	rtl
  9922                        ;}
  9923             00000006   L411	equ	6
  9924             00000005   L412	equ	5
  9925                        	ends
  9926                        	efunc
  9927                        ;
  9928                        ;
  9929                        ;
  9930                        ;
  9931                        ;/*-----------------------------------------------
                    ----------------------------
  9932                        ;
  9933                        ;   Public Functions (FatFs API)
  9934                        ;
  9935                        ;-------------------------------------------------
                    ---------------------------*/
  9936                        ;
  9937                        ;
  9938                        ;
  9939                        ;/*-----------------------------------------------
                    ------------------------*/
  9940                        ;/* Mount/Unmount a Logical Drive                 
                                            */
  9941                        ;/*-----------------------------------------------
                    ------------------------*/
  9942                        ;
  9943                        ;FRESULT f_mount (
  9944                        ;	FATFS* fs,			/* Pointer to th
                    e filesystem object to be registered (NULL:unmount)*/
  9945                        ;	const TCHAR* path,	/* Logical drive number 
                    to be mounted/unmounted */
  9946                        ;	BYTE opt			/* Mount option:
                     0=Do not mount (delayed mount), 1=Mount immediately */
  9947                        ;)
  9948                        ;{
  9949                        	code
  9950                        	xdef	~~f_mount
  9951                        	func
  9952                        ~~f_mount:
  9953                        	longa	on
  9954                        	longi	on
  9955 00:2B44: 3B           	tsc
  9956 00:2B45: 38           	sec
  9957 00:2B46: E9 14 00     	sbc	#L422
  9958 00:2B49: 1B           	tcs
  9959 00:2B4A: 0B           	phd
  9960 00:2B4B: 5B           	tcd
  9961             00000004   fs_0	set	4
  9962             00000008   path_0	set	8
  9963             0000000C   opt_0	set	12
  9964                        ;	FATFS *cfs;
  9965                        ;	int vol;
  9966                        ;	FRESULT res;
  Thu May 20 2021 21:37                                                Page 204


  9967                        ;	const TCHAR *rp = path;
  9968                        ;
  9969                        ;
  9970                        ;	/* Get logical drive number */
  9971                        ;	vol = get_ldnumber(&rp);
  9972             00000000   cfs_1	set	0
  9973             00000004   vol_1	set	4
  9974             00000006   res_1	set	6
  9975             00000008   rp_1	set	8
  9976 00:2B4C: A5 1C        	lda	<L422+path_0
  9977 00:2B4E: 85 11        	sta	<L423+rp_1
  9978 00:2B50: A5 1E        	lda	<L422+path_0+2
  9979 00:2B52: 85 13        	sta	<L423+rp_1+2
  9980 00:2B54: F4 00 00     	pea	#0
  9981 00:2B57: 18           	clc
  9982 00:2B58: 7B           	tdc
  9983 00:2B59: 69 11 00     	adc	#<L423+rp_1
  9984 00:2B5C: 48           	pha
  9985 00:2B5D: 22 xx xx xx  	jsl	~~get_ldnumber
  9986 00:2B61: 85 0D        	sta	<L423+vol_1
  9987                        ;	if (vol < 0) return FR_INVALID_DRIVE;
  9988 00:2B63: A5 0D        	lda	<L423+vol_1
  9989 00:2B65: 30 03        	bmi	L424
  9990 00:2B67: 82 15 00     	brl	L10200
  9991                        L424:
  9992 00:2B6A: A9 0B 00     	lda	#$b
  9993                        L425:
  9994 00:2B6D: A8           	tay
  9995 00:2B6E: A5 16        	lda	<L422+2
  9996 00:2B70: 85 20        	sta	<L422+2+10
  9997 00:2B72: A5 15        	lda	<L422+1
  9998 00:2B74: 85 1F        	sta	<L422+1+10
  9999 00:2B76: 2B           	pld
 10000 00:2B77: 3B           	tsc
 10001 00:2B78: 18           	clc
 10002 00:2B79: 69 1E 00     	adc	#L422+10
 10003 00:2B7C: 1B           	tcs
 10004 00:2B7D: 98           	tya
 10005 00:2B7E: 6B           	rtl
 10006                        ;	cfs = FatFs[vol];				
                    	/* Pointer to fs object */
 10007                        L10200:
 10008 00:2B7F: A5 0D        	lda	<L423+vol_1
 10009 00:2B81: 0A           	asl	A
 10010 00:2B82: 0A           	asl	A
 10011 00:2B83: 85 01        	sta	<R0
 10012 00:2B85: 18           	clc
 10013 00:2B86: A9 xx xx     	lda	#<~~FatFs
 10014 00:2B89: 65 01        	adc	<R0
 10015 00:2B8B: 85 05        	sta	<R1
 10016 00:2B8D: B2 05        	lda	(<R1)
 10017 00:2B8F: 85 09        	sta	<L423+cfs_1
 10018 00:2B91: A0 02 00     	ldy	#$2
 10019 00:2B94: B1 05        	lda	(<R1),Y
 10020 00:2B96: 85 0B        	sta	<L423+cfs_1+2
 10021                        ;
 10022                        ;	if (cfs) {
 10023 00:2B98: A5 09        	lda	<L423+cfs_1
  Thu May 20 2021 21:37                                                Page 205


 10024 00:2B9A: 05 0B        	ora	<L423+cfs_1+2
 10025 00:2B9C: D0 03        	bne	L426
 10026 00:2B9E: 82 08 00     	brl	L10201
 10027                        L426:
 10028                        ;#if FF_FS_LOCK != 0
 10029                        ;		clear_lock(cfs);
 10030                        ;#endif
 10031                        ;#if FF_FS_REENTRANT				
                    		/* Discard sync object of the current volume */
 10032                        ;		if (!ff_del_syncobj(cfs->sobj)) return F
                    R_INT_ERR;
 10033                        ;#endif
 10034                        ;		cfs->fs_type = 0;			
                    	/* Clear old fs object */
 10035 00:2BA1: E2 20        	sep	#$20
 10036                        	longa	off
 10037 00:2BA3: A9 00        	lda	#$0
 10038 00:2BA5: 87 09        	sta	[<L423+cfs_1]
 10039 00:2BA7: C2 20        	rep	#$20
 10040                        	longa	on
 10041                        ;	}
 10042                        ;
 10043                        ;	if (fs) {
 10044                        L10201:
 10045 00:2BA9: A5 18        	lda	<L422+fs_0
 10046 00:2BAB: 05 1A        	ora	<L422+fs_0+2
 10047 00:2BAD: D0 03        	bne	L427
 10048 00:2BAF: 82 08 00     	brl	L10202
 10049                        L427:
 10050                        ;		fs->fs_type = 0;			
                    	/* Clear new fs object */
 10051 00:2BB2: E2 20        	sep	#$20
 10052                        	longa	off
 10053 00:2BB4: A9 00        	lda	#$0
 10054 00:2BB6: 87 18        	sta	[<L422+fs_0]
 10055 00:2BB8: C2 20        	rep	#$20
 10056                        	longa	on
 10057                        ;#if FF_FS_REENTRANT				
                    		/* Create sync object for the new volume */
 10058                        ;		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj
                    )) return FR_INT_ERR;
 10059                        ;#endif
 10060                        ;	}
 10061                        ;	FatFs[vol] = fs;				
                    	/* Register new fs object */
 10062                        L10202:
 10063 00:2BBA: A5 0D        	lda	<L423+vol_1
 10064 00:2BBC: 0A           	asl	A
 10065 00:2BBD: 0A           	asl	A
 10066 00:2BBE: 85 01        	sta	<R0
 10067 00:2BC0: 18           	clc
 10068 00:2BC1: A9 xx xx     	lda	#<~~FatFs
 10069 00:2BC4: 65 01        	adc	<R0
 10070 00:2BC6: 85 05        	sta	<R1
 10071 00:2BC8: A5 18        	lda	<L422+fs_0
 10072 00:2BCA: 92 05        	sta	(<R1)
 10073 00:2BCC: A5 1A        	lda	<L422+fs_0+2
 10074 00:2BCE: A0 02 00     	ldy	#$2
  Thu May 20 2021 21:37                                                Page 206


 10075 00:2BD1: 91 05        	sta	(<R1),Y
 10076                        ;
 10077                        ;	if (opt == 0) return FR_OK;			
                    /* Do not mount now, it will be mounted later */
 10078 00:2BD3: A5 20        	lda	<L422+opt_0
 10079 00:2BD5: 29 FF 00     	and	#$ff
 10080 00:2BD8: F0 03        	beq	L428
 10081 00:2BDA: 82 06 00     	brl	L10203
 10082                        L428:
 10083 00:2BDD: A9 00 00     	lda	#$0
 10084 00:2BE0: 82 8A FF     	brl	L425
 10085                        ;
 10086                        ;	res = mount_volume(&path, &fs, 0);	/* Force
                     mounted the volume */
 10087                        L10203:
 10088 00:2BE3: F4 00 00     	pea	#<$0
 10089 00:2BE6: F4 00 00     	pea	#0
 10090 00:2BE9: 18           	clc
 10091 00:2BEA: 7B           	tdc
 10092 00:2BEB: 69 18 00     	adc	#<L422+fs_0
 10093 00:2BEE: 48           	pha
 10094 00:2BEF: F4 00 00     	pea	#0
 10095 00:2BF2: 18           	clc
 10096 00:2BF3: 7B           	tdc
 10097 00:2BF4: 69 1C 00     	adc	#<L422+path_0
 10098 00:2BF7: 48           	pha
 10099 00:2BF8: 22 xx xx xx  	jsl	~~mount_volume
 10100 00:2BFC: 85 0F        	sta	<L423+res_1
 10101                        ;	LEAVE_FF(fs, res);
 10102 00:2BFE: A5 0F        	lda	<L423+res_1
 10103 00:2C00: 82 6A FF     	brl	L425
 10104                        ;}
 10105             00000014   L422	equ	20
 10106             00000009   L423	equ	9
 10107                        	ends
 10108                        	efunc
 10109                        ;
 10110                        ;
 10111                        ;
 10112                        ;
 10113                        ;/*-----------------------------------------------
                    ------------------------*/
 10114                        ;/* Open or Create a File                         
                                            */
 10115                        ;/*-----------------------------------------------
                    ------------------------*/
 10116                        ;
 10117                        ;FRESULT f_open (
 10118                        ;	FIL* fp,			/* Pointer to th
                    e blank file object */
 10119                        ;	const TCHAR* path,	/* Pointer to the file n
                    ame */
 10120                        ;	BYTE mode			/* Access mode a
                    nd open mode flags */
 10121                        ;)
 10122                        ;{
 10123                        	code
 10124                        	xdef	~~f_open
  Thu May 20 2021 21:37                                                Page 207


 10125                        	func
 10126                        ~~f_open:
 10127                        	longa	on
 10128                        	longi	on
 10129 00:2C03: 3B           	tsc
 10130 00:2C04: 38           	sec
 10131 00:2C05: E9 52 00     	sbc	#L429
 10132 00:2C08: 1B           	tcs
 10133 00:2C09: 0B           	phd
 10134 00:2C0A: 5B           	tcd
 10135             00000004   fp_0	set	4
 10136             00000008   path_0	set	8
 10137             0000000C   mode_0	set	12
 10138                        ;	FRESULT res;
 10139                        ;	DIR dj;
 10140                        ;	FATFS *fs;
 10141                        ;#if !FF_FS_READONLY
 10142                        ;	DWORD cl, bcs, clst, tm;
 10143                        ;	LBA_t sc;
 10144                        ;	FSIZE_t ofs;
 10145                        ;#endif
 10146                        ;	DEF_NAMBUF
 10147                        ;
 10148                        ;
 10149                        ;	if (!fp) return FR_INVALID_OBJECT;
 10150             00000000   res_1	set	0
 10151             00000002   dj_1	set	2
 10152             0000002E   fs_1	set	46
 10153             00000032   cl_1	set	50
 10154             00000036   bcs_1	set	54
 10155             0000003A   clst_1	set	58
 10156             0000003E   tm_1	set	62
 10157             00000042   sc_1	set	66
 10158             00000046   ofs_1	set	70
 10159 00:2C0B: A5 56        	lda	<L429+fp_0
 10160 00:2C0D: 05 58        	ora	<L429+fp_0+2
 10161 00:2C0F: F0 03        	beq	L431
 10162 00:2C11: 82 15 00     	brl	L10204
 10163                        L431:
 10164 00:2C14: A9 09 00     	lda	#$9
 10165                        L432:
 10166 00:2C17: A8           	tay
 10167 00:2C18: A5 54        	lda	<L429+2
 10168 00:2C1A: 85 5E        	sta	<L429+2+10
 10169 00:2C1C: A5 53        	lda	<L429+1
 10170 00:2C1E: 85 5D        	sta	<L429+1+10
 10171 00:2C20: 2B           	pld
 10172 00:2C21: 3B           	tsc
 10173 00:2C22: 18           	clc
 10174 00:2C23: 69 5C 00     	adc	#L429+10
 10175 00:2C26: 1B           	tcs
 10176 00:2C27: 98           	tya
 10177 00:2C28: 6B           	rtl
 10178                        ;
 10179                        ;	/* Get logical drive number */
 10180                        ;	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_
                    WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | 
                    FA_OPEN_APPEND;
  Thu May 20 2021 21:37                                                Page 208


 10181                        L10204:
 10182 00:2C29: E2 20        	sep	#$20
 10183                        	longa	off
 10184 00:2C2B: A9 C0        	lda	#$c0
 10185 00:2C2D: 14 5E        	trb	<L429+mode_0
 10186 00:2C2F: C2 20        	rep	#$20
 10187                        	longa	on
 10188                        ;	res = mount_volume(&path, &fs, mode);
 10189 00:2C31: D4 5E        	pei	<L429+mode_0
 10190 00:2C33: F4 00 00     	pea	#0
 10191 00:2C36: 18           	clc
 10192 00:2C37: 7B           	tdc
 10193 00:2C38: 69 37 00     	adc	#<L430+fs_1
 10194 00:2C3B: 48           	pha
 10195 00:2C3C: F4 00 00     	pea	#0
 10196 00:2C3F: 18           	clc
 10197 00:2C40: 7B           	tdc
 10198 00:2C41: 69 5A 00     	adc	#<L429+path_0
 10199 00:2C44: 48           	pha
 10200 00:2C45: 22 xx xx xx  	jsl	~~mount_volume
 10201 00:2C49: 85 09        	sta	<L430+res_1
 10202                        ;	if (res == FR_OK) {
 10203 00:2C4B: A5 09        	lda	<L430+res_1
 10204 00:2C4D: F0 03        	beq	L433
 10205 00:2C4F: 82 3C 04     	brl	L10205
 10206                        L433:
 10207                        ;		dj.obj.fs = fs;
 10208 00:2C52: A5 37        	lda	<L430+fs_1
 10209 00:2C54: 85 0B        	sta	<L430+dj_1
 10210 00:2C56: A5 39        	lda	<L430+fs_1+2
 10211 00:2C58: 85 0D        	sta	<L430+dj_1+2
 10212                        ;		INIT_NAMBUF(fs);
 10213                        ;		res = follow_path(&dj, path);	/* Follo
                    w the file path */
 10214 00:2C5A: D4 5C        	pei	<L429+path_0+2
 10215 00:2C5C: D4 5A        	pei	<L429+path_0
 10216 00:2C5E: F4 00 00     	pea	#0
 10217 00:2C61: 18           	clc
 10218 00:2C62: 7B           	tdc
 10219 00:2C63: 69 0B 00     	adc	#<L430+dj_1
 10220 00:2C66: 48           	pha
 10221 00:2C67: 22 xx xx xx  	jsl	~~follow_path
 10222 00:2C6B: 85 09        	sta	<L430+res_1
 10223                        ;#if !FF_FS_READONLY	/* Read/Write configurat
                    ion */
 10224                        ;		if (res == FR_OK) {
 10225 00:2C6D: A5 09        	lda	<L430+res_1
 10226 00:2C6F: F0 03        	beq	L434
 10227 00:2C71: 82 12 00     	brl	L10206
 10228                        L434:
 10229                        ;			if (dj.fn[NSFLAG] & NS_NONAME) {
                    	/* Origin directory itself? */
 10230 00:2C74: E2 20        	sep	#$20
 10231                        	longa	off
 10232 00:2C76: A5 36        	lda	<L430+dj_1+43
 10233 00:2C78: 29 80        	and	#<$80
 10234 00:2C7A: C2 20        	rep	#$20
 10235                        	longa	on
  Thu May 20 2021 21:37                                                Page 209


 10236 00:2C7C: D0 03        	bne	L435
 10237 00:2C7E: 82 05 00     	brl	L10207
 10238                        L435:
 10239                        ;				res = FR_INVALID_NAME;
 10240 00:2C81: A9 06 00     	lda	#$6
 10241 00:2C84: 85 09        	sta	<L430+res_1
 10242                        ;			}
 10243                        ;#if FF_FS_LOCK != 0
 10244                        ;			else {
 10245                        ;				res = chk_lock(&dj, (mod
                    e & ~FA_READ) ? 1 : 0);		/* Check if the file can
                     be used */
 10246                        ;			}
 10247                        ;#endif
 10248                        ;		}
 10249                        L10207:
 10250                        ;		/* Create or Open a file */
 10251                        ;		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_A
                    LWAYS | FA_CREATE_NEW)) {
 10252                        L10206:
 10253 00:2C86: E2 20        	sep	#$20
 10254                        	longa	off
 10255 00:2C88: A5 5E        	lda	<L429+mode_0
 10256 00:2C8A: 29 1C        	and	#<$1c
 10257 00:2C8C: C2 20        	rep	#$20
 10258                        	longa	on
 10259 00:2C8E: D0 03        	bne	L436
 10260 00:2C90: 82 60 01     	brl	L10208
 10261                        L436:
 10262                        ;			if (res != FR_OK) {		
                    			/* No file, create new */
 10263 00:2C93: A5 09        	lda	<L430+res_1
 10264 00:2C95: D0 03        	bne	L437
 10265 00:2C97: 82 24 00     	brl	L10209
 10266                        L437:
 10267                        ;				if (res == FR_NO_FILE) {
                    		/* There is no file to open, create a new entry 
                    */
 10268 00:2C9A: A5 09        	lda	<L430+res_1
 10269 00:2C9C: C9 04 00     	cmp	#<$4
 10270 00:2C9F: F0 03        	beq	L438
 10271 00:2CA1: 82 0F 00     	brl	L10210
 10272                        L438:
 10273                        ;#if FF_FS_LOCK != 0
 10274                        ;					res = enq_lock()
                     ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 10275                        ;#else
 10276                        ;					res = dir_regist
                    er(&dj);
 10277 00:2CA4: F4 00 00     	pea	#0
 10278 00:2CA7: 18           	clc
 10279 00:2CA8: 7B           	tdc
 10280 00:2CA9: 69 0B 00     	adc	#<L430+dj_1
 10281 00:2CAC: 48           	pha
 10282 00:2CAD: 22 xx xx xx  	jsl	~~dir_register
 10283 00:2CB1: 85 09        	sta	<L430+res_1
 10284                        ;#endif
 10285                        ;				}
  Thu May 20 2021 21:37                                                Page 210


 10286                        ;				mode |= FA_CREATE_ALWAYS
                    ;		/* File is created */
 10287                        L10210:
 10288 00:2CB3: E2 20        	sep	#$20
 10289                        	longa	off
 10290 00:2CB5: A9 08        	lda	#$8
 10291 00:2CB7: 04 5E        	tsb	<L429+mode_0
 10292 00:2CB9: C2 20        	rep	#$20
 10293                        	longa	on
 10294                        ;			}
 10295                        ;			else {				
                    				/* Any object with the same name
                     is already existing */
 10296 00:2CBB: 82 27 00     	brl	L10211
 10297                        L10209:
 10298                        ;				if (dj.obj.attr & (AM_RD
                    O | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 10299 00:2CBE: E2 20        	sep	#$20
 10300                        	longa	off
 10301 00:2CC0: A5 11        	lda	<L430+dj_1+6
 10302 00:2CC2: 29 11        	and	#<$11
 10303 00:2CC4: C2 20        	rep	#$20
 10304                        	longa	on
 10305 00:2CC6: D0 03        	bne	L439
 10306 00:2CC8: 82 08 00     	brl	L10212
 10307                        L439:
 10308                        ;					res = FR_DENIED;
 10309 00:2CCB: A9 07 00     	lda	#$7
 10310 00:2CCE: 85 09        	sta	<L430+res_1
 10311                        ;				} else {
 10312 00:2CD0: 82 12 00     	brl	L10213
 10313                        L10212:
 10314                        ;					if (mode & FA_CR
                    EATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 10315 00:2CD3: E2 20        	sep	#$20
 10316                        	longa	off
 10317 00:2CD5: A5 5E        	lda	<L429+mode_0
 10318 00:2CD7: 29 04        	and	#<$4
 10319 00:2CD9: C2 20        	rep	#$20
 10320                        	longa	on
 10321 00:2CDB: D0 03        	bne	L440
 10322 00:2CDD: 82 05 00     	brl	L10214
 10323                        L440:
 10324 00:2CE0: A9 08 00     	lda	#$8
 10325 00:2CE3: 85 09        	sta	<L430+res_1
 10326                        ;				}
 10327                        L10214:
 10328                        L10213:
 10329                        ;			}
 10330                        L10211:
 10331                        ;			if (res == FR_OK && (mode & FA_C
                    REATE_ALWAYS)) {	/* Truncate the file if overwrite mode *
                    /
 10332 00:2CE5: A5 09        	lda	<L430+res_1
 10333 00:2CE7: F0 03        	beq	L441
 10334 00:2CE9: 82 04 01     	brl	L10215
 10335                        L441:
 10336 00:2CEC: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 211


 10337                        	longa	off
 10338 00:2CEE: A5 5E        	lda	<L429+mode_0
 10339 00:2CF0: 29 08        	and	#<$8
 10340 00:2CF2: C2 20        	rep	#$20
 10341                        	longa	on
 10342 00:2CF4: D0 03        	bne	L442
 10343 00:2CF6: 82 F7 00     	brl	L10215
 10344                        L442:
 10345                        ;#if FF_FS_EXFAT
 10346                        ;				if (fs->fs_type == FS_EX
                    FAT) {
 10347                        ;					/* Get current a
                    llocation info */
 10348                        ;					fp->obj.fs = fs;
 10349                        ;					init_alloc_info(
                    fs, &fp->obj);
 10350                        ;					/* Set directory
                     entry block initial state */
 10351                        ;					memset(fs->dirbu
                    f + 2, 0, 30);	/* Clear 85 entry except for NumSec */
 10352                        ;					memset(fs->dirbu
                    f + 38, 0, 26);	/* Clear C0 entry except for NumName and
                     NameHash */
 10353                        ;					fs->dirbuf[XDIR_
                    Attr] = AM_ARC;
 10354                        ;					st_dword(fs->dir
                    buf + XDIR_CrtTime, GET_FATTIME());
 10355                        ;					fs->dirbuf[XDIR_
                    GenFlags] = 1;
 10356                        ;					res = store_xdir
                    (&dj);
 10357                        ;					if (res == FR_OK
                     && fp->obj.sclust != 0) {	/* Remove the cluster chain if e
                    xist */
 10358                        ;						res = re
                    move_chain(&fp->obj, fp->obj.sclust, 0);
 10359                        ;						fs->last
                    _clst = fp->obj.sclust - 1;		/* Reuse the cluster hol
                    e */
 10360                        ;					}
 10361                        ;				} else
 10362                        ;#endif
 10363                        ;				{
 10364                        ;					/* Set directory
                     entry initial state */
 10365                        ;					tm = GET_FATTIME
                    ();					/* Set created time */
 10366 00:2CF9: A9 00 00     	lda	#$0
 10367 00:2CFC: 85 47        	sta	<L430+tm_1
 10368 00:2CFE: A9 21 50     	lda	#$5021
 10369 00:2D01: 85 49        	sta	<L430+tm_1+2
 10370                        ;					st_dword(dj.dir 
                    + DIR_CrtTime, tm);
 10371 00:2D03: D4 49        	pei	<L430+tm_1+2
 10372 00:2D05: D4 47        	pei	<L430+tm_1
 10373 00:2D07: 18           	clc
 10374 00:2D08: A9 0E 00     	lda	#$e
 10375 00:2D0B: 65 27        	adc	<L430+dj_1+28
  Thu May 20 2021 21:37                                                Page 212


 10376 00:2D0D: 85 01        	sta	<R0
 10377 00:2D0F: A9 00 00     	lda	#$0
 10378 00:2D12: 65 29        	adc	<L430+dj_1+30
 10379 00:2D14: 85 03        	sta	<R0+2
 10380 00:2D16: D4 03        	pei	<R0+2
 10381 00:2D18: D4 01        	pei	<R0
 10382 00:2D1A: 22 xx xx xx  	jsl	~~st_dword
 10383                        ;					st_dword(dj.dir 
                    + DIR_ModTime, tm);
 10384 00:2D1E: D4 49        	pei	<L430+tm_1+2
 10385 00:2D20: D4 47        	pei	<L430+tm_1
 10386 00:2D22: 18           	clc
 10387 00:2D23: A9 16 00     	lda	#$16
 10388 00:2D26: 65 27        	adc	<L430+dj_1+28
 10389 00:2D28: 85 01        	sta	<R0
 10390 00:2D2A: A9 00 00     	lda	#$0
 10391 00:2D2D: 65 29        	adc	<L430+dj_1+30
 10392 00:2D2F: 85 03        	sta	<R0+2
 10393 00:2D31: D4 03        	pei	<R0+2
 10394 00:2D33: D4 01        	pei	<R0
 10395 00:2D35: 22 xx xx xx  	jsl	~~st_dword
 10396                        ;					cl = ld_clust(fs
                    , dj.dir);			/* Get current cluster chain */
 10397 00:2D39: D4 29        	pei	<L430+dj_1+30
 10398 00:2D3B: D4 27        	pei	<L430+dj_1+28
 10399 00:2D3D: D4 39        	pei	<L430+fs_1+2
 10400 00:2D3F: D4 37        	pei	<L430+fs_1
 10401 00:2D41: 22 xx xx xx  	jsl	~~ld_clust
 10402 00:2D45: 85 3B        	sta	<L430+cl_1
 10403 00:2D47: 86 3D        	stx	<L430+cl_1+2
 10404                        ;					dj.dir[DIR_Attr]
                     = AM_ARC;			/* Reset attribute */
 10405 00:2D49: E2 20        	sep	#$20
 10406                        	longa	off
 10407 00:2D4B: A9 20        	lda	#$20
 10408 00:2D4D: A0 0B 00     	ldy	#$b
 10409 00:2D50: 97 27        	sta	[<L430+dj_1+28],Y
 10410 00:2D52: C2 20        	rep	#$20
 10411                        	longa	on
 10412                        ;					st_clust(fs, dj.
                    dir, 0);			/* Reset file allocation info */
 10413 00:2D54: F4 00 00     	pea	#^$0
 10414 00:2D57: F4 00 00     	pea	#<$0
 10415 00:2D5A: D4 29        	pei	<L430+dj_1+30
 10416 00:2D5C: D4 27        	pei	<L430+dj_1+28
 10417 00:2D5E: D4 39        	pei	<L430+fs_1+2
 10418 00:2D60: D4 37        	pei	<L430+fs_1
 10419 00:2D62: 22 xx xx xx  	jsl	~~st_clust
 10420                        ;					st_dword(dj.dir 
                    + DIR_FileSize, 0);
 10421 00:2D66: F4 00 00     	pea	#^$0
 10422 00:2D69: F4 00 00     	pea	#<$0
 10423 00:2D6C: 18           	clc
 10424 00:2D6D: A9 1C 00     	lda	#$1c
 10425 00:2D70: 65 27        	adc	<L430+dj_1+28
 10426 00:2D72: 85 01        	sta	<R0
 10427 00:2D74: A9 00 00     	lda	#$0
 10428 00:2D77: 65 29        	adc	<L430+dj_1+30
  Thu May 20 2021 21:37                                                Page 213


 10429 00:2D79: 85 03        	sta	<R0+2
 10430 00:2D7B: D4 03        	pei	<R0+2
 10431 00:2D7D: D4 01        	pei	<R0
 10432 00:2D7F: 22 xx xx xx  	jsl	~~st_dword
 10433                        ;					fs->wflag = 1;
 10434 00:2D83: E2 20        	sep	#$20
 10435                        	longa	off
 10436 00:2D85: A9 01        	lda	#$1
 10437 00:2D87: A0 03 00     	ldy	#$3
 10438 00:2D8A: 97 37        	sta	[<L430+fs_1],Y
 10439 00:2D8C: C2 20        	rep	#$20
 10440                        	longa	on
 10441                        ;					if (cl != 0) {	
                    					/* Remove the cluster ch
                    ain if exist */
 10442 00:2D8E: A5 3B        	lda	<L430+cl_1
 10443 00:2D90: 05 3D        	ora	<L430+cl_1+2
 10444 00:2D92: D0 03        	bne	L443
 10445 00:2D94: 82 59 00     	brl	L10216
 10446                        L443:
 10447                        ;						sc = fs-
                    >winsect;
 10448 00:2D97: A0 2B 00     	ldy	#$2b
 10449 00:2D9A: B7 37        	lda	[<L430+fs_1],Y
 10450 00:2D9C: 85 4B        	sta	<L430+sc_1
 10451 00:2D9E: A0 2D 00     	ldy	#$2d
 10452 00:2DA1: B7 37        	lda	[<L430+fs_1],Y
 10453 00:2DA3: 85 4D        	sta	<L430+sc_1+2
 10454                        ;						res = re
                    move_chain(&dj.obj, cl, 0);
 10455 00:2DA5: F4 00 00     	pea	#^$0
 10456 00:2DA8: F4 00 00     	pea	#<$0
 10457 00:2DAB: D4 3D        	pei	<L430+cl_1+2
 10458 00:2DAD: D4 3B        	pei	<L430+cl_1
 10459 00:2DAF: F4 00 00     	pea	#0
 10460 00:2DB2: 18           	clc
 10461 00:2DB3: 7B           	tdc
 10462 00:2DB4: 69 0B 00     	adc	#<L430+dj_1
 10463 00:2DB7: 48           	pha
 10464 00:2DB8: 22 xx xx xx  	jsl	~~remove_chain
 10465 00:2DBC: 85 09        	sta	<L430+res_1
 10466                        ;						if (res 
                    == FR_OK) {
 10467 00:2DBE: A5 09        	lda	<L430+res_1
 10468 00:2DC0: F0 03        	beq	L444
 10469 00:2DC2: 82 2B 00     	brl	L10217
 10470                        L444:
 10471                        ;							
                    res = move_window(fs, sc);
 10472 00:2DC5: D4 4D        	pei	<L430+sc_1+2
 10473 00:2DC7: D4 4B        	pei	<L430+sc_1
 10474 00:2DC9: D4 39        	pei	<L430+fs_1+2
 10475 00:2DCB: D4 37        	pei	<L430+fs_1
 10476 00:2DCD: 22 xx xx xx  	jsl	~~move_window
 10477 00:2DD1: 85 09        	sta	<L430+res_1
 10478                        ;							
                    fs->last_clst = cl - 1;		/* Reuse the cluster hol
                    e */
  Thu May 20 2021 21:37                                                Page 214


 10479 00:2DD3: 18           	clc
 10480 00:2DD4: A9 FF FF     	lda	#$ffff
 10481 00:2DD7: 65 3B        	adc	<L430+cl_1
 10482 00:2DD9: 85 01        	sta	<R0
 10483 00:2DDB: A9 FF FF     	lda	#$ffff
 10484 00:2DDE: 65 3D        	adc	<L430+cl_1+2
 10485 00:2DE0: 85 03        	sta	<R0+2
 10486 00:2DE2: A5 01        	lda	<R0
 10487 00:2DE4: A0 0B 00     	ldy	#$b
 10488 00:2DE7: 97 37        	sta	[<L430+fs_1],Y
 10489 00:2DE9: A5 03        	lda	<R0+2
 10490 00:2DEB: A0 0D 00     	ldy	#$d
 10491 00:2DEE: 97 37        	sta	[<L430+fs_1],Y
 10492                        ;						}
 10493                        ;					}
 10494                        L10217:
 10495                        ;				}
 10496                        L10216:
 10497                        ;			}
 10498                        ;		}
 10499                        L10215:
 10500                        ;		else {	/* Open an existing file */
 10501 00:2DF0: 82 3B 00     	brl	L10218
 10502                        L10208:
 10503                        ;			if (res == FR_OK) {		
                    			/* Is the object exsiting? */
 10504 00:2DF3: A5 09        	lda	<L430+res_1
 10505 00:2DF5: F0 03        	beq	L445
 10506 00:2DF7: 82 34 00     	brl	L10219
 10507                        L445:
 10508                        ;				if (dj.obj.attr & AM_DIR
                    ) {		/* File open against a directory */
 10509 00:2DFA: E2 20        	sep	#$20
 10510                        	longa	off
 10511 00:2DFC: A5 11        	lda	<L430+dj_1+6
 10512 00:2DFE: 29 10        	and	#<$10
 10513 00:2E00: C2 20        	rep	#$20
 10514                        	longa	on
 10515 00:2E02: D0 03        	bne	L446
 10516 00:2E04: 82 08 00     	brl	L10220
 10517                        L446:
 10518                        ;					res = FR_NO_FILE
                    ;
 10519 00:2E07: A9 04 00     	lda	#$4
 10520 00:2E0A: 85 09        	sta	<L430+res_1
 10521                        ;				} else {
 10522 00:2E0C: 82 1F 00     	brl	L10221
 10523                        L10220:
 10524                        ;					if ((mode & FA_W
                    RITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open agains
                    t R/O file */
 10525 00:2E0F: E2 20        	sep	#$20
 10526                        	longa	off
 10527 00:2E11: A5 5E        	lda	<L429+mode_0
 10528 00:2E13: 29 02        	and	#<$2
 10529 00:2E15: C2 20        	rep	#$20
 10530                        	longa	on
 10531 00:2E17: D0 03        	bne	L447
  Thu May 20 2021 21:37                                                Page 215


 10532 00:2E19: 82 12 00     	brl	L10222
 10533                        L447:
 10534 00:2E1C: E2 20        	sep	#$20
 10535                        	longa	off
 10536 00:2E1E: A5 11        	lda	<L430+dj_1+6
 10537 00:2E20: 29 01        	and	#<$1
 10538 00:2E22: C2 20        	rep	#$20
 10539                        	longa	on
 10540 00:2E24: D0 03        	bne	L448
 10541 00:2E26: 82 05 00     	brl	L10222
 10542                        L448:
 10543                        ;						res = FR
                    _DENIED;
 10544 00:2E29: A9 07 00     	lda	#$7
 10545 00:2E2C: 85 09        	sta	<L430+res_1
 10546                        ;					}
 10547                        ;				}
 10548                        L10222:
 10549                        L10221:
 10550                        ;			}
 10551                        ;		}
 10552                        L10219:
 10553                        L10218:
 10554                        ;		if (res == FR_OK) {
 10555 00:2E2E: A5 09        	lda	<L430+res_1
 10556 00:2E30: F0 03        	beq	L449
 10557 00:2E32: 82 37 00     	brl	L10223
 10558                        L449:
 10559                        ;			if (mode & FA_CREATE_ALWAYS) mod
                    e |= FA_MODIFIED;	/* Set file change flag if created or ov
                    erwritten */
 10560 00:2E35: E2 20        	sep	#$20
 10561                        	longa	off
 10562 00:2E37: A5 5E        	lda	<L429+mode_0
 10563 00:2E39: 29 08        	and	#<$8
 10564 00:2E3B: C2 20        	rep	#$20
 10565                        	longa	on
 10566 00:2E3D: D0 03        	bne	L450
 10567 00:2E3F: 82 08 00     	brl	L10224
 10568                        L450:
 10569 00:2E42: E2 20        	sep	#$20
 10570                        	longa	off
 10571 00:2E44: A9 40        	lda	#$40
 10572 00:2E46: 04 5E        	tsb	<L429+mode_0
 10573 00:2E48: C2 20        	rep	#$20
 10574                        	longa	on
 10575                        ;			fp->dir_sect = fs->winsect;	
                    		/* Pointer to the directory entry */
 10576                        L10224:
 10577 00:2E4A: A0 2B 00     	ldy	#$2b
 10578 00:2E4D: B7 37        	lda	[<L430+fs_1],Y
 10579 00:2E4F: A0 1E 00     	ldy	#$1e
 10580 00:2E52: 97 56        	sta	[<L429+fp_0],Y
 10581 00:2E54: A0 2D 00     	ldy	#$2d
 10582 00:2E57: B7 37        	lda	[<L430+fs_1],Y
 10583 00:2E59: A0 20 00     	ldy	#$20
 10584 00:2E5C: 97 56        	sta	[<L429+fp_0],Y
 10585                        ;			fp->dir_ptr = dj.dir;
  Thu May 20 2021 21:37                                                Page 216


 10586 00:2E5E: A5 27        	lda	<L430+dj_1+28
 10587 00:2E60: A0 22 00     	ldy	#$22
 10588 00:2E63: 97 56        	sta	[<L429+fp_0],Y
 10589 00:2E65: A5 29        	lda	<L430+dj_1+30
 10590 00:2E67: A0 24 00     	ldy	#$24
 10591 00:2E6A: 97 56        	sta	[<L429+fp_0],Y
 10592                        ;#if FF_FS_LOCK != 0
 10593                        ;			fp->obj.lockid = inc_lock(&dj, (
                    mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this sessio
                    n */
 10594                        ;			if (fp->obj.lockid == 0) res = F
                    R_INT_ERR;
 10595                        ;#endif
 10596                        ;		}
 10597                        ;#else		/* R/O configuration */
 10598                        ;		if (res == FR_OK) {
 10599                        ;			if (dj.fn[NSFLAG] & NS_NONAME) {
                    	/* Is it origin directory itself? */
 10600                        ;				res = FR_INVALID_NAME;
 10601                        ;			} else {
 10602                        ;				if (dj.obj.attr & AM_DIR
                    ) {		/* Is it a directory? */
 10603                        ;					res = FR_NO_FILE
                    ;
 10604                        ;				}
 10605                        ;			}
 10606                        ;		}
 10607                        ;#endif
 10608                        ;
 10609                        ;		if (res == FR_OK) {
 10610                        L10223:
 10611 00:2E6C: A5 09        	lda	<L430+res_1
 10612 00:2E6E: F0 03        	beq	L451
 10613 00:2E70: 82 1B 02     	brl	L10225
 10614                        L451:
 10615                        ;#if FF_FS_EXFAT
 10616                        ;			if (fs->fs_type == FS_EXFAT) {
 10617                        ;				fp->obj.c_scl = dj.obj.s
                    clust;							
                    /* Get containing directory info */
 10618                        ;				fp->obj.c_size = ((DWORD
                    )dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 10619                        ;				fp->obj.c_ofs = dj.blk_o
                    fs;
 10620                        ;				init_alloc_info(fs, &fp-
                    >obj);
 10621                        ;			} else
 10622                        ;#endif
 10623                        ;			{
 10624                        ;				fp->obj.sclust = ld_clus
                    t(fs, dj.dir);					/* Get o
                    bject allocation info */
 10625 00:2E73: D4 29        	pei	<L430+dj_1+30
 10626 00:2E75: D4 27        	pei	<L430+dj_1+28
 10627 00:2E77: D4 39        	pei	<L430+fs_1+2
 10628 00:2E79: D4 37        	pei	<L430+fs_1
 10629 00:2E7B: 22 xx xx xx  	jsl	~~ld_clust
 10630 00:2E7F: 85 01        	sta	<R0
  Thu May 20 2021 21:37                                                Page 217


 10631 00:2E81: 86 03        	stx	<R0+2
 10632 00:2E83: A5 01        	lda	<R0
 10633 00:2E85: A0 08 00     	ldy	#$8
 10634 00:2E88: 97 56        	sta	[<L429+fp_0],Y
 10635 00:2E8A: A5 03        	lda	<R0+2
 10636 00:2E8C: A0 0A 00     	ldy	#$a
 10637 00:2E8F: 97 56        	sta	[<L429+fp_0],Y
 10638                        ;				fp->obj.objsize = ld_dwo
                    rd(dj.dir + DIR_FileSize);
 10639 00:2E91: 18           	clc
 10640 00:2E92: A9 1C 00     	lda	#$1c
 10641 00:2E95: 65 27        	adc	<L430+dj_1+28
 10642 00:2E97: 85 01        	sta	<R0
 10643 00:2E99: A9 00 00     	lda	#$0
 10644 00:2E9C: 65 29        	adc	<L430+dj_1+30
 10645 00:2E9E: 85 03        	sta	<R0+2
 10646 00:2EA0: D4 03        	pei	<R0+2
 10647 00:2EA2: D4 01        	pei	<R0
 10648 00:2EA4: 22 xx xx xx  	jsl	~~ld_dword
 10649 00:2EA8: 85 05        	sta	<R1
 10650 00:2EAA: 86 07        	stx	<R1+2
 10651 00:2EAC: A5 05        	lda	<R1
 10652 00:2EAE: A0 0C 00     	ldy	#$c
 10653 00:2EB1: 97 56        	sta	[<L429+fp_0],Y
 10654 00:2EB3: A5 07        	lda	<R1+2
 10655 00:2EB5: A0 0E 00     	ldy	#$e
 10656 00:2EB8: 97 56        	sta	[<L429+fp_0],Y
 10657                        ;			}
 10658                        ;#if FF_USE_FASTSEEK
 10659                        ;			fp->cltbl = 0;		/* Disab
                    le fast seek mode */
 10660                        ;#endif
 10661                        ;			fp->obj.fs = fs;	/* Valid
                    ate the file object */
 10662 00:2EBA: A5 37        	lda	<L430+fs_1
 10663 00:2EBC: 87 56        	sta	[<L429+fp_0]
 10664 00:2EBE: A5 39        	lda	<L430+fs_1+2
 10665 00:2EC0: A0 02 00     	ldy	#$2
 10666 00:2EC3: 97 56        	sta	[<L429+fp_0],Y
 10667                        ;			fp->obj.id = fs->id;
 10668 00:2EC5: A0 05 00     	ldy	#$5
 10669 00:2EC8: B7 37        	lda	[<L430+fs_1],Y
 10670 00:2ECA: A0 04 00     	ldy	#$4
 10671 00:2ECD: 97 56        	sta	[<L429+fp_0],Y
 10672                        ;			fp->flag = mode;	/* Set f
                    ile access mode */
 10673 00:2ECF: E2 20        	sep	#$20
 10674                        	longa	off
 10675 00:2ED1: A5 5E        	lda	<L429+mode_0
 10676 00:2ED3: A0 10 00     	ldy	#$10
 10677 00:2ED6: 97 56        	sta	[<L429+fp_0],Y
 10678 00:2ED8: C2 20        	rep	#$20
 10679                        	longa	on
 10680                        ;			fp->err = 0;		/* Clear
                     error flag */
 10681 00:2EDA: E2 20        	sep	#$20
 10682                        	longa	off
 10683 00:2EDC: A9 00        	lda	#$0
  Thu May 20 2021 21:37                                                Page 218


 10684 00:2EDE: A0 11 00     	ldy	#$11
 10685 00:2EE1: 97 56        	sta	[<L429+fp_0],Y
 10686 00:2EE3: C2 20        	rep	#$20
 10687                        	longa	on
 10688                        ;			fp->sect = 0;		/* Inval
                    idate current data sector */
 10689 00:2EE5: A9 00 00     	lda	#$0
 10690 00:2EE8: A0 1A 00     	ldy	#$1a
 10691 00:2EEB: 97 56        	sta	[<L429+fp_0],Y
 10692 00:2EED: A9 00 00     	lda	#$0
 10693 00:2EF0: A0 1C 00     	ldy	#$1c
 10694 00:2EF3: 97 56        	sta	[<L429+fp_0],Y
 10695                        ;			fp->fptr = 0;		/* Set f
                    ile pointer top of the file */
 10696 00:2EF5: A9 00 00     	lda	#$0
 10697 00:2EF8: A0 12 00     	ldy	#$12
 10698 00:2EFB: 97 56        	sta	[<L429+fp_0],Y
 10699 00:2EFD: A9 00 00     	lda	#$0
 10700 00:2F00: A0 14 00     	ldy	#$14
 10701 00:2F03: 97 56        	sta	[<L429+fp_0],Y
 10702                        ;#if !FF_FS_READONLY
 10703                        ;#if !FF_FS_TINY
 10704                        ;			memset(fp->buf, 0, sizeof fp->bu
                    f);	/* Clear sector buffer */
 10705 00:2F05: F4 00 02     	pea	#<$200
 10706 00:2F08: F4 00 00     	pea	#<$0
 10707 00:2F0B: 18           	clc
 10708 00:2F0C: A9 26 00     	lda	#$26
 10709 00:2F0F: 65 56        	adc	<L429+fp_0
 10710 00:2F11: 85 01        	sta	<R0
 10711 00:2F13: A9 00 00     	lda	#$0
 10712 00:2F16: 65 58        	adc	<L429+fp_0+2
 10713 00:2F18: 85 03        	sta	<R0+2
 10714 00:2F1A: D4 03        	pei	<R0+2
 10715 00:2F1C: D4 01        	pei	<R0
 10716 00:2F1E: 22 xx xx xx  	jsl	~~memset
 10717                        ;#endif
 10718                        ;			if ((mode & FA_SEEKEND) && fp->o
                    bj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND
                     is specified */
 10719 00:2F22: E2 20        	sep	#$20
 10720                        	longa	off
 10721 00:2F24: A5 5E        	lda	<L429+mode_0
 10722 00:2F26: 29 20        	and	#<$20
 10723 00:2F28: C2 20        	rep	#$20
 10724                        	longa	on
 10725 00:2F2A: D0 03        	bne	L452
 10726 00:2F2C: 82 5F 01     	brl	L10226
 10727                        L452:
 10728 00:2F2F: A9 00 00     	lda	#$0
 10729 00:2F32: A0 0C 00     	ldy	#$c
 10730 00:2F35: D7 56        	cmp	[<L429+fp_0],Y
 10731 00:2F37: A9 00 00     	lda	#$0
 10732 00:2F3A: A0 0E 00     	ldy	#$e
 10733 00:2F3D: F7 56        	sbc	[<L429+fp_0],Y
 10734 00:2F3F: 90 03        	bcc	L453
 10735 00:2F41: 82 4A 01     	brl	L10226
 10736                        L453:
  Thu May 20 2021 21:37                                                Page 219


 10737                        ;				fp->fptr = fp->obj.objsi
                    ze;			/* Offset to seek */
 10738 00:2F44: A0 0C 00     	ldy	#$c
 10739 00:2F47: B7 56        	lda	[<L429+fp_0],Y
 10740 00:2F49: A0 12 00     	ldy	#$12
 10741 00:2F4C: 97 56        	sta	[<L429+fp_0],Y
 10742 00:2F4E: A0 0E 00     	ldy	#$e
 10743 00:2F51: B7 56        	lda	[<L429+fp_0],Y
 10744 00:2F53: A0 14 00     	ldy	#$14
 10745 00:2F56: 97 56        	sta	[<L429+fp_0],Y
 10746                        ;				bcs = (DWORD)fs->csize *
                     SS(fs);	/* Cluster size in byte */
 10747 00:2F58: A0 09 00     	ldy	#$9
 10748 00:2F5B: B7 37        	lda	[<L430+fs_1],Y
 10749 00:2F5D: 85 01        	sta	<R0
 10750 00:2F5F: 64 03        	stz	<R0+2
 10751 00:2F61: D4 03        	pei	<R0+2
 10752 00:2F63: D4 01        	pei	<R0
 10753 00:2F65: A9 09 00     	lda	#$9
 10754                        	xref	~~~lasl
 10755 00:2F68: 22 xx xx xx  	jsl	~~~lasl
 10756 00:2F6C: 85 3F        	sta	<L430+bcs_1
 10757 00:2F6E: 86 41        	stx	<L430+bcs_1+2
 10758                        ;				clst = fp->obj.sclust;	
                    			/* Follow the cluster chain */
 10759 00:2F70: A0 08 00     	ldy	#$8
 10760 00:2F73: B7 56        	lda	[<L429+fp_0],Y
 10761 00:2F75: 85 43        	sta	<L430+clst_1
 10762 00:2F77: A0 0A 00     	ldy	#$a
 10763 00:2F7A: B7 56        	lda	[<L429+fp_0],Y
 10764 00:2F7C: 85 45        	sta	<L430+clst_1+2
 10765                        ;				for (ofs = fp->obj.objsi
                    ze; res == FR_OK && ofs > bcs; ofs -= bcs) {
 10766 00:2F7E: A0 0C 00     	ldy	#$c
 10767 00:2F81: B7 56        	lda	[<L429+fp_0],Y
 10768 00:2F83: 85 4F        	sta	<L430+ofs_1
 10769 00:2F85: A0 0E 00     	ldy	#$e
 10770 00:2F88: B7 56        	lda	[<L429+fp_0],Y
 10771 00:2F8A: 85 51        	sta	<L430+ofs_1+2
 10772 00:2F8C: 82 0D 00     	brl	L10228
 10773                        L10227:
 10774 00:2F8F: 38           	sec
 10775 00:2F90: A5 4F        	lda	<L430+ofs_1
 10776 00:2F92: E5 3F        	sbc	<L430+bcs_1
 10777 00:2F94: 85 4F        	sta	<L430+ofs_1
 10778 00:2F96: A5 51        	lda	<L430+ofs_1+2
 10779 00:2F98: E5 41        	sbc	<L430+bcs_1+2
 10780 00:2F9A: 85 51        	sta	<L430+ofs_1+2
 10781                        L10228:
 10782 00:2F9C: A5 09        	lda	<L430+res_1
 10783 00:2F9E: F0 03        	beq	L454
 10784 00:2FA0: 82 4A 00     	brl	L10229
 10785                        L454:
 10786 00:2FA3: A5 3F        	lda	<L430+bcs_1
 10787 00:2FA5: C5 4F        	cmp	<L430+ofs_1
 10788 00:2FA7: A5 41        	lda	<L430+bcs_1+2
 10789 00:2FA9: E5 51        	sbc	<L430+ofs_1+2
 10790 00:2FAB: 90 03        	bcc	L455
  Thu May 20 2021 21:37                                                Page 220


 10791 00:2FAD: 82 3D 00     	brl	L10229
 10792                        L455:
 10793                        ;					clst = get_fat(&
                    fp->obj, clst);
 10794 00:2FB0: D4 45        	pei	<L430+clst_1+2
 10795 00:2FB2: D4 43        	pei	<L430+clst_1
 10796 00:2FB4: D4 58        	pei	<L429+fp_0+2
 10797 00:2FB6: D4 56        	pei	<L429+fp_0
 10798 00:2FB8: 22 xx xx xx  	jsl	~~get_fat
 10799 00:2FBC: 85 43        	sta	<L430+clst_1
 10800 00:2FBE: 86 45        	stx	<L430+clst_1+2
 10801                        ;					if (clst <= 1) r
                    es = FR_INT_ERR;
 10802 00:2FC0: A9 01 00     	lda	#$1
 10803 00:2FC3: C5 43        	cmp	<L430+clst_1
 10804 00:2FC5: A9 00 00     	lda	#$0
 10805 00:2FC8: E5 45        	sbc	<L430+clst_1+2
 10806 00:2FCA: B0 03        	bcs	L456
 10807 00:2FCC: 82 05 00     	brl	L10230
 10808                        L456:
 10809 00:2FCF: A9 02 00     	lda	#$2
 10810 00:2FD2: 85 09        	sta	<L430+res_1
 10811                        ;					if (clst == 0xFF
                    FFFFFF) res = FR_DISK_ERR;
 10812                        L10230:
 10813 00:2FD4: A5 43        	lda	<L430+clst_1
 10814 00:2FD6: C9 FF FF     	cmp	#<$ffffffff
 10815 00:2FD9: D0 05        	bne	L457
 10816 00:2FDB: A5 45        	lda	<L430+clst_1+2
 10817 00:2FDD: C9 FF FF     	cmp	#^$ffffffff
 10818                        L457:
 10819 00:2FE0: F0 03        	beq	L458
 10820 00:2FE2: 82 05 00     	brl	L10231
 10821                        L458:
 10822 00:2FE5: A9 01 00     	lda	#$1
 10823 00:2FE8: 85 09        	sta	<L430+res_1
 10824                        ;				}
 10825                        L10231:
 10826 00:2FEA: 82 A2 FF     	brl	L10227
 10827                        L10229:
 10828                        ;				fp->clust = clst;
 10829 00:2FED: A5 43        	lda	<L430+clst_1
 10830 00:2FEF: A0 16 00     	ldy	#$16
 10831 00:2FF2: 97 56        	sta	[<L429+fp_0],Y
 10832 00:2FF4: A5 45        	lda	<L430+clst_1+2
 10833 00:2FF6: A0 18 00     	ldy	#$18
 10834 00:2FF9: 97 56        	sta	[<L429+fp_0],Y
 10835                        ;				if (res == FR_OK && ofs 
                    % SS(fs)) {	/* Fill sector buffer if not on the sector bound
                    ary */
 10836 00:2FFB: A5 09        	lda	<L430+res_1
 10837 00:2FFD: F0 03        	beq	L459
 10838 00:2FFF: 82 8C 00     	brl	L10232
 10839                        L459:
 10840 00:3002: A5 4F        	lda	<L430+ofs_1
 10841 00:3004: 29 FF 01     	and	#<$1ff
 10842 00:3007: D0 03        	bne	L460
 10843 00:3009: 82 82 00     	brl	L10232
  Thu May 20 2021 21:37                                                Page 221


 10844                        L460:
 10845                        ;					sc = clst2sect(f
                    s, clst);
 10846 00:300C: D4 45        	pei	<L430+clst_1+2
 10847 00:300E: D4 43        	pei	<L430+clst_1
 10848 00:3010: D4 39        	pei	<L430+fs_1+2
 10849 00:3012: D4 37        	pei	<L430+fs_1
 10850 00:3014: 22 xx xx xx  	jsl	~~clst2sect
 10851 00:3018: 85 4B        	sta	<L430+sc_1
 10852 00:301A: 86 4D        	stx	<L430+sc_1+2
 10853                        ;					if (sc == 0) {
 10854 00:301C: A5 4B        	lda	<L430+sc_1
 10855 00:301E: 05 4D        	ora	<L430+sc_1+2
 10856 00:3020: F0 03        	beq	L461
 10857 00:3022: 82 08 00     	brl	L10233
 10858                        L461:
 10859                        ;						res = FR
                    _INT_ERR;
 10860 00:3025: A9 02 00     	lda	#$2
 10861 00:3028: 85 09        	sta	<L430+res_1
 10862                        ;					} else {
 10863 00:302A: 82 61 00     	brl	L10234
 10864                        L10233:
 10865                        ;						fp->sect
                     = sc + (DWORD)(ofs / SS(fs));
 10866 00:302D: D4 51        	pei	<L430+ofs_1+2
 10867 00:302F: D4 4F        	pei	<L430+ofs_1
 10868 00:3031: A9 09 00     	lda	#$9
 10869                        	xref	~~~llsr
 10870 00:3034: 22 xx xx xx  	jsl	~~~llsr
 10871 00:3038: 85 01        	sta	<R0
 10872 00:303A: 86 03        	stx	<R0+2
 10873 00:303C: 18           	clc
 10874 00:303D: A5 01        	lda	<R0
 10875 00:303F: 65 4B        	adc	<L430+sc_1
 10876 00:3041: 85 05        	sta	<R1
 10877 00:3043: A5 03        	lda	<R0+2
 10878 00:3045: 65 4D        	adc	<L430+sc_1+2
 10879 00:3047: 85 07        	sta	<R1+2
 10880 00:3049: A5 05        	lda	<R1
 10881 00:304B: A0 1A 00     	ldy	#$1a
 10882 00:304E: 97 56        	sta	[<L429+fp_0],Y
 10883 00:3050: A5 07        	lda	<R1+2
 10884 00:3052: A0 1C 00     	ldy	#$1c
 10885 00:3055: 97 56        	sta	[<L429+fp_0],Y
 10886                        ;#if !FF_FS_TINY
 10887                        ;						if (disk
                    _read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DI
                    SK_ERR;
 10888 00:3057: F4 01 00     	pea	#<$1
 10889 00:305A: A0 1C 00     	ldy	#$1c
 10890 00:305D: B7 56        	lda	[<L429+fp_0],Y
 10891 00:305F: 48           	pha
 10892 00:3060: A0 1A 00     	ldy	#$1a
 10893 00:3063: B7 56        	lda	[<L429+fp_0],Y
 10894 00:3065: 48           	pha
 10895 00:3066: 18           	clc
 10896 00:3067: A9 26 00     	lda	#$26
  Thu May 20 2021 21:37                                                Page 222


 10897 00:306A: 65 56        	adc	<L429+fp_0
 10898 00:306C: 85 01        	sta	<R0
 10899 00:306E: A9 00 00     	lda	#$0
 10900 00:3071: 65 58        	adc	<L429+fp_0+2
 10901 00:3073: 85 03        	sta	<R0+2
 10902 00:3075: D4 03        	pei	<R0+2
 10903 00:3077: D4 01        	pei	<R0
 10904 00:3079: A0 01 00     	ldy	#$1
 10905 00:307C: B7 37        	lda	[<L430+fs_1],Y
 10906 00:307E: 48           	pha
 10907 00:307F: 22 xx xx xx  	jsl	~~disk_read
 10908 00:3083: AA           	tax
 10909 00:3084: D0 03        	bne	L462
 10910 00:3086: 82 05 00     	brl	L10235
 10911                        L462:
 10912 00:3089: A9 01 00     	lda	#$1
 10913 00:308C: 85 09        	sta	<L430+res_1
 10914                        ;#endif
 10915                        ;					}
 10916                        L10235:
 10917                        L10234:
 10918                        ;				}
 10919                        ;#if FF_FS_LOCK != 0
 10920                        ;				if (res != FR_OK) dec_lo
                    ck(fp->obj.lockid); /* Decrement file open counter if seek f
                    ailed */
 10921                        ;#endif
 10922                        ;			}
 10923                        L10232:
 10924                        ;#endif
 10925                        ;		}
 10926                        L10226:
 10927                        ;
 10928                        ;		FREE_NAMBUF();
 10929                        L10225:
 10930                        ;	}
 10931                        ;
 10932                        ;	if (res != FR_OK) fp->obj.fs = 0;	/* Inval
                    idate file object on error */
 10933                        L10205:
 10934 00:308E: A5 09        	lda	<L430+res_1
 10935 00:3090: D0 03        	bne	L463
 10936 00:3092: 82 0D 00     	brl	L10236
 10937                        L463:
 10938 00:3095: A9 00 00     	lda	#$0
 10939 00:3098: 87 56        	sta	[<L429+fp_0]
 10940 00:309A: A9 00 00     	lda	#$0
 10941 00:309D: A0 02 00     	ldy	#$2
 10942 00:30A0: 97 56        	sta	[<L429+fp_0],Y
 10943                        ;
 10944                        ;	LEAVE_FF(fs, res);
 10945                        L10236:
 10946 00:30A2: A5 09        	lda	<L430+res_1
 10947 00:30A4: 82 70 FB     	brl	L432
 10948                        ;}
 10949             00000052   L429	equ	82
 10950             00000009   L430	equ	9
 10951                        	ends
  Thu May 20 2021 21:37                                                Page 223


 10952                        	efunc
 10953                        ;
 10954                        ;
 10955                        ;
 10956                        ;
 10957                        ;/*-----------------------------------------------
                    ------------------------*/
 10958                        ;/* Read File                                     
                                            */
 10959                        ;/*-----------------------------------------------
                    ------------------------*/
 10960                        ;
 10961                        ;FRESULT f_read (
 10962                        ;	FIL* fp, 	/* Open file to be read */
 10963                        ;	void* buff,	/* Data buffer to store the read
                     data */
 10964                        ;	UINT btr,	/* Number of bytes to read */
 10965                        ;	UINT* br	/* Number of bytes read */
 10966                        ;)
 10967                        ;{
 10968                        	code
 10969                        	xdef	~~f_read
 10970                        	func
 10971                        ~~f_read:
 10972                        	longa	on
 10973                        	longi	on
 10974 00:30A7: 3B           	tsc
 10975 00:30A8: 38           	sec
 10976 00:30A9: E9 2C 00     	sbc	#L464
 10977 00:30AC: 1B           	tcs
 10978 00:30AD: 0B           	phd
 10979 00:30AE: 5B           	tcd
 10980             00000004   fp_0	set	4
 10981             00000008   buff_0	set	8
 10982             0000000C   btr_0	set	12
 10983             0000000E   br_0	set	14
 10984                        ;	FRESULT res;
 10985                        ;	FATFS *fs;
 10986                        ;	DWORD clst;
 10987                        ;	LBA_t sect;
 10988                        ;	FSIZE_t remain;
 10989                        ;	UINT rcnt, cc, csect;
 10990                        ;	BYTE *rbuff = (BYTE*)buff;
 10991                        ;
 10992                        ;
 10993                        ;	*br = 0;	/* Clear read byte counter */
 10994             00000000   res_1	set	0
 10995             00000002   fs_1	set	2
 10996             00000006   clst_1	set	6
 10997             0000000A   sect_1	set	10
 10998             0000000E   remain_1	set	14
 10999             00000012   rcnt_1	set	18
 11000             00000014   cc_1	set	20
 11001             00000016   csect_1	set	22
 11002             00000018   rbuff_1	set	24
 11003 00:30AF: A5 34        	lda	<L464+buff_0
 11004 00:30B1: 85 29        	sta	<L465+rbuff_1
 11005 00:30B3: A5 36        	lda	<L464+buff_0+2
  Thu May 20 2021 21:37                                                Page 224


 11006 00:30B5: 85 2B        	sta	<L465+rbuff_1+2
 11007 00:30B7: A9 00 00     	lda	#$0
 11008 00:30BA: 87 3A        	sta	[<L464+br_0]
 11009                        ;	res = validate(&fp->obj, &fs);			
                    	/* Check validity of the file object */
 11010 00:30BC: F4 00 00     	pea	#0
 11011 00:30BF: 18           	clc
 11012 00:30C0: 7B           	tdc
 11013 00:30C1: 69 13 00     	adc	#<L465+fs_1
 11014 00:30C4: 48           	pha
 11015 00:30C5: D4 32        	pei	<L464+fp_0+2
 11016 00:30C7: D4 30        	pei	<L464+fp_0
 11017 00:30C9: 22 xx xx xx  	jsl	~~validate
 11018 00:30CD: 85 11        	sta	<L465+res_1
 11019                        ;	if (res != FR_OK || (res = (FRESULT)fp->err) != 
                    FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 11020 00:30CF: A5 11        	lda	<L465+res_1
 11021 00:30D1: F0 03        	beq	L467
 11022 00:30D3: 82 11 00     	brl	L466
 11023                        L467:
 11024 00:30D6: A0 11 00     	ldy	#$11
 11025 00:30D9: B7 30        	lda	[<L464+fp_0],Y
 11026 00:30DB: 29 FF 00     	and	#$ff
 11027 00:30DE: 85 11        	sta	<L465+res_1
 11028 00:30E0: A5 11        	lda	<L465+res_1
 11029 00:30E2: D0 03        	bne	L468
 11030 00:30E4: 82 14 00     	brl	L10237
 11031                        L468:
 11032                        L466:
 11033 00:30E7: A5 11        	lda	<L465+res_1
 11034                        L469:
 11035 00:30E9: A8           	tay
 11036 00:30EA: A5 2E        	lda	<L464+2
 11037 00:30EC: 85 3C        	sta	<L464+2+14
 11038 00:30EE: A5 2D        	lda	<L464+1
 11039 00:30F0: 85 3B        	sta	<L464+1+14
 11040 00:30F2: 2B           	pld
 11041 00:30F3: 3B           	tsc
 11042 00:30F4: 18           	clc
 11043 00:30F5: 69 3A 00     	adc	#L464+14
 11044 00:30F8: 1B           	tcs
 11045 00:30F9: 98           	tya
 11046 00:30FA: 6B           	rtl
 11047                        ;	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIE
                    D); /* Check access mode */
 11048                        L10237:
 11049 00:30FB: E2 20        	sep	#$20
 11050                        	longa	off
 11051 00:30FD: A0 10 00     	ldy	#$10
 11052 00:3100: B7 30        	lda	[<L464+fp_0],Y
 11053 00:3102: 29 01        	and	#<$1
 11054 00:3104: C2 20        	rep	#$20
 11055                        	longa	on
 11056 00:3106: F0 03        	beq	L470
 11057 00:3108: 82 06 00     	brl	L10238
 11058                        L470:
 11059 00:310B: A9 07 00     	lda	#$7
 11060 00:310E: 82 D8 FF     	brl	L469
  Thu May 20 2021 21:37                                                Page 225


 11061                        ;	remain = fp->obj.objsize - fp->fptr;
 11062                        L10238:
 11063 00:3111: 38           	sec
 11064 00:3112: A0 0C 00     	ldy	#$c
 11065 00:3115: B7 30        	lda	[<L464+fp_0],Y
 11066 00:3117: A0 12 00     	ldy	#$12
 11067 00:311A: F7 30        	sbc	[<L464+fp_0],Y
 11068 00:311C: 85 1F        	sta	<L465+remain_1
 11069 00:311E: A0 0E 00     	ldy	#$e
 11070 00:3121: B7 30        	lda	[<L464+fp_0],Y
 11071 00:3123: A0 14 00     	ldy	#$14
 11072 00:3126: F7 30        	sbc	[<L464+fp_0],Y
 11073 00:3128: 85 21        	sta	<L465+remain_1+2
 11074                        ;	if (btr > remain) btr = (UINT)remain;		
                    /* Truncate btr by remaining bytes */
 11075 00:312A: A5 38        	lda	<L464+btr_0
 11076 00:312C: 85 01        	sta	<R0
 11077 00:312E: 64 03        	stz	<R0+2
 11078 00:3130: A5 1F        	lda	<L465+remain_1
 11079 00:3132: C5 01        	cmp	<R0
 11080 00:3134: A5 21        	lda	<L465+remain_1+2
 11081 00:3136: E5 03        	sbc	<R0+2
 11082 00:3138: 90 03        	bcc	L471
 11083 00:313A: 82 04 00     	brl	L10239
 11084                        L471:
 11085 00:313D: A5 1F        	lda	<L465+remain_1
 11086 00:313F: 85 38        	sta	<L464+btr_0
 11087                        ;
 11088                        ;	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff
                     += rcnt, fp->fptr += rcnt) {	/* Repeat until btr byte
                    s read */
 11089                        L10239:
 11090 00:3141: 82 49 00     	brl	L10241
 11091                        L10240:
 11092 00:3144: 38           	sec
 11093 00:3145: A5 38        	lda	<L464+btr_0
 11094 00:3147: E5 23        	sbc	<L465+rcnt_1
 11095 00:3149: 85 38        	sta	<L464+btr_0
 11096 00:314B: 18           	clc
 11097 00:314C: A7 3A        	lda	[<L464+br_0]
 11098 00:314E: 65 23        	adc	<L465+rcnt_1
 11099 00:3150: 87 3A        	sta	[<L464+br_0]
 11100 00:3152: A5 23        	lda	<L465+rcnt_1
 11101 00:3154: 85 01        	sta	<R0
 11102 00:3156: 64 03        	stz	<R0+2
 11103 00:3158: 18           	clc
 11104 00:3159: A5 29        	lda	<L465+rbuff_1
 11105 00:315B: 65 01        	adc	<R0
 11106 00:315D: 85 29        	sta	<L465+rbuff_1
 11107 00:315F: A5 2B        	lda	<L465+rbuff_1+2
 11108 00:3161: 65 03        	adc	<R0+2
 11109 00:3163: 85 2B        	sta	<L465+rbuff_1+2
 11110 00:3165: 18           	clc
 11111 00:3166: A9 12 00     	lda	#$12
 11112 00:3169: 65 30        	adc	<L464+fp_0
 11113 00:316B: 85 01        	sta	<R0
 11114 00:316D: A9 00 00     	lda	#$0
 11115 00:3170: 65 32        	adc	<L464+fp_0+2
  Thu May 20 2021 21:37                                                Page 226


 11116 00:3172: 85 03        	sta	<R0+2
 11117 00:3174: A5 23        	lda	<L465+rcnt_1
 11118 00:3176: 85 05        	sta	<R1
 11119 00:3178: 64 07        	stz	<R1+2
 11120 00:317A: 18           	clc
 11121 00:317B: A5 05        	lda	<R1
 11122 00:317D: 67 01        	adc	[<R0]
 11123 00:317F: 87 01        	sta	[<R0]
 11124 00:3181: A5 07        	lda	<R1+2
 11125 00:3183: A0 02 00     	ldy	#$2
 11126 00:3186: 77 01        	adc	[<R0],Y
 11127 00:3188: A0 02 00     	ldy	#$2
 11128 00:318B: 97 01        	sta	[<R0],Y
 11129                        L10241:
 11130 00:318D: A9 00 00     	lda	#$0
 11131 00:3190: C5 38        	cmp	<L464+btr_0
 11132 00:3192: 90 03        	bcc	L472
 11133 00:3194: 82 29 03     	brl	L10242
 11134                        L472:
 11135                        ;		if (fp->fptr % SS(fs) == 0) {		
                    	/* On the sector boundary? */
 11136 00:3197: A0 12 00     	ldy	#$12
 11137 00:319A: B7 30        	lda	[<L464+fp_0],Y
 11138 00:319C: 29 FF 01     	and	#<$1ff
 11139 00:319F: F0 03        	beq	L473
 11140 00:31A1: 82 C4 02     	brl	L10243
 11141                        L473:
 11142                        ;			csect = (UINT)(fp->fptr / SS(fs)
                     & (fs->csize - 1));	/* Sector offset in the cluster 
                    */
 11143 00:31A4: A0 14 00     	ldy	#$14
 11144 00:31A7: B7 30        	lda	[<L464+fp_0],Y
 11145 00:31A9: 48           	pha
 11146 00:31AA: A0 12 00     	ldy	#$12
 11147 00:31AD: B7 30        	lda	[<L464+fp_0],Y
 11148 00:31AF: 48           	pha
 11149 00:31B0: A9 09 00     	lda	#$9
 11150                        	xref	~~~llsr
 11151 00:31B3: 22 xx xx xx  	jsl	~~~llsr
 11152 00:31B7: 85 01        	sta	<R0
 11153 00:31B9: 86 03        	stx	<R0+2
 11154 00:31BB: 18           	clc
 11155 00:31BC: A9 FF FF     	lda	#$ffff
 11156 00:31BF: A0 09 00     	ldy	#$9
 11157 00:31C2: 77 13        	adc	[<L465+fs_1],Y
 11158 00:31C4: 85 05        	sta	<R1
 11159 00:31C6: A5 05        	lda	<R1
 11160 00:31C8: 85 05        	sta	<R1
 11161 00:31CA: 64 07        	stz	<R1+2
 11162 00:31CC: A5 05        	lda	<R1
 11163 00:31CE: 25 01        	and	<R0
 11164 00:31D0: 85 09        	sta	<R2
 11165 00:31D2: A5 07        	lda	<R1+2
 11166 00:31D4: 25 03        	and	<R0+2
 11167 00:31D6: 85 0B        	sta	<R2+2
 11168 00:31D8: A5 09        	lda	<R2
 11169 00:31DA: 85 27        	sta	<L465+csect_1
 11170                        ;			if (csect == 0) {		
  Thu May 20 2021 21:37                                                Page 227


                    			/* On the cluster boundary? */
 11171 00:31DC: A5 27        	lda	<L465+csect_1
 11172 00:31DE: F0 03        	beq	L474
 11173 00:31E0: 82 88 00     	brl	L10244
 11174                        L474:
 11175                        ;				if (fp->fptr == 0) {	
                    		/* On the top of the file? */
 11176 00:31E3: A0 12 00     	ldy	#$12
 11177 00:31E6: B7 30        	lda	[<L464+fp_0],Y
 11178 00:31E8: A0 14 00     	ldy	#$14
 11179 00:31EB: 17 30        	ora	[<L464+fp_0],Y
 11180 00:31ED: F0 03        	beq	L475
 11181 00:31EF: 82 11 00     	brl	L10245
 11182                        L475:
 11183                        ;					clst = fp->obj.s
                    clust;		/* Follow cluster chain from the origin 
                    */
 11184 00:31F2: A0 08 00     	ldy	#$8
 11185 00:31F5: B7 30        	lda	[<L464+fp_0],Y
 11186 00:31F7: 85 17        	sta	<L465+clst_1
 11187 00:31F9: A0 0A 00     	ldy	#$a
 11188 00:31FC: B7 30        	lda	[<L464+fp_0],Y
 11189 00:31FE: 85 19        	sta	<L465+clst_1+2
 11190                        ;				} else {		
                    				/* Middle or end of the file */
 11191 00:3200: 82 18 00     	brl	L10246
 11192                        L10245:
 11193                        ;#if FF_USE_FASTSEEK
 11194                        ;					if (fp->cltbl) {
 11195                        ;						clst = c
                    lmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 11196                        ;					} else
 11197                        ;#endif
 11198                        ;					{
 11199                        ;						clst = g
                    et_fat(&fp->obj, fp->clust);	/* Follow cluster chain 
                    on the FAT */
 11200 00:3203: A0 18 00     	ldy	#$18
 11201 00:3206: B7 30        	lda	[<L464+fp_0],Y
 11202 00:3208: 48           	pha
 11203 00:3209: A0 16 00     	ldy	#$16
 11204 00:320C: B7 30        	lda	[<L464+fp_0],Y
 11205 00:320E: 48           	pha
 11206 00:320F: D4 32        	pei	<L464+fp_0+2
 11207 00:3211: D4 30        	pei	<L464+fp_0
 11208 00:3213: 22 xx xx xx  	jsl	~~get_fat
 11209 00:3217: 85 17        	sta	<L465+clst_1
 11210 00:3219: 86 19        	stx	<L465+clst_1+2
 11211                        ;					}
 11212                        ;				}
 11213                        L10246:
 11214                        ;				if (clst < 2) ABORT(fs, 
                    FR_INT_ERR);
 11215 00:321B: A5 17        	lda	<L465+clst_1
 11216 00:321D: C9 02 00     	cmp	#<$2
 11217 00:3220: A5 19        	lda	<L465+clst_1+2
 11218 00:3222: E9 00 00     	sbc	#^$2
 11219 00:3225: 90 03        	bcc	L476
  Thu May 20 2021 21:37                                                Page 228


 11220 00:3227: 82 11 00     	brl	L10247
 11221                        L476:
 11222 00:322A: E2 20        	sep	#$20
 11223                        	longa	off
 11224 00:322C: A9 02        	lda	#$2
 11225 00:322E: A0 11 00     	ldy	#$11
 11226 00:3231: 97 30        	sta	[<L464+fp_0],Y
 11227 00:3233: C2 20        	rep	#$20
 11228                        	longa	on
 11229 00:3235: A9 02 00     	lda	#$2
 11230 00:3238: 82 AE FE     	brl	L469
 11231                        L10247:
 11232                        ;				if (clst == 0xFFFFFFFF) 
                    ABORT(fs, FR_DISK_ERR);
 11233 00:323B: A5 17        	lda	<L465+clst_1
 11234 00:323D: C9 FF FF     	cmp	#<$ffffffff
 11235 00:3240: D0 05        	bne	L477
 11236 00:3242: A5 19        	lda	<L465+clst_1+2
 11237 00:3244: C9 FF FF     	cmp	#^$ffffffff
 11238                        L477:
 11239 00:3247: F0 03        	beq	L478
 11240 00:3249: 82 11 00     	brl	L10248
 11241                        L478:
 11242 00:324C: E2 20        	sep	#$20
 11243                        	longa	off
 11244 00:324E: A9 01        	lda	#$1
 11245 00:3250: A0 11 00     	ldy	#$11
 11246 00:3253: 97 30        	sta	[<L464+fp_0],Y
 11247 00:3255: C2 20        	rep	#$20
 11248                        	longa	on
 11249 00:3257: A9 01 00     	lda	#$1
 11250 00:325A: 82 8C FE     	brl	L469
 11251                        L10248:
 11252                        ;				fp->clust = clst;	
                    			/* Update current cluster */
 11253 00:325D: A5 17        	lda	<L465+clst_1
 11254 00:325F: A0 16 00     	ldy	#$16
 11255 00:3262: 97 30        	sta	[<L464+fp_0],Y
 11256 00:3264: A5 19        	lda	<L465+clst_1+2
 11257 00:3266: A0 18 00     	ldy	#$18
 11258 00:3269: 97 30        	sta	[<L464+fp_0],Y
 11259                        ;			}
 11260                        ;			sect = clst2sect(fs, fp->clust);
                    	/* Get current sector */
 11261                        L10244:
 11262 00:326B: A0 18 00     	ldy	#$18
 11263 00:326E: B7 30        	lda	[<L464+fp_0],Y
 11264 00:3270: 48           	pha
 11265 00:3271: A0 16 00     	ldy	#$16
 11266 00:3274: B7 30        	lda	[<L464+fp_0],Y
 11267 00:3276: 48           	pha
 11268 00:3277: D4 15        	pei	<L465+fs_1+2
 11269 00:3279: D4 13        	pei	<L465+fs_1
 11270 00:327B: 22 xx xx xx  	jsl	~~clst2sect
 11271 00:327F: 85 1B        	sta	<L465+sect_1
 11272 00:3281: 86 1D        	stx	<L465+sect_1+2
 11273                        ;			if (sect == 0) ABORT(fs, FR_INT_
                    ERR);
  Thu May 20 2021 21:37                                                Page 229


 11274 00:3283: A5 1B        	lda	<L465+sect_1
 11275 00:3285: 05 1D        	ora	<L465+sect_1+2
 11276 00:3287: F0 03        	beq	L479
 11277 00:3289: 82 11 00     	brl	L10249
 11278                        L479:
 11279 00:328C: E2 20        	sep	#$20
 11280                        	longa	off
 11281 00:328E: A9 02        	lda	#$2
 11282 00:3290: A0 11 00     	ldy	#$11
 11283 00:3293: 97 30        	sta	[<L464+fp_0],Y
 11284 00:3295: C2 20        	rep	#$20
 11285                        	longa	on
 11286 00:3297: A9 02 00     	lda	#$2
 11287 00:329A: 82 4C FE     	brl	L469
 11288                        L10249:
 11289                        ;			sect += csect;
 11290 00:329D: A5 27        	lda	<L465+csect_1
 11291 00:329F: 85 01        	sta	<R0
 11292 00:32A1: 64 03        	stz	<R0+2
 11293 00:32A3: 18           	clc
 11294 00:32A4: A5 01        	lda	<R0
 11295 00:32A6: 65 1B        	adc	<L465+sect_1
 11296 00:32A8: 85 1B        	sta	<L465+sect_1
 11297 00:32AA: A5 03        	lda	<R0+2
 11298 00:32AC: 65 1D        	adc	<L465+sect_1+2
 11299 00:32AE: 85 1D        	sta	<L465+sect_1+2
 11300                        ;			cc = btr / SS(fs);		
                    			/* When remaining bytes >= sector size, 
                    */
 11301 00:32B0: A5 38        	lda	<L464+btr_0
 11302 00:32B2: A2 09 00     	ldx	#<$9
 11303                        	xref	~~~lsr
 11304 00:32B5: 22 xx xx xx  	jsl	~~~lsr
 11305 00:32B9: 85 25        	sta	<L465+cc_1
 11306                        ;			if (cc > 0) {			
                    			/* Read maximum contiguous sectors direc
                    tly */
 11307 00:32BB: A9 00 00     	lda	#$0
 11308 00:32BE: C5 25        	cmp	<L465+cc_1
 11309 00:32C0: 90 03        	bcc	L480
 11310 00:32C2: 82 D9 00     	brl	L10250
 11311                        L480:
 11312                        ;				if (csect + cc > fs->csi
                    ze) {	/* Clip at cluster boundary */
 11313 00:32C5: 18           	clc
 11314 00:32C6: A5 27        	lda	<L465+csect_1
 11315 00:32C8: 65 25        	adc	<L465+cc_1
 11316 00:32CA: 85 01        	sta	<R0
 11317 00:32CC: A0 09 00     	ldy	#$9
 11318 00:32CF: B7 13        	lda	[<L465+fs_1],Y
 11319 00:32D1: C5 01        	cmp	<R0
 11320 00:32D3: 90 03        	bcc	L481
 11321 00:32D5: 82 0A 00     	brl	L10251
 11322                        L481:
 11323                        ;					cc = fs->csize -
                     csect;
 11324 00:32D8: 38           	sec
 11325 00:32D9: A0 09 00     	ldy	#$9
  Thu May 20 2021 21:37                                                Page 230


 11326 00:32DC: B7 13        	lda	[<L465+fs_1],Y
 11327 00:32DE: E5 27        	sbc	<L465+csect_1
 11328 00:32E0: 85 25        	sta	<L465+cc_1
 11329                        ;				}
 11330                        ;				if (disk_read(fs->pdrv, 
                    rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 11331                        L10251:
 11332 00:32E2: D4 25        	pei	<L465+cc_1
 11333 00:32E4: D4 1D        	pei	<L465+sect_1+2
 11334 00:32E6: D4 1B        	pei	<L465+sect_1
 11335 00:32E8: D4 2B        	pei	<L465+rbuff_1+2
 11336 00:32EA: D4 29        	pei	<L465+rbuff_1
 11337 00:32EC: A0 01 00     	ldy	#$1
 11338 00:32EF: B7 13        	lda	[<L465+fs_1],Y
 11339 00:32F1: 48           	pha
 11340 00:32F2: 22 xx xx xx  	jsl	~~disk_read
 11341 00:32F6: AA           	tax
 11342 00:32F7: D0 03        	bne	L482
 11343 00:32F9: 82 11 00     	brl	L10252
 11344                        L482:
 11345 00:32FC: E2 20        	sep	#$20
 11346                        	longa	off
 11347 00:32FE: A9 01        	lda	#$1
 11348 00:3300: A0 11 00     	ldy	#$11
 11349 00:3303: 97 30        	sta	[<L464+fp_0],Y
 11350 00:3305: C2 20        	rep	#$20
 11351                        	longa	on
 11352 00:3307: A9 01 00     	lda	#$1
 11353 00:330A: 82 DC FD     	brl	L469
 11354                        L10252:
 11355                        ;#if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2	
                    	/* Replace one of the read sectors with cached data if i
                    t contains a dirty sector */
 11356                        ;#if FF_FS_TINY
 11357                        ;				if (fs->wflag && fs->win
                    sect - sect < cc) {
 11358                        ;					memcpy(rbuff + (
                    (fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
 11359                        ;				}
 11360                        ;#else
 11361                        ;				if ((fp->flag & FA_DIRTY
                    ) && fp->sect - sect < cc) {
 11362 00:330D: E2 20        	sep	#$20
 11363                        	longa	off
 11364 00:330F: A0 10 00     	ldy	#$10
 11365 00:3312: B7 30        	lda	[<L464+fp_0],Y
 11366 00:3314: 29 80        	and	#<$80
 11367 00:3316: C2 20        	rep	#$20
 11368                        	longa	on
 11369 00:3318: D0 03        	bne	L483
 11370 00:331A: 82 73 00     	brl	L10253
 11371                        L483:
 11372 00:331D: A5 25        	lda	<L465+cc_1
 11373 00:331F: 85 01        	sta	<R0
 11374 00:3321: 64 03        	stz	<R0+2
 11375 00:3323: 38           	sec
 11376 00:3324: A0 1A 00     	ldy	#$1a
 11377 00:3327: B7 30        	lda	[<L464+fp_0],Y
  Thu May 20 2021 21:37                                                Page 231


 11378 00:3329: E5 1B        	sbc	<L465+sect_1
 11379 00:332B: 85 05        	sta	<R1
 11380 00:332D: A0 1C 00     	ldy	#$1c
 11381 00:3330: B7 30        	lda	[<L464+fp_0],Y
 11382 00:3332: E5 1D        	sbc	<L465+sect_1+2
 11383 00:3334: 85 07        	sta	<R1+2
 11384 00:3336: A5 05        	lda	<R1
 11385 00:3338: C5 01        	cmp	<R0
 11386 00:333A: A5 07        	lda	<R1+2
 11387 00:333C: E5 03        	sbc	<R0+2
 11388 00:333E: 90 03        	bcc	L484
 11389 00:3340: 82 4D 00     	brl	L10253
 11390                        L484:
 11391                        ;					memcpy(rbuff + (
                    (fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 11392 00:3343: F4 00 02     	pea	#<$200
 11393 00:3346: 18           	clc
 11394 00:3347: A9 26 00     	lda	#$26
 11395 00:334A: 65 30        	adc	<L464+fp_0
 11396 00:334C: 85 01        	sta	<R0
 11397 00:334E: A9 00 00     	lda	#$0
 11398 00:3351: 65 32        	adc	<L464+fp_0+2
 11399 00:3353: 85 03        	sta	<R0+2
 11400 00:3355: D4 03        	pei	<R0+2
 11401 00:3357: D4 01        	pei	<R0
 11402 00:3359: 38           	sec
 11403 00:335A: A0 1A 00     	ldy	#$1a
 11404 00:335D: B7 30        	lda	[<L464+fp_0],Y
 11405 00:335F: E5 1B        	sbc	<L465+sect_1
 11406 00:3361: 85 09        	sta	<R2
 11407 00:3363: A0 1C 00     	ldy	#$1c
 11408 00:3366: B7 30        	lda	[<L464+fp_0],Y
 11409 00:3368: E5 1D        	sbc	<L465+sect_1+2
 11410 00:336A: 85 0B        	sta	<R2+2
 11411 00:336C: D4 0B        	pei	<R2+2
 11412 00:336E: D4 09        	pei	<R2
 11413 00:3370: A9 09 00     	lda	#$9
 11414                        	xref	~~~lasl
 11415 00:3373: 22 xx xx xx  	jsl	~~~lasl
 11416 00:3377: 85 05        	sta	<R1
 11417 00:3379: 86 07        	stx	<R1+2
 11418 00:337B: 18           	clc
 11419 00:337C: A5 29        	lda	<L465+rbuff_1
 11420 00:337E: 65 05        	adc	<R1
 11421 00:3380: 85 0D        	sta	<R3
 11422 00:3382: A5 2B        	lda	<L465+rbuff_1+2
 11423 00:3384: 65 07        	adc	<R1+2
 11424 00:3386: 85 0F        	sta	<R3+2
 11425 00:3388: D4 0F        	pei	<R3+2
 11426 00:338A: D4 0D        	pei	<R3
 11427 00:338C: 22 xx xx xx  	jsl	~~memcpy
 11428                        ;				}
 11429                        ;#endif
 11430                        ;#endif
 11431                        ;				rcnt = SS(fs) * cc;	
                    			/* Number of bytes transferred */
 11432                        L10253:
 11433 00:3390: A5 25        	lda	<L465+cc_1
  Thu May 20 2021 21:37                                                Page 232


 11434 00:3392: A2 09 00     	ldx	#<$9
 11435                        	xref	~~~asl
 11436 00:3395: 22 xx xx xx  	jsl	~~~asl
 11437 00:3399: 85 23        	sta	<L465+rcnt_1
 11438                        ;				continue;
 11439 00:339B: 82 A6 FD     	brl	L10240
 11440                        ;			}
 11441                        ;#if !FF_FS_TINY
 11442                        ;			if (fp->sect != sect) {		
                    	/* Load data sector if not in cache */
 11443                        L10250:
 11444 00:339E: A0 1A 00     	ldy	#$1a
 11445 00:33A1: B7 30        	lda	[<L464+fp_0],Y
 11446 00:33A3: C5 1B        	cmp	<L465+sect_1
 11447 00:33A5: D0 07        	bne	L485
 11448 00:33A7: A0 1C 00     	ldy	#$1c
 11449 00:33AA: B7 30        	lda	[<L464+fp_0],Y
 11450 00:33AC: C5 1D        	cmp	<L465+sect_1+2
 11451                        L485:
 11452 00:33AE: D0 03        	bne	L486
 11453 00:33B0: 82 A7 00     	brl	L10254
 11454                        L486:
 11455                        ;#if !FF_FS_READONLY
 11456                        ;				if (fp->flag & FA_DIRTY)
                     {		/* Write-back dirty sector cache */
 11457 00:33B3: E2 20        	sep	#$20
 11458                        	longa	off
 11459 00:33B5: A0 10 00     	ldy	#$10
 11460 00:33B8: B7 30        	lda	[<L464+fp_0],Y
 11461 00:33BA: 29 80        	and	#<$80
 11462 00:33BC: C2 20        	rep	#$20
 11463                        	longa	on
 11464 00:33BE: D0 03        	bne	L487
 11465 00:33C0: 82 5C 00     	brl	L10255
 11466                        L487:
 11467                        ;					if (disk_write(f
                    s->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_
                    ERR);
 11468 00:33C3: F4 01 00     	pea	#<$1
 11469 00:33C6: A0 1C 00     	ldy	#$1c
 11470 00:33C9: B7 30        	lda	[<L464+fp_0],Y
 11471 00:33CB: 48           	pha
 11472 00:33CC: A0 1A 00     	ldy	#$1a
 11473 00:33CF: B7 30        	lda	[<L464+fp_0],Y
 11474 00:33D1: 48           	pha
 11475 00:33D2: 18           	clc
 11476 00:33D3: A9 26 00     	lda	#$26
 11477 00:33D6: 65 30        	adc	<L464+fp_0
 11478 00:33D8: 85 01        	sta	<R0
 11479 00:33DA: A9 00 00     	lda	#$0
 11480 00:33DD: 65 32        	adc	<L464+fp_0+2
 11481 00:33DF: 85 03        	sta	<R0+2
 11482 00:33E1: D4 03        	pei	<R0+2
 11483 00:33E3: D4 01        	pei	<R0
 11484 00:33E5: A0 01 00     	ldy	#$1
 11485 00:33E8: B7 13        	lda	[<L465+fs_1],Y
 11486 00:33EA: 48           	pha
 11487 00:33EB: 22 xx xx xx  	jsl	~~disk_write
  Thu May 20 2021 21:37                                                Page 233


 11488 00:33EF: AA           	tax
 11489 00:33F0: D0 03        	bne	L488
 11490 00:33F2: 82 11 00     	brl	L10256
 11491                        L488:
 11492 00:33F5: E2 20        	sep	#$20
 11493                        	longa	off
 11494 00:33F7: A9 01        	lda	#$1
 11495 00:33F9: A0 11 00     	ldy	#$11
 11496 00:33FC: 97 30        	sta	[<L464+fp_0],Y
 11497 00:33FE: C2 20        	rep	#$20
 11498                        	longa	on
 11499 00:3400: A9 01 00     	lda	#$1
 11500 00:3403: 82 E3 FC     	brl	L469
 11501                        L10256:
 11502                        ;					fp->flag &= (BYT
                    E)~FA_DIRTY;
 11503 00:3406: 18           	clc
 11504 00:3407: A9 10 00     	lda	#$10
 11505 00:340A: 65 30        	adc	<L464+fp_0
 11506 00:340C: 85 01        	sta	<R0
 11507 00:340E: A9 00 00     	lda	#$0
 11508 00:3411: 65 32        	adc	<L464+fp_0+2
 11509 00:3413: 85 03        	sta	<R0+2
 11510 00:3415: E2 20        	sep	#$20
 11511                        	longa	off
 11512 00:3417: A7 01        	lda	[<R0]
 11513 00:3419: 29 7F        	and	#<$7f
 11514 00:341B: 87 01        	sta	[<R0]
 11515 00:341D: C2 20        	rep	#$20
 11516                        	longa	on
 11517                        ;				}
 11518                        ;#endif
 11519                        ;				if (disk_read(fs->pdrv, 
                    fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	
                    /* Fill sector cache */
 11520                        L10255:
 11521 00:341F: F4 01 00     	pea	#<$1
 11522 00:3422: D4 1D        	pei	<L465+sect_1+2
 11523 00:3424: D4 1B        	pei	<L465+sect_1
 11524 00:3426: 18           	clc
 11525 00:3427: A9 26 00     	lda	#$26
 11526 00:342A: 65 30        	adc	<L464+fp_0
 11527 00:342C: 85 01        	sta	<R0
 11528 00:342E: A9 00 00     	lda	#$0
 11529 00:3431: 65 32        	adc	<L464+fp_0+2
 11530 00:3433: 85 03        	sta	<R0+2
 11531 00:3435: D4 03        	pei	<R0+2
 11532 00:3437: D4 01        	pei	<R0
 11533 00:3439: A0 01 00     	ldy	#$1
 11534 00:343C: B7 13        	lda	[<L465+fs_1],Y
 11535 00:343E: 48           	pha
 11536 00:343F: 22 xx xx xx  	jsl	~~disk_read
 11537 00:3443: AA           	tax
 11538 00:3444: D0 03        	bne	L489
 11539 00:3446: 82 11 00     	brl	L10257
 11540                        L489:
 11541 00:3449: E2 20        	sep	#$20
 11542                        	longa	off
  Thu May 20 2021 21:37                                                Page 234


 11543 00:344B: A9 01        	lda	#$1
 11544 00:344D: A0 11 00     	ldy	#$11
 11545 00:3450: 97 30        	sta	[<L464+fp_0],Y
 11546 00:3452: C2 20        	rep	#$20
 11547                        	longa	on
 11548 00:3454: A9 01 00     	lda	#$1
 11549 00:3457: 82 8F FC     	brl	L469
 11550                        L10257:
 11551                        ;			}
 11552                        ;#endif
 11553                        ;			fp->sect = sect;
 11554                        L10254:
 11555 00:345A: A5 1B        	lda	<L465+sect_1
 11556 00:345C: A0 1A 00     	ldy	#$1a
 11557 00:345F: 97 30        	sta	[<L464+fp_0],Y
 11558 00:3461: A5 1D        	lda	<L465+sect_1+2
 11559 00:3463: A0 1C 00     	ldy	#$1c
 11560 00:3466: 97 30        	sta	[<L464+fp_0],Y
 11561                        ;		}
 11562                        ;		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);
                    	/* Number of bytes remains in the sector */
 11563                        L10243:
 11564 00:3468: A0 12 00     	ldy	#$12
 11565 00:346B: B7 30        	lda	[<L464+fp_0],Y
 11566 00:346D: 29 FF 01     	and	#<$1ff
 11567 00:3470: 85 01        	sta	<R0
 11568 00:3472: 38           	sec
 11569 00:3473: A9 00 02     	lda	#$200
 11570 00:3476: E5 01        	sbc	<R0
 11571 00:3478: 85 23        	sta	<L465+rcnt_1
 11572                        ;		if (rcnt > btr) rcnt = btr;		
                    			/* Clip it by btr if needed */
 11573 00:347A: A5 38        	lda	<L464+btr_0
 11574 00:347C: C5 23        	cmp	<L465+rcnt_1
 11575 00:347E: 90 03        	bcc	L490
 11576 00:3480: 82 04 00     	brl	L10258
 11577                        L490:
 11578 00:3483: A5 38        	lda	<L464+btr_0
 11579 00:3485: 85 23        	sta	<L465+rcnt_1
 11580                        ;#if FF_FS_TINY
 11581                        ;		if (move_window(fs, fp->sect) != FR_OK) 
                    ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 11582                        ;		memcpy(rbuff, fs->win + fp->fptr % SS(fs
                    ), rcnt);	/* Extract partial sector */
 11583                        ;#else
 11584                        ;		memcpy(rbuff, fp->buf + fp->fptr % SS(fs
                    ), rcnt);	/* Extract partial sector */
 11585                        L10258:
 11586 00:3487: D4 23        	pei	<L465+rcnt_1
 11587 00:3489: A0 12 00     	ldy	#$12
 11588 00:348C: B7 30        	lda	[<L464+fp_0],Y
 11589 00:348E: 29 FF 01     	and	#<$1ff
 11590 00:3491: 85 01        	sta	<R0
 11591 00:3493: 64 03        	stz	<R0+2
 11592 00:3495: 18           	clc
 11593 00:3496: A9 26 00     	lda	#$26
 11594 00:3499: 65 01        	adc	<R0
 11595 00:349B: 85 05        	sta	<R1
  Thu May 20 2021 21:37                                                Page 235


 11596 00:349D: A9 00 00     	lda	#$0
 11597 00:34A0: 65 03        	adc	<R0+2
 11598 00:34A2: 85 07        	sta	<R1+2
 11599 00:34A4: 18           	clc
 11600 00:34A5: A5 30        	lda	<L464+fp_0
 11601 00:34A7: 65 05        	adc	<R1
 11602 00:34A9: 85 01        	sta	<R0
 11603 00:34AB: A5 32        	lda	<L464+fp_0+2
 11604 00:34AD: 65 07        	adc	<R1+2
 11605 00:34AF: 85 03        	sta	<R0+2
 11606 00:34B1: D4 03        	pei	<R0+2
 11607 00:34B3: D4 01        	pei	<R0
 11608 00:34B5: D4 2B        	pei	<L465+rbuff_1+2
 11609 00:34B7: D4 29        	pei	<L465+rbuff_1
 11610 00:34B9: 22 xx xx xx  	jsl	~~memcpy
 11611                        ;#endif
 11612                        ;	}
 11613 00:34BD: 82 84 FC     	brl	L10240
 11614                        L10242:
 11615                        ;
 11616                        ;	LEAVE_FF(fs, FR_OK);
 11617 00:34C0: A9 00 00     	lda	#$0
 11618 00:34C3: 82 23 FC     	brl	L469
 11619                        ;}
 11620             0000002C   L464	equ	44
 11621             00000011   L465	equ	17
 11622                        	ends
 11623                        	efunc
 11624                        ;
 11625                        ;
 11626                        ;
 11627                        ;
 11628                        ;#if !FF_FS_READONLY
 11629                        ;/*-----------------------------------------------
                    ------------------------*/
 11630                        ;/* Write File                                    
                                            */
 11631                        ;/*-----------------------------------------------
                    ------------------------*/
 11632                        ;
 11633                        ;FRESULT f_write (
 11634                        ;	FIL* fp,			/* Open file to 
                    be written */
 11635                        ;	const void* buff,	/* Data to be written */
 11636                        ;	UINT btw,			/* Number of byt
                    es to write */
 11637                        ;	UINT* bw			/* Number of byt
                    es written */
 11638                        ;)
 11639                        ;{
 11640                        	code
 11641                        	xdef	~~f_write
 11642                        	func
 11643                        ~~f_write:
 11644                        	longa	on
 11645                        	longi	on
 11646 00:34C6: 3B           	tsc
 11647 00:34C7: 38           	sec
  Thu May 20 2021 21:37                                                Page 236


 11648 00:34C8: E9 24 00     	sbc	#L491
 11649 00:34CB: 1B           	tcs
 11650 00:34CC: 0B           	phd
 11651 00:34CD: 5B           	tcd
 11652             00000004   fp_0	set	4
 11653             00000008   buff_0	set	8
 11654             0000000C   btw_0	set	12
 11655             0000000E   bw_0	set	14
 11656                        ;	FRESULT res;
 11657                        ;	FATFS *fs;
 11658                        ;	DWORD clst;
 11659                        ;	LBA_t sect;
 11660                        ;	UINT wcnt, cc, csect;
 11661                        ;	const BYTE *wbuff = (const BYTE*)buff;
 11662                        ;
 11663                        ;
 11664                        ;	*bw = 0;	/* Clear write byte counter */
 11665             00000000   res_1	set	0
 11666             00000002   fs_1	set	2
 11667             00000006   clst_1	set	6
 11668             0000000A   sect_1	set	10
 11669             0000000E   wcnt_1	set	14
 11670             00000010   cc_1	set	16
 11671             00000012   csect_1	set	18
 11672             00000014   wbuff_1	set	20
 11673 00:34CE: A5 2C        	lda	<L491+buff_0
 11674 00:34D0: 85 21        	sta	<L492+wbuff_1
 11675 00:34D2: A5 2E        	lda	<L491+buff_0+2
 11676 00:34D4: 85 23        	sta	<L492+wbuff_1+2
 11677 00:34D6: A9 00 00     	lda	#$0
 11678 00:34D9: 87 32        	sta	[<L491+bw_0]
 11679                        ;	res = validate(&fp->obj, &fs);			
                    /* Check validity of the file object */
 11680 00:34DB: F4 00 00     	pea	#0
 11681 00:34DE: 18           	clc
 11682 00:34DF: 7B           	tdc
 11683 00:34E0: 69 0F 00     	adc	#<L492+fs_1
 11684 00:34E3: 48           	pha
 11685 00:34E4: D4 2A        	pei	<L491+fp_0+2
 11686 00:34E6: D4 28        	pei	<L491+fp_0
 11687 00:34E8: 22 xx xx xx  	jsl	~~validate
 11688 00:34EC: 85 0D        	sta	<L492+res_1
 11689                        ;	if (res != FR_OK || (res = (FRESULT)fp->err) != 
                    FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 11690 00:34EE: A5 0D        	lda	<L492+res_1
 11691 00:34F0: F0 03        	beq	L494
 11692 00:34F2: 82 11 00     	brl	L493
 11693                        L494:
 11694 00:34F5: A0 11 00     	ldy	#$11
 11695 00:34F8: B7 28        	lda	[<L491+fp_0],Y
 11696 00:34FA: 29 FF 00     	and	#$ff
 11697 00:34FD: 85 0D        	sta	<L492+res_1
 11698 00:34FF: A5 0D        	lda	<L492+res_1
 11699 00:3501: D0 03        	bne	L495
 11700 00:3503: 82 14 00     	brl	L10259
 11701                        L495:
 11702                        L493:
 11703 00:3506: A5 0D        	lda	<L492+res_1
  Thu May 20 2021 21:37                                                Page 237


 11704                        L496:
 11705 00:3508: A8           	tay
 11706 00:3509: A5 26        	lda	<L491+2
 11707 00:350B: 85 34        	sta	<L491+2+14
 11708 00:350D: A5 25        	lda	<L491+1
 11709 00:350F: 85 33        	sta	<L491+1+14
 11710 00:3511: 2B           	pld
 11711 00:3512: 3B           	tsc
 11712 00:3513: 18           	clc
 11713 00:3514: 69 32 00     	adc	#L491+14
 11714 00:3517: 1B           	tcs
 11715 00:3518: 98           	tya
 11716 00:3519: 6B           	rtl
 11717                        ;	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENI
                    ED);	/* Check access mode */
 11718                        L10259:
 11719 00:351A: E2 20        	sep	#$20
 11720                        	longa	off
 11721 00:351C: A0 10 00     	ldy	#$10
 11722 00:351F: B7 28        	lda	[<L491+fp_0],Y
 11723 00:3521: 29 02        	and	#<$2
 11724 00:3523: C2 20        	rep	#$20
 11725                        	longa	on
 11726 00:3525: F0 03        	beq	L497
 11727 00:3527: 82 06 00     	brl	L10260
 11728                        L497:
 11729 00:352A: A9 07 00     	lda	#$7
 11730 00:352D: 82 D8 FF     	brl	L496
 11731                        ;
 11732                        ;	/* Check fptr wrap-around (file size cannot reac
                    h 4 GiB at FAT volume) */
 11733                        ;	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) &&
                     (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 11734                        L10260:
 11735 00:3530: 82 0D 00     	brl	L498
 11736 00:3533: E2 20        	sep	#$20
 11737                        	longa	off
 11738 00:3535: A7 0F        	lda	[<L492+fs_1]
 11739 00:3537: C9 04        	cmp	#<$4
 11740 00:3539: C2 20        	rep	#$20
 11741                        	longa	on
 11742 00:353B: D0 03        	bne	L499
 11743 00:353D: 82 45 00     	brl	L10261
 11744                        L499:
 11745                        L498:
 11746 00:3540: A5 30        	lda	<L491+btw_0
 11747 00:3542: 85 01        	sta	<R0
 11748 00:3544: 64 03        	stz	<R0+2
 11749 00:3546: 18           	clc
 11750 00:3547: A5 01        	lda	<R0
 11751 00:3549: A0 12 00     	ldy	#$12
 11752 00:354C: 77 28        	adc	[<L491+fp_0],Y
 11753 00:354E: 85 05        	sta	<R1
 11754 00:3550: A5 03        	lda	<R0+2
 11755 00:3552: A0 14 00     	ldy	#$14
 11756 00:3555: 77 28        	adc	[<L491+fp_0],Y
 11757 00:3557: 85 07        	sta	<R1+2
 11758 00:3559: A5 05        	lda	<R1
  Thu May 20 2021 21:37                                                Page 238


 11759 00:355B: A0 12 00     	ldy	#$12
 11760 00:355E: D7 28        	cmp	[<L491+fp_0],Y
 11761 00:3560: A5 07        	lda	<R1+2
 11762 00:3562: A0 14 00     	ldy	#$14
 11763 00:3565: F7 28        	sbc	[<L491+fp_0],Y
 11764 00:3567: 90 03        	bcc	L500
 11765 00:3569: 82 19 00     	brl	L10261
 11766                        L500:
 11767                        ;		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fpt
                    r);
 11768 00:356C: 38           	sec
 11769 00:356D: A9 FF FF     	lda	#$ffff
 11770 00:3570: A0 12 00     	ldy	#$12
 11771 00:3573: F7 28        	sbc	[<L491+fp_0],Y
 11772 00:3575: 85 01        	sta	<R0
 11773 00:3577: A9 FF FF     	lda	#$ffff
 11774 00:357A: A0 14 00     	ldy	#$14
 11775 00:357D: F7 28        	sbc	[<L491+fp_0],Y
 11776 00:357F: 85 03        	sta	<R0+2
 11777 00:3581: A5 01        	lda	<R0
 11778 00:3583: 85 30        	sta	<L491+btw_0
 11779                        ;	}
 11780                        ;
 11781                        ;	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff
                     += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp
                    ->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repea
                    t until all data written */
 11782                        L10261:
 11783 00:3585: 82 8C 00     	brl	L10263
 11784                        L10262:
 11785 00:3588: 38           	sec
 11786 00:3589: A5 30        	lda	<L491+btw_0
 11787 00:358B: E5 1B        	sbc	<L492+wcnt_1
 11788 00:358D: 85 30        	sta	<L491+btw_0
 11789 00:358F: 18           	clc
 11790 00:3590: A7 32        	lda	[<L491+bw_0]
 11791 00:3592: 65 1B        	adc	<L492+wcnt_1
 11792 00:3594: 87 32        	sta	[<L491+bw_0]
 11793 00:3596: A5 1B        	lda	<L492+wcnt_1
 11794 00:3598: 85 01        	sta	<R0
 11795 00:359A: 64 03        	stz	<R0+2
 11796 00:359C: 18           	clc
 11797 00:359D: A5 21        	lda	<L492+wbuff_1
 11798 00:359F: 65 01        	adc	<R0
 11799 00:35A1: 85 21        	sta	<L492+wbuff_1
 11800 00:35A3: A5 23        	lda	<L492+wbuff_1+2
 11801 00:35A5: 65 03        	adc	<R0+2
 11802 00:35A7: 85 23        	sta	<L492+wbuff_1+2
 11803 00:35A9: 18           	clc
 11804 00:35AA: A9 12 00     	lda	#$12
 11805 00:35AD: 65 28        	adc	<L491+fp_0
 11806 00:35AF: 85 01        	sta	<R0
 11807 00:35B1: A9 00 00     	lda	#$0
 11808 00:35B4: 65 2A        	adc	<L491+fp_0+2
 11809 00:35B6: 85 03        	sta	<R0+2
 11810 00:35B8: A5 1B        	lda	<L492+wcnt_1
 11811 00:35BA: 85 05        	sta	<R1
 11812 00:35BC: 64 07        	stz	<R1+2
  Thu May 20 2021 21:37                                                Page 239


 11813 00:35BE: 18           	clc
 11814 00:35BF: A5 05        	lda	<R1
 11815 00:35C1: 67 01        	adc	[<R0]
 11816 00:35C3: 87 01        	sta	[<R0]
 11817 00:35C5: A5 07        	lda	<R1+2
 11818 00:35C7: A0 02 00     	ldy	#$2
 11819 00:35CA: 77 01        	adc	[<R0],Y
 11820 00:35CC: A0 02 00     	ldy	#$2
 11821 00:35CF: 97 01        	sta	[<R0],Y
 11822 00:35D1: A0 0C 00     	ldy	#$c
 11823 00:35D4: B7 28        	lda	[<L491+fp_0],Y
 11824 00:35D6: A0 12 00     	ldy	#$12
 11825 00:35D9: D7 28        	cmp	[<L491+fp_0],Y
 11826 00:35DB: A0 0E 00     	ldy	#$e
 11827 00:35DE: B7 28        	lda	[<L491+fp_0],Y
 11828 00:35E0: A0 14 00     	ldy	#$14
 11829 00:35E3: F7 28        	sbc	[<L491+fp_0],Y
 11830 00:35E5: 90 03        	bcc	L502
 11831 00:35E7: 82 0D 00     	brl	L501
 11832                        L502:
 11833 00:35EA: A0 14 00     	ldy	#$14
 11834 00:35ED: B7 28        	lda	[<L491+fp_0],Y
 11835 00:35EF: AA           	tax
 11836 00:35F0: A0 12 00     	ldy	#$12
 11837 00:35F3: B7 28        	lda	[<L491+fp_0],Y
 11838 00:35F5: 80 0B        	bra	L503
 11839                        L501:
 11840 00:35F7: A0 0E 00     	ldy	#$e
 11841 00:35FA: B7 28        	lda	[<L491+fp_0],Y
 11842 00:35FC: AA           	tax
 11843 00:35FD: A0 0C 00     	ldy	#$c
 11844 00:3600: B7 28        	lda	[<L491+fp_0],Y
 11845                        L503:
 11846 00:3602: 85 01        	sta	<R0
 11847 00:3604: 86 03        	stx	<R0+2
 11848 00:3606: A5 01        	lda	<R0
 11849 00:3608: A0 0C 00     	ldy	#$c
 11850 00:360B: 97 28        	sta	[<L491+fp_0],Y
 11851 00:360D: A5 03        	lda	<R0+2
 11852 00:360F: A0 0E 00     	ldy	#$e
 11853 00:3612: 97 28        	sta	[<L491+fp_0],Y
 11854                        L10263:
 11855 00:3614: A9 00 00     	lda	#$0
 11856 00:3617: C5 30        	cmp	<L491+btw_0
 11857 00:3619: 90 03        	bcc	L504
 11858 00:361B: 82 97 03     	brl	L10264
 11859                        L504:
 11860                        ;		if (fp->fptr % SS(fs) == 0) {		
                    /* On the sector boundary? */
 11861 00:361E: A0 12 00     	ldy	#$12
 11862 00:3621: B7 28        	lda	[<L491+fp_0],Y
 11863 00:3623: 29 FF 01     	and	#<$1ff
 11864 00:3626: F0 03        	beq	L505
 11865 00:3628: 82 19 03     	brl	L10265
 11866                        L505:
 11867                        ;			csect = (UINT)(fp->fptr / SS(fs)
                    ) & (fs->csize - 1);	/* Sector offset in the cluster 
                    */
  Thu May 20 2021 21:37                                                Page 240


 11868 00:362B: A0 14 00     	ldy	#$14
 11869 00:362E: B7 28        	lda	[<L491+fp_0],Y
 11870 00:3630: 48           	pha
 11871 00:3631: A0 12 00     	ldy	#$12
 11872 00:3634: B7 28        	lda	[<L491+fp_0],Y
 11873 00:3636: 48           	pha
 11874 00:3637: A9 09 00     	lda	#$9
 11875                        	xref	~~~llsr
 11876 00:363A: 22 xx xx xx  	jsl	~~~llsr
 11877 00:363E: 85 01        	sta	<R0
 11878 00:3640: 86 03        	stx	<R0+2
 11879 00:3642: 18           	clc
 11880 00:3643: A9 FF FF     	lda	#$ffff
 11881 00:3646: A0 09 00     	ldy	#$9
 11882 00:3649: 77 0F        	adc	[<L492+fs_1],Y
 11883 00:364B: 85 05        	sta	<R1
 11884 00:364D: A5 05        	lda	<R1
 11885 00:364F: 25 01        	and	<R0
 11886 00:3651: 85 1F        	sta	<L492+csect_1
 11887                        ;			if (csect == 0) {		
                    		/* On the cluster boundary? */
 11888 00:3653: A5 1F        	lda	<L492+csect_1
 11889 00:3655: F0 03        	beq	L506
 11890 00:3657: 82 CB 00     	brl	L10266
 11891                        L506:
 11892                        ;				if (fp->fptr == 0) {	
                    	/* On the top of the file? */
 11893 00:365A: A0 12 00     	ldy	#$12
 11894 00:365D: B7 28        	lda	[<L491+fp_0],Y
 11895 00:365F: A0 14 00     	ldy	#$14
 11896 00:3662: 17 28        	ora	[<L491+fp_0],Y
 11897 00:3664: F0 03        	beq	L507
 11898 00:3666: 82 2C 00     	brl	L10267
 11899                        L507:
 11900                        ;					clst = fp->obj.s
                    clust;	/* Follow from the origin */
 11901 00:3669: A0 08 00     	ldy	#$8
 11902 00:366C: B7 28        	lda	[<L491+fp_0],Y
 11903 00:366E: 85 13        	sta	<L492+clst_1
 11904 00:3670: A0 0A 00     	ldy	#$a
 11905 00:3673: B7 28        	lda	[<L491+fp_0],Y
 11906 00:3675: 85 15        	sta	<L492+clst_1+2
 11907                        ;					if (clst == 0) {
                    		/* If no cluster is allocated, */
 11908 00:3677: A5 13        	lda	<L492+clst_1
 11909 00:3679: 05 15        	ora	<L492+clst_1+2
 11910 00:367B: F0 03        	beq	L508
 11911 00:367D: 82 12 00     	brl	L10268
 11912                        L508:
 11913                        ;						clst = c
                    reate_chain(&fp->obj, 0);	/* create a new cluster chain */
 11914 00:3680: F4 00 00     	pea	#^$0
 11915 00:3683: F4 00 00     	pea	#<$0
 11916 00:3686: D4 2A        	pei	<L491+fp_0+2
 11917 00:3688: D4 28        	pei	<L491+fp_0
 11918 00:368A: 22 xx xx xx  	jsl	~~create_chain
 11919 00:368E: 85 13        	sta	<L492+clst_1
 11920 00:3690: 86 15        	stx	<L492+clst_1+2
  Thu May 20 2021 21:37                                                Page 241


 11921                        ;					}
 11922                        ;				} else {		
                    			/* On the middle or end of the file */
 11923                        L10268:
 11924 00:3692: 82 18 00     	brl	L10269
 11925                        L10267:
 11926                        ;#if FF_USE_FASTSEEK
 11927                        ;					if (fp->cltbl) {
 11928                        ;						clst = c
                    lmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 11929                        ;					} else
 11930                        ;#endif
 11931                        ;					{
 11932                        ;						clst = c
                    reate_chain(&fp->obj, fp->clust);	/* Follow or stretch clu
                    ster chain on the FAT */
 11933 00:3695: A0 18 00     	ldy	#$18
 11934 00:3698: B7 28        	lda	[<L491+fp_0],Y
 11935 00:369A: 48           	pha
 11936 00:369B: A0 16 00     	ldy	#$16
 11937 00:369E: B7 28        	lda	[<L491+fp_0],Y
 11938 00:36A0: 48           	pha
 11939 00:36A1: D4 2A        	pei	<L491+fp_0+2
 11940 00:36A3: D4 28        	pei	<L491+fp_0
 11941 00:36A5: 22 xx xx xx  	jsl	~~create_chain
 11942 00:36A9: 85 13        	sta	<L492+clst_1
 11943 00:36AB: 86 15        	stx	<L492+clst_1+2
 11944                        ;					}
 11945                        ;				}
 11946                        L10269:
 11947                        ;				if (clst == 0) break;	
                    	/* Could not allocate a new cluster (disk full) */
 11948 00:36AD: A5 13        	lda	<L492+clst_1
 11949 00:36AF: 05 15        	ora	<L492+clst_1+2
 11950 00:36B1: D0 03        	bne	L509
 11951 00:36B3: 82 FF 02     	brl	L10264
 11952                        L509:
 11953                        ;				if (clst == 1) ABORT(fs,
                     FR_INT_ERR);
 11954 00:36B6: A5 13        	lda	<L492+clst_1
 11955 00:36B8: C9 01 00     	cmp	#<$1
 11956 00:36BB: D0 05        	bne	L510
 11957 00:36BD: A5 15        	lda	<L492+clst_1+2
 11958 00:36BF: C9 00 00     	cmp	#^$1
 11959                        L510:
 11960 00:36C2: F0 03        	beq	L511
 11961 00:36C4: 82 11 00     	brl	L10270
 11962                        L511:
 11963 00:36C7: E2 20        	sep	#$20
 11964                        	longa	off
 11965 00:36C9: A9 02        	lda	#$2
 11966 00:36CB: A0 11 00     	ldy	#$11
 11967 00:36CE: 97 28        	sta	[<L491+fp_0],Y
 11968 00:36D0: C2 20        	rep	#$20
 11969                        	longa	on
 11970 00:36D2: A9 02 00     	lda	#$2
 11971 00:36D5: 82 30 FE     	brl	L496
 11972                        L10270:
  Thu May 20 2021 21:37                                                Page 242


 11973                        ;				if (clst == 0xFFFFFFFF) 
                    ABORT(fs, FR_DISK_ERR);
 11974 00:36D8: A5 13        	lda	<L492+clst_1
 11975 00:36DA: C9 FF FF     	cmp	#<$ffffffff
 11976 00:36DD: D0 05        	bne	L512
 11977 00:36DF: A5 15        	lda	<L492+clst_1+2
 11978 00:36E1: C9 FF FF     	cmp	#^$ffffffff
 11979                        L512:
 11980 00:36E4: F0 03        	beq	L513
 11981 00:36E6: 82 11 00     	brl	L10271
 11982                        L513:
 11983 00:36E9: E2 20        	sep	#$20
 11984                        	longa	off
 11985 00:36EB: A9 01        	lda	#$1
 11986 00:36ED: A0 11 00     	ldy	#$11
 11987 00:36F0: 97 28        	sta	[<L491+fp_0],Y
 11988 00:36F2: C2 20        	rep	#$20
 11989                        	longa	on
 11990 00:36F4: A9 01 00     	lda	#$1
 11991 00:36F7: 82 0E FE     	brl	L496
 11992                        L10271:
 11993                        ;				fp->clust = clst;	
                    		/* Update current cluster */
 11994 00:36FA: A5 13        	lda	<L492+clst_1
 11995 00:36FC: A0 16 00     	ldy	#$16
 11996 00:36FF: 97 28        	sta	[<L491+fp_0],Y
 11997 00:3701: A5 15        	lda	<L492+clst_1+2
 11998 00:3703: A0 18 00     	ldy	#$18
 11999 00:3706: 97 28        	sta	[<L491+fp_0],Y
 12000                        ;				if (fp->obj.sclust == 0)
                     fp->obj.sclust = clst;	/* Set start cluster if the firs
                    t write */
 12001 00:3708: A0 08 00     	ldy	#$8
 12002 00:370B: B7 28        	lda	[<L491+fp_0],Y
 12003 00:370D: A0 0A 00     	ldy	#$a
 12004 00:3710: 17 28        	ora	[<L491+fp_0],Y
 12005 00:3712: F0 03        	beq	L514
 12006 00:3714: 82 0E 00     	brl	L10272
 12007                        L514:
 12008 00:3717: A5 13        	lda	<L492+clst_1
 12009 00:3719: A0 08 00     	ldy	#$8
 12010 00:371C: 97 28        	sta	[<L491+fp_0],Y
 12011 00:371E: A5 15        	lda	<L492+clst_1+2
 12012 00:3720: A0 0A 00     	ldy	#$a
 12013 00:3723: 97 28        	sta	[<L491+fp_0],Y
 12014                        ;			}
 12015                        L10272:
 12016                        ;#if FF_FS_TINY
 12017                        ;			if (fs->winsect == fp->sect && s
                    ync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write
                    -back sector cache */
 12018                        ;#else
 12019                        ;			if (fp->flag & FA_DIRTY) {	
                    	/* Write-back sector cache */
 12020                        L10266:
 12021 00:3725: E2 20        	sep	#$20
 12022                        	longa	off
 12023 00:3727: A0 10 00     	ldy	#$10
  Thu May 20 2021 21:37                                                Page 243


 12024 00:372A: B7 28        	lda	[<L491+fp_0],Y
 12025 00:372C: 29 80        	and	#<$80
 12026 00:372E: C2 20        	rep	#$20
 12027                        	longa	on
 12028 00:3730: D0 03        	bne	L515
 12029 00:3732: 82 5C 00     	brl	L10273
 12030                        L515:
 12031                        ;				if (disk_write(fs->pdrv,
                     fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 12032 00:3735: F4 01 00     	pea	#<$1
 12033 00:3738: A0 1C 00     	ldy	#$1c
 12034 00:373B: B7 28        	lda	[<L491+fp_0],Y
 12035 00:373D: 48           	pha
 12036 00:373E: A0 1A 00     	ldy	#$1a
 12037 00:3741: B7 28        	lda	[<L491+fp_0],Y
 12038 00:3743: 48           	pha
 12039 00:3744: 18           	clc
 12040 00:3745: A9 26 00     	lda	#$26
 12041 00:3748: 65 28        	adc	<L491+fp_0
 12042 00:374A: 85 01        	sta	<R0
 12043 00:374C: A9 00 00     	lda	#$0
 12044 00:374F: 65 2A        	adc	<L491+fp_0+2
 12045 00:3751: 85 03        	sta	<R0+2
 12046 00:3753: D4 03        	pei	<R0+2
 12047 00:3755: D4 01        	pei	<R0
 12048 00:3757: A0 01 00     	ldy	#$1
 12049 00:375A: B7 0F        	lda	[<L492+fs_1],Y
 12050 00:375C: 48           	pha
 12051 00:375D: 22 xx xx xx  	jsl	~~disk_write
 12052 00:3761: AA           	tax
 12053 00:3762: D0 03        	bne	L516
 12054 00:3764: 82 11 00     	brl	L10274
 12055                        L516:
 12056 00:3767: E2 20        	sep	#$20
 12057                        	longa	off
 12058 00:3769: A9 01        	lda	#$1
 12059 00:376B: A0 11 00     	ldy	#$11
 12060 00:376E: 97 28        	sta	[<L491+fp_0],Y
 12061 00:3770: C2 20        	rep	#$20
 12062                        	longa	on
 12063 00:3772: A9 01 00     	lda	#$1
 12064 00:3775: 82 90 FD     	brl	L496
 12065                        L10274:
 12066                        ;				fp->flag &= (BYTE)~FA_DI
                    RTY;
 12067 00:3778: 18           	clc
 12068 00:3779: A9 10 00     	lda	#$10
 12069 00:377C: 65 28        	adc	<L491+fp_0
 12070 00:377E: 85 01        	sta	<R0
 12071 00:3780: A9 00 00     	lda	#$0
 12072 00:3783: 65 2A        	adc	<L491+fp_0+2
 12073 00:3785: 85 03        	sta	<R0+2
 12074 00:3787: E2 20        	sep	#$20
 12075                        	longa	off
 12076 00:3789: A7 01        	lda	[<R0]
 12077 00:378B: 29 7F        	and	#<$7f
 12078 00:378D: 87 01        	sta	[<R0]
 12079 00:378F: C2 20        	rep	#$20
  Thu May 20 2021 21:37                                                Page 244


 12080                        	longa	on
 12081                        ;			}
 12082                        ;#endif
 12083                        ;			sect = clst2sect(fs, fp->clust);
                    	/* Get current sector */
 12084                        L10273:
 12085 00:3791: A0 18 00     	ldy	#$18
 12086 00:3794: B7 28        	lda	[<L491+fp_0],Y
 12087 00:3796: 48           	pha
 12088 00:3797: A0 16 00     	ldy	#$16
 12089 00:379A: B7 28        	lda	[<L491+fp_0],Y
 12090 00:379C: 48           	pha
 12091 00:379D: D4 11        	pei	<L492+fs_1+2
 12092 00:379F: D4 0F        	pei	<L492+fs_1
 12093 00:37A1: 22 xx xx xx  	jsl	~~clst2sect
 12094 00:37A5: 85 17        	sta	<L492+sect_1
 12095 00:37A7: 86 19        	stx	<L492+sect_1+2
 12096                        ;			if (sect == 0) ABORT(fs, FR_INT_
                    ERR);
 12097 00:37A9: A5 17        	lda	<L492+sect_1
 12098 00:37AB: 05 19        	ora	<L492+sect_1+2
 12099 00:37AD: F0 03        	beq	L517
 12100 00:37AF: 82 11 00     	brl	L10275
 12101                        L517:
 12102 00:37B2: E2 20        	sep	#$20
 12103                        	longa	off
 12104 00:37B4: A9 02        	lda	#$2
 12105 00:37B6: A0 11 00     	ldy	#$11
 12106 00:37B9: 97 28        	sta	[<L491+fp_0],Y
 12107 00:37BB: C2 20        	rep	#$20
 12108                        	longa	on
 12109 00:37BD: A9 02 00     	lda	#$2
 12110 00:37C0: 82 45 FD     	brl	L496
 12111                        L10275:
 12112                        ;			sect += csect;
 12113 00:37C3: A5 1F        	lda	<L492+csect_1
 12114 00:37C5: 85 01        	sta	<R0
 12115 00:37C7: 64 03        	stz	<R0+2
 12116 00:37C9: 18           	clc
 12117 00:37CA: A5 01        	lda	<R0
 12118 00:37CC: 65 17        	adc	<L492+sect_1
 12119 00:37CE: 85 17        	sta	<L492+sect_1
 12120 00:37D0: A5 03        	lda	<R0+2
 12121 00:37D2: 65 19        	adc	<L492+sect_1+2
 12122 00:37D4: 85 19        	sta	<L492+sect_1+2
 12123                        ;			cc = btw / SS(fs);		
                    		/* When remaining bytes >= sector size, */
 12124 00:37D6: A5 30        	lda	<L491+btw_0
 12125 00:37D8: A2 09 00     	ldx	#<$9
 12126                        	xref	~~~lsr
 12127 00:37DB: 22 xx xx xx  	jsl	~~~lsr
 12128 00:37DF: 85 1D        	sta	<L492+cc_1
 12129                        ;			if (cc > 0) {			
                    		/* Write maximum contiguous sectors directly */
 12130 00:37E1: A9 00 00     	lda	#$0
 12131 00:37E4: C5 1D        	cmp	<L492+cc_1
 12132 00:37E6: 90 03        	bcc	L518
 12133 00:37E8: 82 E2 00     	brl	L10276
  Thu May 20 2021 21:37                                                Page 245


 12134                        L518:
 12135                        ;				if (csect + cc > fs->csi
                    ze) {	/* Clip at cluster boundary */
 12136 00:37EB: 18           	clc
 12137 00:37EC: A5 1F        	lda	<L492+csect_1
 12138 00:37EE: 65 1D        	adc	<L492+cc_1
 12139 00:37F0: 85 01        	sta	<R0
 12140 00:37F2: A0 09 00     	ldy	#$9
 12141 00:37F5: B7 0F        	lda	[<L492+fs_1],Y
 12142 00:37F7: C5 01        	cmp	<R0
 12143 00:37F9: 90 03        	bcc	L519
 12144 00:37FB: 82 0A 00     	brl	L10277
 12145                        L519:
 12146                        ;					cc = fs->csize -
                     csect;
 12147 00:37FE: 38           	sec
 12148 00:37FF: A0 09 00     	ldy	#$9
 12149 00:3802: B7 0F        	lda	[<L492+fs_1],Y
 12150 00:3804: E5 1F        	sbc	<L492+csect_1
 12151 00:3806: 85 1D        	sta	<L492+cc_1
 12152                        ;				}
 12153                        ;				if (disk_write(fs->pdrv,
                     wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 12154                        L10277:
 12155 00:3808: D4 1D        	pei	<L492+cc_1
 12156 00:380A: D4 19        	pei	<L492+sect_1+2
 12157 00:380C: D4 17        	pei	<L492+sect_1
 12158 00:380E: D4 23        	pei	<L492+wbuff_1+2
 12159 00:3810: D4 21        	pei	<L492+wbuff_1
 12160 00:3812: A0 01 00     	ldy	#$1
 12161 00:3815: B7 0F        	lda	[<L492+fs_1],Y
 12162 00:3817: 48           	pha
 12163 00:3818: 22 xx xx xx  	jsl	~~disk_write
 12164 00:381C: AA           	tax
 12165 00:381D: D0 03        	bne	L520
 12166 00:381F: 82 11 00     	brl	L10278
 12167                        L520:
 12168 00:3822: E2 20        	sep	#$20
 12169                        	longa	off
 12170 00:3824: A9 01        	lda	#$1
 12171 00:3826: A0 11 00     	ldy	#$11
 12172 00:3829: 97 28        	sta	[<L491+fp_0],Y
 12173 00:382B: C2 20        	rep	#$20
 12174                        	longa	on
 12175 00:382D: A9 01 00     	lda	#$1
 12176 00:3830: 82 D5 FC     	brl	L496
 12177                        L10278:
 12178                        ;#if FF_FS_MINIMIZE <= 2
 12179                        ;#if FF_FS_TINY
 12180                        ;				if (fs->winsect - sect <
                     cc) {	/* Refill sector cache if it gets invalidated by
                     the direct write */
 12181                        ;					memcpy(fs->win, 
                    wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
 12182                        ;					fs->wflag = 0;
 12183                        ;				}
 12184                        ;#else
 12185                        ;				if (fp->sect - sect < cc
  Thu May 20 2021 21:37                                                Page 246


                    ) { /* Refill sector cache if it gets invalidated by the dir
                    ect write */
 12186 00:3833: A5 1D        	lda	<L492+cc_1
 12187 00:3835: 85 01        	sta	<R0
 12188 00:3837: 64 03        	stz	<R0+2
 12189 00:3839: 38           	sec
 12190 00:383A: A0 1A 00     	ldy	#$1a
 12191 00:383D: B7 28        	lda	[<L491+fp_0],Y
 12192 00:383F: E5 17        	sbc	<L492+sect_1
 12193 00:3841: 85 05        	sta	<R1
 12194 00:3843: A0 1C 00     	ldy	#$1c
 12195 00:3846: B7 28        	lda	[<L491+fp_0],Y
 12196 00:3848: E5 19        	sbc	<L492+sect_1+2
 12197 00:384A: 85 07        	sta	<R1+2
 12198 00:384C: A5 05        	lda	<R1
 12199 00:384E: C5 01        	cmp	<R0
 12200 00:3850: A5 07        	lda	<R1+2
 12201 00:3852: E5 03        	sbc	<R0+2
 12202 00:3854: 90 03        	bcc	L521
 12203 00:3856: 82 66 00     	brl	L10279
 12204                        L521:
 12205                        ;					memcpy(fp->buf, 
                    wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 12206 00:3859: F4 00 02     	pea	#<$200
 12207 00:385C: 38           	sec
 12208 00:385D: A0 1A 00     	ldy	#$1a
 12209 00:3860: B7 28        	lda	[<L491+fp_0],Y
 12210 00:3862: E5 17        	sbc	<L492+sect_1
 12211 00:3864: 85 05        	sta	<R1
 12212 00:3866: A0 1C 00     	ldy	#$1c
 12213 00:3869: B7 28        	lda	[<L491+fp_0],Y
 12214 00:386B: E5 19        	sbc	<L492+sect_1+2
 12215 00:386D: 85 07        	sta	<R1+2
 12216 00:386F: D4 07        	pei	<R1+2
 12217 00:3871: D4 05        	pei	<R1
 12218 00:3873: A9 09 00     	lda	#$9
 12219                        	xref	~~~lasl
 12220 00:3876: 22 xx xx xx  	jsl	~~~lasl
 12221 00:387A: 85 01        	sta	<R0
 12222 00:387C: 86 03        	stx	<R0+2
 12223 00:387E: 18           	clc
 12224 00:387F: A5 21        	lda	<L492+wbuff_1
 12225 00:3881: 65 01        	adc	<R0
 12226 00:3883: 85 09        	sta	<R2
 12227 00:3885: A5 23        	lda	<L492+wbuff_1+2
 12228 00:3887: 65 03        	adc	<R0+2
 12229 00:3889: 85 0B        	sta	<R2+2
 12230 00:388B: D4 0B        	pei	<R2+2
 12231 00:388D: D4 09        	pei	<R2
 12232 00:388F: 18           	clc
 12233 00:3890: A9 26 00     	lda	#$26
 12234 00:3893: 65 28        	adc	<L491+fp_0
 12235 00:3895: 85 01        	sta	<R0
 12236 00:3897: A9 00 00     	lda	#$0
 12237 00:389A: 65 2A        	adc	<L491+fp_0+2
 12238 00:389C: 85 03        	sta	<R0+2
 12239 00:389E: D4 03        	pei	<R0+2
 12240 00:38A0: D4 01        	pei	<R0
  Thu May 20 2021 21:37                                                Page 247


 12241 00:38A2: 22 xx xx xx  	jsl	~~memcpy
 12242                        ;					fp->flag &= (BYT
                    E)~FA_DIRTY;
 12243 00:38A6: 18           	clc
 12244 00:38A7: A9 10 00     	lda	#$10
 12245 00:38AA: 65 28        	adc	<L491+fp_0
 12246 00:38AC: 85 01        	sta	<R0
 12247 00:38AE: A9 00 00     	lda	#$0
 12248 00:38B1: 65 2A        	adc	<L491+fp_0+2
 12249 00:38B3: 85 03        	sta	<R0+2
 12250 00:38B5: E2 20        	sep	#$20
 12251                        	longa	off
 12252 00:38B7: A7 01        	lda	[<R0]
 12253 00:38B9: 29 7F        	and	#<$7f
 12254 00:38BB: 87 01        	sta	[<R0]
 12255 00:38BD: C2 20        	rep	#$20
 12256                        	longa	on
 12257                        ;				}
 12258                        ;#endif
 12259                        ;#endif
 12260                        ;				wcnt = SS(fs) * cc;	
                    	/* Number of bytes transferred */
 12261                        L10279:
 12262 00:38BF: A5 1D        	lda	<L492+cc_1
 12263 00:38C1: A2 09 00     	ldx	#<$9
 12264                        	xref	~~~asl
 12265 00:38C4: 22 xx xx xx  	jsl	~~~asl
 12266 00:38C8: 85 1B        	sta	<L492+wcnt_1
 12267                        ;				continue;
 12268 00:38CA: 82 BB FC     	brl	L10262
 12269                        ;			}
 12270                        ;#if FF_FS_TINY
 12271                        ;			if (fp->fptr >= fp->obj.objsize)
                     {	/* Avoid silly cache filling on the growing edge */
 12272                        ;				if (sync_window(fs) != F
                    R_OK) ABORT(fs, FR_DISK_ERR);
 12273                        ;				fs->winsect = sect;
 12274                        ;			}
 12275                        ;#else
 12276                        ;			if (fp->sect != sect && 	
                    	/* Fill sector cache with file data */
 12277                        L10276:
 12278                        ;				fp->fptr < fp->obj.objsi
                    ze &&
 12279                        ;				disk_read(fs->pdrv, fp->
                    buf, sect, 1) != RES_OK) {
 12280 00:38CD: A0 1A 00     	ldy	#$1a
 12281 00:38D0: B7 28        	lda	[<L491+fp_0],Y
 12282 00:38D2: C5 17        	cmp	<L492+sect_1
 12283 00:38D4: D0 07        	bne	L522
 12284 00:38D6: A0 1C 00     	ldy	#$1c
 12285 00:38D9: B7 28        	lda	[<L491+fp_0],Y
 12286 00:38DB: C5 19        	cmp	<L492+sect_1+2
 12287                        L522:
 12288 00:38DD: D0 03        	bne	L523
 12289 00:38DF: 82 54 00     	brl	L10280
 12290                        L523:
 12291 00:38E2: A0 12 00     	ldy	#$12
  Thu May 20 2021 21:37                                                Page 248


 12292 00:38E5: B7 28        	lda	[<L491+fp_0],Y
 12293 00:38E7: A0 0C 00     	ldy	#$c
 12294 00:38EA: D7 28        	cmp	[<L491+fp_0],Y
 12295 00:38EC: A0 14 00     	ldy	#$14
 12296 00:38EF: B7 28        	lda	[<L491+fp_0],Y
 12297 00:38F1: A0 0E 00     	ldy	#$e
 12298 00:38F4: F7 28        	sbc	[<L491+fp_0],Y
 12299 00:38F6: 90 03        	bcc	L524
 12300 00:38F8: 82 3B 00     	brl	L10280
 12301                        L524:
 12302 00:38FB: F4 01 00     	pea	#<$1
 12303 00:38FE: D4 19        	pei	<L492+sect_1+2
 12304 00:3900: D4 17        	pei	<L492+sect_1
 12305 00:3902: 18           	clc
 12306 00:3903: A9 26 00     	lda	#$26
 12307 00:3906: 65 28        	adc	<L491+fp_0
 12308 00:3908: 85 01        	sta	<R0
 12309 00:390A: A9 00 00     	lda	#$0
 12310 00:390D: 65 2A        	adc	<L491+fp_0+2
 12311 00:390F: 85 03        	sta	<R0+2
 12312 00:3911: D4 03        	pei	<R0+2
 12313 00:3913: D4 01        	pei	<R0
 12314 00:3915: A0 01 00     	ldy	#$1
 12315 00:3918: B7 0F        	lda	[<L492+fs_1],Y
 12316 00:391A: 48           	pha
 12317 00:391B: 22 xx xx xx  	jsl	~~disk_read
 12318 00:391F: AA           	tax
 12319 00:3920: D0 03        	bne	L525
 12320 00:3922: 82 11 00     	brl	L10280
 12321                        L525:
 12322                        ;					ABORT(fs, FR_DIS
                    K_ERR);
 12323 00:3925: E2 20        	sep	#$20
 12324                        	longa	off
 12325 00:3927: A9 01        	lda	#$1
 12326 00:3929: A0 11 00     	ldy	#$11
 12327 00:392C: 97 28        	sta	[<L491+fp_0],Y
 12328 00:392E: C2 20        	rep	#$20
 12329                        	longa	on
 12330 00:3930: A9 01 00     	lda	#$1
 12331 00:3933: 82 D2 FB     	brl	L496
 12332                        ;			}
 12333                        ;#endif
 12334                        ;			fp->sect = sect;
 12335                        L10280:
 12336 00:3936: A5 17        	lda	<L492+sect_1
 12337 00:3938: A0 1A 00     	ldy	#$1a
 12338 00:393B: 97 28        	sta	[<L491+fp_0],Y
 12339 00:393D: A5 19        	lda	<L492+sect_1+2
 12340 00:393F: A0 1C 00     	ldy	#$1c
 12341 00:3942: 97 28        	sta	[<L491+fp_0],Y
 12342                        ;		}
 12343                        ;		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);
                    	/* Number of bytes remains in the sector */
 12344                        L10265:
 12345 00:3944: A0 12 00     	ldy	#$12
 12346 00:3947: B7 28        	lda	[<L491+fp_0],Y
 12347 00:3949: 29 FF 01     	and	#<$1ff
  Thu May 20 2021 21:37                                                Page 249


 12348 00:394C: 85 01        	sta	<R0
 12349 00:394E: 38           	sec
 12350 00:394F: A9 00 02     	lda	#$200
 12351 00:3952: E5 01        	sbc	<R0
 12352 00:3954: 85 1B        	sta	<L492+wcnt_1
 12353                        ;		if (wcnt > btw) wcnt = btw;		
                    			/* Clip it by btw if needed */
 12354 00:3956: A5 30        	lda	<L491+btw_0
 12355 00:3958: C5 1B        	cmp	<L492+wcnt_1
 12356 00:395A: 90 03        	bcc	L526
 12357 00:395C: 82 04 00     	brl	L10281
 12358                        L526:
 12359 00:395F: A5 30        	lda	<L491+btw_0
 12360 00:3961: 85 1B        	sta	<L492+wcnt_1
 12361                        ;#if FF_FS_TINY
 12362                        ;		if (move_window(fs, fp->sect) != FR_OK) 
                    ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 12363                        ;		memcpy(fs->win + fp->fptr % SS(fs), wbuf
                    f, wcnt);	/* Fit data to the sector */
 12364                        ;		fs->wflag = 1;
 12365                        ;#else
 12366                        ;		memcpy(fp->buf + fp->fptr % SS(fs), wbuf
                    f, wcnt);	/* Fit data to the sector */
 12367                        L10281:
 12368 00:3963: D4 1B        	pei	<L492+wcnt_1
 12369 00:3965: D4 23        	pei	<L492+wbuff_1+2
 12370 00:3967: D4 21        	pei	<L492+wbuff_1
 12371 00:3969: A0 12 00     	ldy	#$12
 12372 00:396C: B7 28        	lda	[<L491+fp_0],Y
 12373 00:396E: 29 FF 01     	and	#<$1ff
 12374 00:3971: 85 01        	sta	<R0
 12375 00:3973: 64 03        	stz	<R0+2
 12376 00:3975: 18           	clc
 12377 00:3976: A9 26 00     	lda	#$26
 12378 00:3979: 65 01        	adc	<R0
 12379 00:397B: 85 05        	sta	<R1
 12380 00:397D: A9 00 00     	lda	#$0
 12381 00:3980: 65 03        	adc	<R0+2
 12382 00:3982: 85 07        	sta	<R1+2
 12383 00:3984: 18           	clc
 12384 00:3985: A5 28        	lda	<L491+fp_0
 12385 00:3987: 65 05        	adc	<R1
 12386 00:3989: 85 01        	sta	<R0
 12387 00:398B: A5 2A        	lda	<L491+fp_0+2
 12388 00:398D: 65 07        	adc	<R1+2
 12389 00:398F: 85 03        	sta	<R0+2
 12390 00:3991: D4 03        	pei	<R0+2
 12391 00:3993: D4 01        	pei	<R0
 12392 00:3995: 22 xx xx xx  	jsl	~~memcpy
 12393                        ;		fp->flag |= FA_DIRTY;
 12394 00:3999: 18           	clc
 12395 00:399A: A9 10 00     	lda	#$10
 12396 00:399D: 65 28        	adc	<L491+fp_0
 12397 00:399F: 85 01        	sta	<R0
 12398 00:39A1: A9 00 00     	lda	#$0
 12399 00:39A4: 65 2A        	adc	<L491+fp_0+2
 12400 00:39A6: 85 03        	sta	<R0+2
 12401 00:39A8: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 250


 12402                        	longa	off
 12403 00:39AA: A7 01        	lda	[<R0]
 12404 00:39AC: 09 80        	ora	#<$80
 12405 00:39AE: 87 01        	sta	[<R0]
 12406 00:39B0: C2 20        	rep	#$20
 12407                        	longa	on
 12408                        ;#endif
 12409                        ;	}
 12410 00:39B2: 82 D3 FB     	brl	L10262
 12411                        L10264:
 12412                        ;
 12413                        ;	fp->flag |= FA_MODIFIED;			
                    	/* Set file change flag */
 12414 00:39B5: 18           	clc
 12415 00:39B6: A9 10 00     	lda	#$10
 12416 00:39B9: 65 28        	adc	<L491+fp_0
 12417 00:39BB: 85 01        	sta	<R0
 12418 00:39BD: A9 00 00     	lda	#$0
 12419 00:39C0: 65 2A        	adc	<L491+fp_0+2
 12420 00:39C2: 85 03        	sta	<R0+2
 12421 00:39C4: E2 20        	sep	#$20
 12422                        	longa	off
 12423 00:39C6: A7 01        	lda	[<R0]
 12424 00:39C8: 09 40        	ora	#<$40
 12425 00:39CA: 87 01        	sta	[<R0]
 12426 00:39CC: C2 20        	rep	#$20
 12427                        	longa	on
 12428                        ;
 12429                        ;	LEAVE_FF(fs, FR_OK);
 12430 00:39CE: A9 00 00     	lda	#$0
 12431 00:39D1: 82 34 FB     	brl	L496
 12432                        ;}
 12433             00000024   L491	equ	36
 12434             0000000D   L492	equ	13
 12435                        	ends
 12436                        	efunc
 12437                        ;
 12438                        ;
 12439                        ;
 12440                        ;
 12441                        ;/*-----------------------------------------------
                    ------------------------*/
 12442                        ;/* Synchronize the File                          
                                            */
 12443                        ;/*-----------------------------------------------
                    ------------------------*/
 12444                        ;
 12445                        ;FRESULT f_sync (
 12446                        ;	FIL* fp		/* Open file to be synced */
 12447                        ;)
 12448                        ;{
 12449                        	code
 12450                        	xdef	~~f_sync
 12451                        	func
 12452                        ~~f_sync:
 12453                        	longa	on
 12454                        	longi	on
 12455 00:39D4: 3B           	tsc
  Thu May 20 2021 21:37                                                Page 251


 12456 00:39D5: 38           	sec
 12457 00:39D6: E9 12 00     	sbc	#L527
 12458 00:39D9: 1B           	tcs
 12459 00:39DA: 0B           	phd
 12460 00:39DB: 5B           	tcd
 12461             00000004   fp_0	set	4
 12462                        ;	FRESULT res;
 12463                        ;	FATFS *fs;
 12464                        ;	DWORD tm;
 12465                        ;	BYTE *dir;
 12466                        ;
 12467                        ;
 12468                        ;	res = validate(&fp->obj, &fs);	/* Check validit
                    y of the file object */
 12469             00000000   res_1	set	0
 12470             00000002   fs_1	set	2
 12471             00000006   tm_1	set	6
 12472             0000000A   dir_1	set	10
 12473 00:39DC: F4 00 00     	pea	#0
 12474 00:39DF: 18           	clc
 12475 00:39E0: 7B           	tdc
 12476 00:39E1: 69 07 00     	adc	#<L528+fs_1
 12477 00:39E4: 48           	pha
 12478 00:39E5: D4 18        	pei	<L527+fp_0+2
 12479 00:39E7: D4 16        	pei	<L527+fp_0
 12480 00:39E9: 22 xx xx xx  	jsl	~~validate
 12481 00:39ED: 85 05        	sta	<L528+res_1
 12482                        ;	if (res == FR_OK) {
 12483 00:39EF: A5 05        	lda	<L528+res_1
 12484 00:39F1: F0 03        	beq	L529
 12485 00:39F3: 82 71 01     	brl	L10282
 12486                        L529:
 12487                        ;		if (fp->flag & FA_MODIFIED) {	/* Is th
                    ere any change to the file? */
 12488 00:39F6: E2 20        	sep	#$20
 12489                        	longa	off
 12490 00:39F8: A0 10 00     	ldy	#$10
 12491 00:39FB: B7 16        	lda	[<L527+fp_0],Y
 12492 00:39FD: 29 40        	and	#<$40
 12493 00:39FF: C2 20        	rep	#$20
 12494                        	longa	on
 12495 00:3A01: D0 03        	bne	L530
 12496 00:3A03: 82 61 01     	brl	L10283
 12497                        L530:
 12498                        ;#if !FF_FS_TINY
 12499                        ;			if (fp->flag & FA_DIRTY) {	
                    /* Write-back cached data if needed */
 12500 00:3A06: E2 20        	sep	#$20
 12501                        	longa	off
 12502 00:3A08: A0 10 00     	ldy	#$10
 12503 00:3A0B: B7 16        	lda	[<L527+fp_0],Y
 12504 00:3A0D: 29 80        	and	#<$80
 12505 00:3A0F: C2 20        	rep	#$20
 12506                        	longa	on
 12507 00:3A11: D0 03        	bne	L531
 12508 00:3A13: 82 60 00     	brl	L10284
 12509                        L531:
 12510                        ;				if (disk_write(fs->pdrv,
  Thu May 20 2021 21:37                                                Page 252


                     fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 12511 00:3A16: F4 01 00     	pea	#<$1
 12512 00:3A19: A0 1C 00     	ldy	#$1c
 12513 00:3A1C: B7 16        	lda	[<L527+fp_0],Y
 12514 00:3A1E: 48           	pha
 12515 00:3A1F: A0 1A 00     	ldy	#$1a
 12516 00:3A22: B7 16        	lda	[<L527+fp_0],Y
 12517 00:3A24: 48           	pha
 12518 00:3A25: 18           	clc
 12519 00:3A26: A9 26 00     	lda	#$26
 12520 00:3A29: 65 16        	adc	<L527+fp_0
 12521 00:3A2B: 85 01        	sta	<R0
 12522 00:3A2D: A9 00 00     	lda	#$0
 12523 00:3A30: 65 18        	adc	<L527+fp_0+2
 12524 00:3A32: 85 03        	sta	<R0+2
 12525 00:3A34: D4 03        	pei	<R0+2
 12526 00:3A36: D4 01        	pei	<R0
 12527 00:3A38: A0 01 00     	ldy	#$1
 12528 00:3A3B: B7 07        	lda	[<L528+fs_1],Y
 12529 00:3A3D: 48           	pha
 12530 00:3A3E: 22 xx xx xx  	jsl	~~disk_write
 12531 00:3A42: AA           	tax
 12532 00:3A43: D0 03        	bne	L532
 12533 00:3A45: 82 15 00     	brl	L10285
 12534                        L532:
 12535 00:3A48: A9 01 00     	lda	#$1
 12536                        L533:
 12537 00:3A4B: A8           	tay
 12538 00:3A4C: A5 14        	lda	<L527+2
 12539 00:3A4E: 85 18        	sta	<L527+2+4
 12540 00:3A50: A5 13        	lda	<L527+1
 12541 00:3A52: 85 17        	sta	<L527+1+4
 12542 00:3A54: 2B           	pld
 12543 00:3A55: 3B           	tsc
 12544 00:3A56: 18           	clc
 12545 00:3A57: 69 16 00     	adc	#L527+4
 12546 00:3A5A: 1B           	tcs
 12547 00:3A5B: 98           	tya
 12548 00:3A5C: 6B           	rtl
 12549                        ;				fp->flag &= (BYTE)~FA_DI
                    RTY;
 12550                        L10285:
 12551 00:3A5D: 18           	clc
 12552 00:3A5E: A9 10 00     	lda	#$10
 12553 00:3A61: 65 16        	adc	<L527+fp_0
 12554 00:3A63: 85 01        	sta	<R0
 12555 00:3A65: A9 00 00     	lda	#$0
 12556 00:3A68: 65 18        	adc	<L527+fp_0+2
 12557 00:3A6A: 85 03        	sta	<R0+2
 12558 00:3A6C: E2 20        	sep	#$20
 12559                        	longa	off
 12560 00:3A6E: A7 01        	lda	[<R0]
 12561 00:3A70: 29 7F        	and	#<$7f
 12562 00:3A72: 87 01        	sta	[<R0]
 12563 00:3A74: C2 20        	rep	#$20
 12564                        	longa	on
 12565                        ;			}
 12566                        ;#endif
  Thu May 20 2021 21:37                                                Page 253


 12567                        ;			/* Update the directory entry */
 12568                        ;			tm = GET_FATTIME();		
                    		/* Modified time */
 12569                        L10284:
 12570 00:3A76: A9 00 00     	lda	#$0
 12571 00:3A79: 85 0B        	sta	<L528+tm_1
 12572 00:3A7B: A9 21 50     	lda	#$5021
 12573 00:3A7E: 85 0D        	sta	<L528+tm_1+2
 12574                        ;#if FF_FS_EXFAT
 12575                        ;			if (fs->fs_type == FS_EXFAT) {
 12576                        ;				res = fill_first_frag(&f
                    p->obj);	/* Fill first fragment on the FAT if needed */
 12577                        ;				if (res == FR_OK) {
 12578                        ;					res = fill_last_
                    frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fra
                    gment on the FAT if needed */
 12579                        ;				}
 12580                        ;				if (res == FR_OK) {
 12581                        ;					DIR dj;
 12582                        ;					DEF_NAMBUF
 12583                        ;
 12584                        ;					INIT_NAMBUF(fs);
 12585                        ;					res = load_obj_x
                    dir(&dj, &fp->obj);	/* Load directory entry block */
 12586                        ;					if (res == FR_OK
                    ) {
 12587                        ;						fs->dirb
                    uf[XDIR_Attr] |= AM_ARC;				/* Set a
                    rchive attribute to indicate that the file has been changed 
                    */
 12588                        ;						fs->dirb
                    uf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file a
                    llocation information */
 12589                        ;						st_dword
                    (fs->dirbuf + XDIR_FstClus, fp->obj.sclust);		
                    /* Update start cluster */
 12590                        ;						st_qword
                    (fs->dirbuf + XDIR_FileSize, fp->obj.objsize);		
                    /* Update file size */
 12591                        ;						st_qword
                    (fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);	/* (FatF
                    s does not support Valid File Size feature) */
 12592                        ;						st_dword
                    (fs->dirbuf + XDIR_ModTime, tm);		/* Update modifi
                    ed time */
 12593                        ;						fs->dirb
                    uf[XDIR_ModTime10] = 0;
 12594                        ;						st_dword
                    (fs->dirbuf + XDIR_AccTime, 0);
 12595                        ;						res = st
                    ore_xdir(&dj);	/* Restore it to the directory */
 12596                        ;						if (res 
                    == FR_OK) {
 12597                        ;							
                    res = sync_fs(fs);
 12598                        ;							
                    fp->flag &= (BYTE)~FA_MODIFIED;
 12599                        ;						}
  Thu May 20 2021 21:37                                                Page 254


 12600                        ;					}
 12601                        ;					FREE_NAMBUF();
 12602                        ;				}
 12603                        ;			} else
 12604                        ;#endif
 12605                        ;			{
 12606                        ;				res = move_window(fs, fp
                    ->dir_sect);
 12607 00:3A80: A0 20 00     	ldy	#$20
 12608 00:3A83: B7 16        	lda	[<L527+fp_0],Y
 12609 00:3A85: 48           	pha
 12610 00:3A86: A0 1E 00     	ldy	#$1e
 12611 00:3A89: B7 16        	lda	[<L527+fp_0],Y
 12612 00:3A8B: 48           	pha
 12613 00:3A8C: D4 09        	pei	<L528+fs_1+2
 12614 00:3A8E: D4 07        	pei	<L528+fs_1
 12615 00:3A90: 22 xx xx xx  	jsl	~~move_window
 12616 00:3A94: 85 05        	sta	<L528+res_1
 12617                        ;				if (res == FR_OK) {
 12618 00:3A96: A5 05        	lda	<L528+res_1
 12619 00:3A98: F0 03        	beq	L534
 12620 00:3A9A: 82 CA 00     	brl	L10286
 12621                        L534:
 12622                        ;					dir = fp->dir_pt
                    r;
 12623 00:3A9D: A0 22 00     	ldy	#$22
 12624 00:3AA0: B7 16        	lda	[<L527+fp_0],Y
 12625 00:3AA2: 85 0F        	sta	<L528+dir_1
 12626 00:3AA4: A0 24 00     	ldy	#$24
 12627 00:3AA7: B7 16        	lda	[<L527+fp_0],Y
 12628 00:3AA9: 85 11        	sta	<L528+dir_1+2
 12629                        ;					dir[DIR_Attr] |=
                     AM_ARC;						/* Set a
                    rchive attribute to indicate that the file has been changed 
                    */
 12630 00:3AAB: 18           	clc
 12631 00:3AAC: A9 0B 00     	lda	#$b
 12632 00:3AAF: 65 0F        	adc	<L528+dir_1
 12633 00:3AB1: 85 01        	sta	<R0
 12634 00:3AB3: A9 00 00     	lda	#$0
 12635 00:3AB6: 65 11        	adc	<L528+dir_1+2
 12636 00:3AB8: 85 03        	sta	<R0+2
 12637 00:3ABA: E2 20        	sep	#$20
 12638                        	longa	off
 12639 00:3ABC: A7 01        	lda	[<R0]
 12640 00:3ABE: 09 20        	ora	#<$20
 12641 00:3AC0: 87 01        	sta	[<R0]
 12642 00:3AC2: C2 20        	rep	#$20
 12643                        	longa	on
 12644                        ;					st_clust(fp->obj
                    .fs, dir, fp->obj.sclust);		/* Update file allocatio
                    n information  */
 12645 00:3AC4: A0 0A 00     	ldy	#$a
 12646 00:3AC7: B7 16        	lda	[<L527+fp_0],Y
 12647 00:3AC9: 48           	pha
 12648 00:3ACA: A0 08 00     	ldy	#$8
 12649 00:3ACD: B7 16        	lda	[<L527+fp_0],Y
 12650 00:3ACF: 48           	pha
  Thu May 20 2021 21:37                                                Page 255


 12651 00:3AD0: D4 11        	pei	<L528+dir_1+2
 12652 00:3AD2: D4 0F        	pei	<L528+dir_1
 12653 00:3AD4: A0 02 00     	ldy	#$2
 12654 00:3AD7: B7 16        	lda	[<L527+fp_0],Y
 12655 00:3AD9: 48           	pha
 12656 00:3ADA: A7 16        	lda	[<L527+fp_0]
 12657 00:3ADC: 48           	pha
 12658 00:3ADD: 22 xx xx xx  	jsl	~~st_clust
 12659                        ;					st_dword(dir + D
                    IR_FileSize, (DWORD)fp->obj.objsize);	/* Update file s
                    ize */
 12660 00:3AE1: A0 0E 00     	ldy	#$e
 12661 00:3AE4: B7 16        	lda	[<L527+fp_0],Y
 12662 00:3AE6: 48           	pha
 12663 00:3AE7: A0 0C 00     	ldy	#$c
 12664 00:3AEA: B7 16        	lda	[<L527+fp_0],Y
 12665 00:3AEC: 48           	pha
 12666 00:3AED: 18           	clc
 12667 00:3AEE: A9 1C 00     	lda	#$1c
 12668 00:3AF1: 65 0F        	adc	<L528+dir_1
 12669 00:3AF3: 85 01        	sta	<R0
 12670 00:3AF5: A9 00 00     	lda	#$0
 12671 00:3AF8: 65 11        	adc	<L528+dir_1+2
 12672 00:3AFA: 85 03        	sta	<R0+2
 12673 00:3AFC: D4 03        	pei	<R0+2
 12674 00:3AFE: D4 01        	pei	<R0
 12675 00:3B00: 22 xx xx xx  	jsl	~~st_dword
 12676                        ;					st_dword(dir + D
                    IR_ModTime, tm);				/* Update modifi
                    ed time */
 12677 00:3B04: D4 0D        	pei	<L528+tm_1+2
 12678 00:3B06: D4 0B        	pei	<L528+tm_1
 12679 00:3B08: 18           	clc
 12680 00:3B09: A9 16 00     	lda	#$16
 12681 00:3B0C: 65 0F        	adc	<L528+dir_1
 12682 00:3B0E: 85 01        	sta	<R0
 12683 00:3B10: A9 00 00     	lda	#$0
 12684 00:3B13: 65 11        	adc	<L528+dir_1+2
 12685 00:3B15: 85 03        	sta	<R0+2
 12686 00:3B17: D4 03        	pei	<R0+2
 12687 00:3B19: D4 01        	pei	<R0
 12688 00:3B1B: 22 xx xx xx  	jsl	~~st_dword
 12689                        ;					st_word(dir + DI
                    R_LstAccDate, 0);
 12690 00:3B1F: F4 00 00     	pea	#<$0
 12691 00:3B22: 18           	clc
 12692 00:3B23: A9 12 00     	lda	#$12
 12693 00:3B26: 65 0F        	adc	<L528+dir_1
 12694 00:3B28: 85 01        	sta	<R0
 12695 00:3B2A: A9 00 00     	lda	#$0
 12696 00:3B2D: 65 11        	adc	<L528+dir_1+2
 12697 00:3B2F: 85 03        	sta	<R0+2
 12698 00:3B31: D4 03        	pei	<R0+2
 12699 00:3B33: D4 01        	pei	<R0
 12700 00:3B35: 22 xx xx xx  	jsl	~~st_word
 12701                        ;					fs->wflag = 1;
 12702 00:3B39: E2 20        	sep	#$20
 12703                        	longa	off
  Thu May 20 2021 21:37                                                Page 256


 12704 00:3B3B: A9 01        	lda	#$1
 12705 00:3B3D: A0 03 00     	ldy	#$3
 12706 00:3B40: 97 07        	sta	[<L528+fs_1],Y
 12707 00:3B42: C2 20        	rep	#$20
 12708                        	longa	on
 12709                        ;					res = sync_fs(fs
                    );					/* Restore it to the dir
                    ectory */
 12710 00:3B44: D4 09        	pei	<L528+fs_1+2
 12711 00:3B46: D4 07        	pei	<L528+fs_1
 12712 00:3B48: 22 xx xx xx  	jsl	~~sync_fs
 12713 00:3B4C: 85 05        	sta	<L528+res_1
 12714                        ;					fp->flag &= (BYT
                    E)~FA_MODIFIED;
 12715 00:3B4E: 18           	clc
 12716 00:3B4F: A9 10 00     	lda	#$10
 12717 00:3B52: 65 16        	adc	<L527+fp_0
 12718 00:3B54: 85 01        	sta	<R0
 12719 00:3B56: A9 00 00     	lda	#$0
 12720 00:3B59: 65 18        	adc	<L527+fp_0+2
 12721 00:3B5B: 85 03        	sta	<R0+2
 12722 00:3B5D: E2 20        	sep	#$20
 12723                        	longa	off
 12724 00:3B5F: A7 01        	lda	[<R0]
 12725 00:3B61: 29 BF        	and	#<$bf
 12726 00:3B63: 87 01        	sta	[<R0]
 12727 00:3B65: C2 20        	rep	#$20
 12728                        	longa	on
 12729                        ;				}
 12730                        ;			}
 12731                        L10286:
 12732                        ;		}
 12733                        ;	}
 12734                        L10283:
 12735                        ;
 12736                        ;	LEAVE_FF(fs, res);
 12737                        L10282:
 12738 00:3B67: A5 05        	lda	<L528+res_1
 12739 00:3B69: 82 DF FE     	brl	L533
 12740                        ;}
 12741             00000012   L527	equ	18
 12742             00000005   L528	equ	5
 12743                        	ends
 12744                        	efunc
 12745                        ;
 12746                        ;#endif /* !FF_FS_READONLY */
 12747                        ;
 12748                        ;
 12749                        ;
 12750                        ;
 12751                        ;/*-----------------------------------------------
                    ------------------------*/
 12752                        ;/* Close File                                    
                                            */
 12753                        ;/*-----------------------------------------------
                    ------------------------*/
 12754                        ;
 12755                        ;FRESULT f_close (
  Thu May 20 2021 21:37                                                Page 257


 12756                        ;	FIL* fp		/* Open file to be closed */
 12757                        ;)
 12758                        ;{
 12759                        	code
 12760                        	xdef	~~f_close
 12761                        	func
 12762                        ~~f_close:
 12763                        	longa	on
 12764                        	longi	on
 12765 00:3B6C: 3B           	tsc
 12766 00:3B6D: 38           	sec
 12767 00:3B6E: E9 06 00     	sbc	#L535
 12768 00:3B71: 1B           	tcs
 12769 00:3B72: 0B           	phd
 12770 00:3B73: 5B           	tcd
 12771             00000004   fp_0	set	4
 12772                        ;	FRESULT res;
 12773                        ;	FATFS *fs;
 12774                        ;
 12775                        ;#if !FF_FS_READONLY
 12776                        ;	res = f_sync(fp);				
                    	/* Flush cached data */
 12777             00000000   res_1	set	0
 12778             00000002   fs_1	set	2
 12779 00:3B74: D4 0C        	pei	<L535+fp_0+2
 12780 00:3B76: D4 0A        	pei	<L535+fp_0
 12781 00:3B78: 22 xx xx xx  	jsl	~~f_sync
 12782 00:3B7C: 85 01        	sta	<L536+res_1
 12783                        ;	if (res == FR_OK)
 12784                        ;#endif
 12785                        ;	{
 12786 00:3B7E: A5 01        	lda	<L536+res_1
 12787 00:3B80: F0 03        	beq	L537
 12788 00:3B82: 82 27 00     	brl	L10287
 12789                        L537:
 12790                        ;		res = validate(&fp->obj, &fs);	/* Lock 
                    volume */
 12791 00:3B85: F4 00 00     	pea	#0
 12792 00:3B88: 18           	clc
 12793 00:3B89: 7B           	tdc
 12794 00:3B8A: 69 03 00     	adc	#<L536+fs_1
 12795 00:3B8D: 48           	pha
 12796 00:3B8E: D4 0C        	pei	<L535+fp_0+2
 12797 00:3B90: D4 0A        	pei	<L535+fp_0
 12798 00:3B92: 22 xx xx xx  	jsl	~~validate
 12799 00:3B96: 85 01        	sta	<L536+res_1
 12800                        ;		if (res == FR_OK) {
 12801 00:3B98: A5 01        	lda	<L536+res_1
 12802 00:3B9A: F0 03        	beq	L538
 12803 00:3B9C: 82 0D 00     	brl	L10288
 12804                        L538:
 12805                        ;#if FF_FS_LOCK != 0
 12806                        ;			res = dec_lock(fp->obj.lockid);	
                    	/* Decrement file open counter */
 12807                        ;			if (res == FR_OK) fp->obj.fs = 0
                    ;	/* Invalidate file object */
 12808                        ;#else
 12809                        ;			fp->obj.fs = 0;	/* Invalidate fi
  Thu May 20 2021 21:37                                                Page 258


                    le object */
 12810 00:3B9F: A9 00 00     	lda	#$0
 12811 00:3BA2: 87 0A        	sta	[<L535+fp_0]
 12812 00:3BA4: A9 00 00     	lda	#$0
 12813 00:3BA7: A0 02 00     	ldy	#$2
 12814 00:3BAA: 97 0A        	sta	[<L535+fp_0],Y
 12815                        ;#endif
 12816                        ;#if FF_FS_REENTRANT
 12817                        ;			unlock_fs(fs, FR_OK);		
                    /* Unlock volume */
 12818                        ;#endif
 12819                        ;		}
 12820                        ;	}
 12821                        L10288:
 12822                        ;	return res;
 12823                        L10287:
 12824 00:3BAC: A5 01        	lda	<L536+res_1
 12825                        L539:
 12826 00:3BAE: A8           	tay
 12827 00:3BAF: A5 08        	lda	<L535+2
 12828 00:3BB1: 85 0C        	sta	<L535+2+4
 12829 00:3BB3: A5 07        	lda	<L535+1
 12830 00:3BB5: 85 0B        	sta	<L535+1+4
 12831 00:3BB7: 2B           	pld
 12832 00:3BB8: 3B           	tsc
 12833 00:3BB9: 18           	clc
 12834 00:3BBA: 69 0A 00     	adc	#L535+4
 12835 00:3BBD: 1B           	tcs
 12836 00:3BBE: 98           	tya
 12837 00:3BBF: 6B           	rtl
 12838                        ;}
 12839             00000006   L535	equ	6
 12840             00000001   L536	equ	1
 12841                        	ends
 12842                        	efunc
 12843                        ;
 12844                        ;
 12845                        ;
 12846                        ;
 12847                        ;#if FF_FS_RPATH >= 1
 12848                        ;/*-----------------------------------------------
                    ------------------------*/
 12849                        ;/* Change Current Directory or Current Drive, Get
                     Current Directory      */
 12850                        ;/*-----------------------------------------------
                    ------------------------*/
 12851                        ;
 12852                        ;FRESULT f_chdrive (
 12853                        ;	const TCHAR* path		/* Drive number 
                    to set */
 12854                        ;)
 12855                        ;{
 12856                        ;	int vol;
 12857                        ;
 12858                        ;
 12859                        ;	/* Get logical drive number */
 12860                        ;	vol = get_ldnumber(&path);
 12861                        ;	if (vol < 0) return FR_INVALID_DRIVE;
  Thu May 20 2021 21:37                                                Page 259


 12862                        ;	CurrVol = (BYTE)vol;	/* Set it as current vol
                    ume */
 12863                        ;
 12864                        ;	return FR_OK;
 12865                        ;}
 12866                        ;
 12867                        ;
 12868                        ;
 12869                        ;FRESULT f_chdir (
 12870                        ;	const TCHAR* path	/* Pointer to the direct
                    ory path */
 12871                        ;)
 12872                        ;{
 12873                        ;#if FF_STR_VOLUME_ID == 2
 12874                        ;	UINT i;
 12875                        ;#endif
 12876                        ;	FRESULT res;
 12877                        ;	DIR dj;
 12878                        ;	FATFS *fs;
 12879                        ;	DEF_NAMBUF
 12880                        ;
 12881                        ;
 12882                        ;	/* Get logical drive */
 12883                        ;	res = mount_volume(&path, &fs, 0);
 12884                        ;	if (res == FR_OK) {
 12885                        ;		dj.obj.fs = fs;
 12886                        ;		INIT_NAMBUF(fs);
 12887                        ;		res = follow_path(&dj, path);		
                    /* Follow the path */
 12888                        ;		if (res == FR_OK) {			
                    		/* Follow completed */
 12889                        ;			if (dj.fn[NSFLAG] & NS_NONAME) {
                    	/* Is it the start directory itself? */
 12890                        ;				fs->cdir = dj.obj.sclust
                    ;
 12891                        ;#if FF_FS_EXFAT
 12892                        ;				if (fs->fs_type == FS_EX
                    FAT) {
 12893                        ;					fs->cdc_scl = dj
                    .obj.c_scl;
 12894                        ;					fs->cdc_size = d
                    j.obj.c_size;
 12895                        ;					fs->cdc_ofs = dj
                    .obj.c_ofs;
 12896                        ;				}
 12897                        ;#endif
 12898                        ;			} else {
 12899                        ;				if (dj.obj.attr & AM_DIR
                    ) {	/* It is a sub-directory */
 12900                        ;#if FF_FS_EXFAT
 12901                        ;					if (fs->fs_type 
                    == FS_EXFAT) {
 12902                        ;						fs->cdir
                     = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-d
                    irectory cluster */
 12903                        ;						fs->cdc_
                    scl = dj.obj.sclust;					
                    	/* Save containing directory information */
  Thu May 20 2021 21:37                                                Page 260


 12904                        ;						fs->cdc_
                    size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 12905                        ;						fs->cdc_
                    ofs = dj.blk_ofs;
 12906                        ;					} else
 12907                        ;#endif
 12908                        ;					{
 12909                        ;						fs->cdir
                     = ld_clust(fs, dj.dir);					
                    /* Sub-directory cluster */
 12910                        ;					}
 12911                        ;				} else {
 12912                        ;					res = FR_NO_PATH
                    ;		/* Reached but a file */
 12913                        ;				}
 12914                        ;			}
 12915                        ;		}
 12916                        ;		FREE_NAMBUF();
 12917                        ;		if (res == FR_NO_FILE) res = FR_NO_PATH;
 12918                        ;#if FF_STR_VOLUME_ID == 2	/* Also current 
                    drive is changed if in Unix style volume ID */
 12919                        ;		if (res == FR_OK) {
 12920                        ;			for (i = FF_VOLUMES - 1; i && fs
                     != FatFs[i]; i--) ;	/* Set current drive */
 12921                        ;			CurrVol = (BYTE)i;
 12922                        ;		}
 12923                        ;#endif
 12924                        ;	}
 12925                        ;
 12926                        ;	LEAVE_FF(fs, res);
 12927                        ;}
 12928                        ;
 12929                        ;
 12930                        ;#if FF_FS_RPATH >= 2
 12931                        ;FRESULT f_getcwd (
 12932                        ;	TCHAR* buff,	/* Pointer to the directory path
                     */
 12933                        ;	UINT len		/* Size of buff in unit 
                    of TCHAR */
 12934                        ;)
 12935                        ;{
 12936                        ;	FRESULT res;
 12937                        ;	DIR dj;
 12938                        ;	FATFS *fs;
 12939                        ;	UINT i, n;
 12940                        ;	DWORD ccl;
 12941                        ;	TCHAR *tp = buff;
 12942                        ;#if FF_VOLUMES >= 2
 12943                        ;	UINT vl;
 12944                        ;#if FF_STR_VOLUME_ID
 12945                        ;	const char *vp;
 12946                        ;#endif
 12947                        ;#endif
 12948                        ;	FILINFO fno;
 12949                        ;	DEF_NAMBUF
 12950                        ;
 12951                        ;
 12952                        ;	/* Get logical drive */
  Thu May 20 2021 21:37                                                Page 261


 12953                        ;	buff[0] = 0;	/* Set null string to get curren
                    t volume */
 12954                        ;	res = mount_volume((const TCHAR**)&buff, &fs, 0)
                    ;	/* Get current volume */
 12955                        ;	if (res == FR_OK) {
 12956                        ;		dj.obj.fs = fs;
 12957                        ;		INIT_NAMBUF(fs);
 12958                        ;
 12959                        ;		/* Follow parent directories and create 
                    the path */
 12960                        ;		i = len;			/* Botto
                    m of buffer (directory stack base) */
 12961                        ;		if (!FF_FS_EXFAT || fs->fs_type != FS_EX
                    FAT) {	/* (Cannot do getcwd on exFAT and returns root p
                    ath) */
 12962                        ;			dj.obj.sclust = fs->cdir;	
                    			/* Start to follow upper directory from 
                    current directory */
 12963                        ;			while ((ccl = dj.obj.sclust) != 
                    0) {	/* Repeat while current directory is a sub-direc
                    tory */
 12964                        ;				res = dir_sdi(&dj, 1 * S
                    ZDIRE);	/* Get parent directory */
 12965                        ;				if (res != FR_OK) break;
 12966                        ;				res = move_window(fs, dj
                    .sect);
 12967                        ;				if (res != FR_OK) break;
 12968                        ;				dj.obj.sclust = ld_clust
                    (fs, dj.dir);	/* Goto parent directory */
 12969                        ;				res = dir_sdi(&dj, 0);
 12970                        ;				if (res != FR_OK) break;
 12971                        ;				do {			
                    				/* Find the entry links to the c
                    hild directory */
 12972                        ;					res = DIR_READ_F
                    ILE(&dj);
 12973                        ;					if (res != FR_OK
                    ) break;
 12974                        ;					if (ccl == ld_cl
                    ust(fs, dj.dir)) break;	/* Found the entry */
 12975                        ;					res = dir_next(&
                    dj, 0);
 12976                        ;				} while (res == FR_OK);
 12977                        ;				if (res == FR_NO_FILE) r
                    es = FR_INT_ERR;/* It cannot be 'not found'. */
 12978                        ;				if (res != FR_OK) break;
 12979                        ;				get_fileinfo(&dj, &fno);
                    		/* Get the directory name and push it to the buf
                    fer */
 12980                        ;				for (n = 0; fno.fname[n]
                    ; n++) ;	/* Name length */
 12981                        ;				if (i < n + 1) {	
                    /* Insufficient space to store the path name? */
 12982                        ;					res = FR_NOT_ENO
                    UGH_CORE; break;
 12983                        ;				}
 12984                        ;				while (n) buff[--i] = fn
                    o.fname[--n];	/* Stack the name */
  Thu May 20 2021 21:37                                                Page 262


 12985                        ;				buff[--i] = '/';
 12986                        ;			}
 12987                        ;		}
 12988                        ;		if (res == FR_OK) {
 12989                        ;			if (i == len) buff[--i] = '/';	
                    /* Is it the root-directory? */
 12990                        ;#if FF_VOLUMES >= 2			/* Put d
                    rive prefix */
 12991                        ;			vl = 0;
 12992                        ;#if FF_STR_VOLUME_ID >= 1	/* String volume
                     ID */
 12993                        ;			for (n = 0, vp = (const char*)Vo
                    lumeStr[CurrVol]; vp[n]; n++) ;
 12994                        ;			if (i >= n + 2) {
 12995                        ;				if (FF_STR_VOLUME_ID == 
                    2) *tp++ = (TCHAR)'/';
 12996                        ;				for (vl = 0; vl < n; *tp
                    ++ = (TCHAR)vp[vl], vl++) ;
 12997                        ;				if (FF_STR_VOLUME_ID == 
                    1) *tp++ = (TCHAR)':';
 12998                        ;				vl++;
 12999                        ;			}
 13000                        ;#else						
                    /* Numeric volume ID */
 13001                        ;			if (i >= 3) {
 13002                        ;				*tp++ = (TCHAR)'0' + Cur
                    rVol;
 13003                        ;				*tp++ = (TCHAR)':';
 13004                        ;				vl = 2;
 13005                        ;			}
 13006                        ;#endif
 13007                        ;			if (vl == 0) res = FR_NOT_ENOUGH
                    _CORE;
 13008                        ;#endif
 13009                        ;			/* Add current directory path */
 13010                        ;			if (res == FR_OK) {
 13011                        ;				do *tp++ = buff[i++]; wh
                    ile (i < len);	/* Copy stacked path string */
 13012                        ;			}
 13013                        ;		}
 13014                        ;		FREE_NAMBUF();
 13015                        ;	}
 13016                        ;
 13017                        ;	*tp = 0;
 13018                        ;	LEAVE_FF(fs, res);
 13019                        ;}
 13020                        ;
 13021                        ;#endif /* FF_FS_RPATH >= 2 */
 13022                        ;#endif /* FF_FS_RPATH >= 1 */
 13023                        ;
 13024                        ;
 13025                        ;
 13026                        ;#if FF_FS_MINIMIZE <= 2
 13027                        ;/*-----------------------------------------------
                    ------------------------*/
 13028                        ;/* Seek File Read/Write Pointer                  
                                            */
 13029                        ;/*-----------------------------------------------
  Thu May 20 2021 21:37                                                Page 263


                    ------------------------*/
 13030                        ;
 13031                        ;FRESULT f_lseek (
 13032                        ;	FIL* fp,		/* Pointer to the file o
                    bject */
 13033                        ;	FSIZE_t ofs		/* File pointer from top
                     of file */
 13034                        ;)
 13035                        ;{
 13036                        	code
 13037                        	xdef	~~f_lseek
 13038                        	func
 13039                        ~~f_lseek:
 13040                        	longa	on
 13041                        	longi	on
 13042 00:3BC0: 3B           	tsc
 13043 00:3BC1: 38           	sec
 13044 00:3BC2: E9 22 00     	sbc	#L540
 13045 00:3BC5: 1B           	tcs
 13046 00:3BC6: 0B           	phd
 13047 00:3BC7: 5B           	tcd
 13048             00000004   fp_0	set	4
 13049             00000008   ofs_0	set	8
 13050                        ;	FRESULT res;
 13051                        ;	FATFS *fs;
 13052                        ;	DWORD clst, bcs;
 13053                        ;	LBA_t nsect;
 13054                        ;	FSIZE_t ifptr;
 13055                        ;#if FF_USE_FASTSEEK
 13056                        ;	DWORD cl, pcl, ncl, tcl, tlen, ulen;
 13057                        ;	DWORD *tbl;
 13058                        ;	LBA_t dsc;
 13059                        ;#endif
 13060                        ;
 13061                        ;	res = validate(&fp->obj, &fs);		/* Check
                     validity of the file object */
 13062             00000000   res_1	set	0
 13063             00000002   fs_1	set	2
 13064             00000006   clst_1	set	6
 13065             0000000A   bcs_1	set	10
 13066             0000000E   nsect_1	set	14
 13067             00000012   ifptr_1	set	18
 13068 00:3BC8: F4 00 00     	pea	#0
 13069 00:3BCB: 18           	clc
 13070 00:3BCC: 7B           	tdc
 13071 00:3BCD: 69 0F 00     	adc	#<L541+fs_1
 13072 00:3BD0: 48           	pha
 13073 00:3BD1: D4 28        	pei	<L540+fp_0+2
 13074 00:3BD3: D4 26        	pei	<L540+fp_0
 13075 00:3BD5: 22 xx xx xx  	jsl	~~validate
 13076 00:3BD9: 85 0D        	sta	<L541+res_1
 13077                        ;	if (res == FR_OK) res = (FRESULT)fp->err;
 13078 00:3BDB: A5 0D        	lda	<L541+res_1
 13079 00:3BDD: F0 03        	beq	L542
 13080 00:3BDF: 82 0A 00     	brl	L10289
 13081                        L542:
 13082 00:3BE2: A0 11 00     	ldy	#$11
 13083 00:3BE5: B7 26        	lda	[<L540+fp_0],Y
  Thu May 20 2021 21:37                                                Page 264


 13084 00:3BE7: 29 FF 00     	and	#$ff
 13085 00:3BEA: 85 0D        	sta	<L541+res_1
 13086                        ;#if FF_FS_EXFAT && !FF_FS_READONLY
 13087                        ;	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
 13088                        ;		res = fill_last_frag(&fp->obj, fp->clust
                    , 0xFFFFFFFF);	/* Fill last fragment on the FAT if need
                    ed */
 13089                        ;	}
 13090                        ;#endif
 13091                        ;	if (res != FR_OK) LEAVE_FF(fs, res);
 13092                        L10289:
 13093 00:3BEC: A5 0D        	lda	<L541+res_1
 13094 00:3BEE: D0 03        	bne	L543
 13095 00:3BF0: 82 14 00     	brl	L10290
 13096                        L543:
 13097 00:3BF3: A5 0D        	lda	<L541+res_1
 13098                        L544:
 13099 00:3BF5: A8           	tay
 13100 00:3BF6: A5 24        	lda	<L540+2
 13101 00:3BF8: 85 2C        	sta	<L540+2+8
 13102 00:3BFA: A5 23        	lda	<L540+1
 13103 00:3BFC: 85 2B        	sta	<L540+1+8
 13104 00:3BFE: 2B           	pld
 13105 00:3BFF: 3B           	tsc
 13106 00:3C00: 18           	clc
 13107 00:3C01: 69 2A 00     	adc	#L540+8
 13108 00:3C04: 1B           	tcs
 13109 00:3C05: 98           	tya
 13110 00:3C06: 6B           	rtl
 13111                        ;
 13112                        ;#if FF_USE_FASTSEEK
 13113                        ;	if (fp->cltbl) {	/* Fast seek */
 13114                        ;		if (ofs == CREATE_LINKMAP) {	/* Creat
                    e CLMT */
 13115                        ;			tbl = fp->cltbl;
 13116                        ;			tlen = *tbl++; ulen = 2;	
                    /* Given table size and required table size */
 13117                        ;			cl = fp->obj.sclust;		
                    /* Origin of the chain */
 13118                        ;			if (cl != 0) {
 13119                        ;				do {
 13120                        ;					/* Get a fragmen
                    t */
 13121                        ;					tcl = cl; ncl = 
                    0; ulen += 2;	/* Top, length and used items */
 13122                        ;					do {
 13123                        ;						pcl = cl
                    ; ncl++;
 13124                        ;						cl = get
                    _fat(&fp->obj, cl);
 13125                        ;						if (cl <
                    = 1) ABORT(fs, FR_INT_ERR);
 13126                        ;						if (cl =
                    = 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 13127                        ;					} while (cl == p
                    cl + 1);
 13128                        ;					if (ulen <= tlen
                    ) {		/* Store the length and top of the fragment */
  Thu May 20 2021 21:37                                                Page 265


 13129                        ;						*tbl++ =
                     ncl; *tbl++ = tcl;
 13130                        ;					}
 13131                        ;				} while (cl < fs->n_fate
                    nt);	/* Repeat until end of chain */
 13132                        ;			}
 13133                        ;			*fp->cltbl = ulen;	/* Numbe
                    r of items used */
 13134                        ;			if (ulen <= tlen) {
 13135                        ;				*tbl = 0;		
                    /* Terminate table */
 13136                        ;			} else {
 13137                        ;				res = FR_NOT_ENOUGH_CORE
                    ;	/* Given table size is smaller than required */
 13138                        ;			}
 13139                        ;		} else {				
                    		/* Fast seek */
 13140                        ;			if (ofs > fp->obj.objsize) ofs =
                     fp->obj.objsize;	/* Clip offset at the file size */
 13141                        ;			fp->fptr = ofs;			
                    	/* Set file pointer */
 13142                        ;			if (ofs > 0) {
 13143                        ;				fp->clust = clmt_clust(f
                    p, ofs - 1);
 13144                        ;				dsc = clst2sect(fs, fp->
                    clust);
 13145                        ;				if (dsc == 0) ABORT(fs, 
                    FR_INT_ERR);
 13146                        ;				dsc += (DWORD)((ofs - 1)
                     / SS(fs)) & (fs->csize - 1);
 13147                        ;				if (fp->fptr % SS(fs) &&
                     dsc != fp->sect) {	/* Refill sector cache if needed */
 13148                        ;#if !FF_FS_TINY
 13149                        ;#if !FF_FS_READONLY
 13150                        ;					if (fp->flag & F
                    A_DIRTY) {		/* Write-back dirty sector cache */
 13151                        ;						if (disk
                    _write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, 
                    FR_DISK_ERR);
 13152                        ;						fp->flag
                     &= (BYTE)~FA_DIRTY;
 13153                        ;					}
 13154                        ;#endif
 13155                        ;					if (disk_read(fs
                    ->pdrv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	
                    /* Load current sector */
 13156                        ;#endif
 13157                        ;					fp->sect = dsc;
 13158                        ;				}
 13159                        ;			}
 13160                        ;		}
 13161                        ;	} else
 13162                        ;#endif
 13163                        ;
 13164                        ;	/* Normal Seek */
 13165                        ;	{
 13166                        L10290:
 13167                        ;#if FF_FS_EXFAT
  Thu May 20 2021 21:37                                                Page 266


 13168                        ;		if (fs->fs_type != FS_EXFAT && ofs >= 0x
                    100000000) ofs = 0xFFFFFFFF;	/* Clip at 4 GiB - 1 if 
                    at FATxx */
 13169                        ;#endif
 13170                        ;		if (ofs > fp->obj.objsize && (FF_FS_READ
                    ONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, cl
                    ip offset with the file size */
 13171 00:3C07: A0 0C 00     	ldy	#$c
 13172 00:3C0A: B7 26        	lda	[<L540+fp_0],Y
 13173 00:3C0C: C5 2A        	cmp	<L540+ofs_0
 13174 00:3C0E: A0 0E 00     	ldy	#$e
 13175 00:3C11: B7 26        	lda	[<L540+fp_0],Y
 13176 00:3C13: E5 2C        	sbc	<L540+ofs_0+2
 13177 00:3C15: 90 03        	bcc	L545
 13178 00:3C17: 82 1E 00     	brl	L10291
 13179                        L545:
 13180 00:3C1A: E2 20        	sep	#$20
 13181                        	longa	off
 13182 00:3C1C: A0 10 00     	ldy	#$10
 13183 00:3C1F: B7 26        	lda	[<L540+fp_0],Y
 13184 00:3C21: 29 02        	and	#<$2
 13185 00:3C23: C2 20        	rep	#$20
 13186                        	longa	on
 13187 00:3C25: F0 03        	beq	L547
 13188 00:3C27: 82 0E 00     	brl	L10291
 13189                        L547:
 13190                        L546:
 13191                        ;			ofs = fp->obj.objsize;
 13192 00:3C2A: A0 0C 00     	ldy	#$c
 13193 00:3C2D: B7 26        	lda	[<L540+fp_0],Y
 13194 00:3C2F: 85 2A        	sta	<L540+ofs_0
 13195 00:3C31: A0 0E 00     	ldy	#$e
 13196 00:3C34: B7 26        	lda	[<L540+fp_0],Y
 13197 00:3C36: 85 2C        	sta	<L540+ofs_0+2
 13198                        ;		}
 13199                        ;		ifptr = fp->fptr;
 13200                        L10291:
 13201 00:3C38: A0 12 00     	ldy	#$12
 13202 00:3C3B: B7 26        	lda	[<L540+fp_0],Y
 13203 00:3C3D: 85 1F        	sta	<L541+ifptr_1
 13204 00:3C3F: A0 14 00     	ldy	#$14
 13205 00:3C42: B7 26        	lda	[<L540+fp_0],Y
 13206 00:3C44: 85 21        	sta	<L541+ifptr_1+2
 13207                        ;		fp->fptr = nsect = 0;
 13208 00:3C46: 64 1B        	stz	<L541+nsect_1
 13209 00:3C48: 64 1D        	stz	<L541+nsect_1+2
 13210 00:3C4A: A9 00 00     	lda	#$0
 13211 00:3C4D: A0 12 00     	ldy	#$12
 13212 00:3C50: 97 26        	sta	[<L540+fp_0],Y
 13213 00:3C52: A9 00 00     	lda	#$0
 13214 00:3C55: A0 14 00     	ldy	#$14
 13215 00:3C58: 97 26        	sta	[<L540+fp_0],Y
 13216                        ;		if (ofs > 0) {
 13217 00:3C5A: A9 00 00     	lda	#$0
 13218 00:3C5D: C5 2A        	cmp	<L540+ofs_0
 13219 00:3C5F: A9 00 00     	lda	#$0
 13220 00:3C62: E5 2C        	sbc	<L540+ofs_0+2
 13221 00:3C64: 90 03        	bcc	L548
  Thu May 20 2021 21:37                                                Page 267


 13222 00:3C66: 82 0E 03     	brl	L10292
 13223                        L548:
 13224                        ;			bcs = (DWORD)fs->csize * SS(fs);
                    	/* Cluster size (byte) */
 13225 00:3C69: A0 09 00     	ldy	#$9
 13226 00:3C6C: B7 0F        	lda	[<L541+fs_1],Y
 13227 00:3C6E: 85 01        	sta	<R0
 13228 00:3C70: 64 03        	stz	<R0+2
 13229 00:3C72: D4 03        	pei	<R0+2
 13230 00:3C74: D4 01        	pei	<R0
 13231 00:3C76: A9 09 00     	lda	#$9
 13232                        	xref	~~~lasl
 13233 00:3C79: 22 xx xx xx  	jsl	~~~lasl
 13234 00:3C7D: 85 17        	sta	<L541+bcs_1
 13235 00:3C7F: 86 19        	stx	<L541+bcs_1+2
 13236                        ;			if (ifptr > 0 &&
 13237                        ;				(ofs - 1) / bcs >= (ifpt
                    r - 1) / bcs) {	/* When seek to same or following cluste
                    r, */
 13238 00:3C81: A9 00 00     	lda	#$0
 13239 00:3C84: C5 1F        	cmp	<L541+ifptr_1
 13240 00:3C86: A9 00 00     	lda	#$0
 13241 00:3C89: E5 21        	sbc	<L541+ifptr_1+2
 13242 00:3C8B: 90 03        	bcc	L549
 13243 00:3C8D: 82 B5 00     	brl	L10293
 13244                        L549:
 13245 00:3C90: 18           	clc
 13246 00:3C91: A9 FF FF     	lda	#$ffff
 13247 00:3C94: 65 1F        	adc	<L541+ifptr_1
 13248 00:3C96: 85 01        	sta	<R0
 13249 00:3C98: A9 FF FF     	lda	#$ffff
 13250 00:3C9B: 65 21        	adc	<L541+ifptr_1+2
 13251 00:3C9D: 85 03        	sta	<R0+2
 13252 00:3C9F: D4 19        	pei	<L541+bcs_1+2
 13253 00:3CA1: D4 17        	pei	<L541+bcs_1
 13254 00:3CA3: D4 03        	pei	<R0+2
 13255 00:3CA5: D4 01        	pei	<R0
 13256                        	xref	~~~ludv
 13257 00:3CA7: 22 xx xx xx  	jsl	~~~ludv
 13258 00:3CAB: 85 01        	sta	<R0
 13259 00:3CAD: 86 03        	stx	<R0+2
 13260 00:3CAF: 18           	clc
 13261 00:3CB0: A9 FF FF     	lda	#$ffff
 13262 00:3CB3: 65 2A        	adc	<L540+ofs_0
 13263 00:3CB5: 85 05        	sta	<R1
 13264 00:3CB7: A9 FF FF     	lda	#$ffff
 13265 00:3CBA: 65 2C        	adc	<L540+ofs_0+2
 13266 00:3CBC: 85 07        	sta	<R1+2
 13267 00:3CBE: D4 19        	pei	<L541+bcs_1+2
 13268 00:3CC0: D4 17        	pei	<L541+bcs_1
 13269 00:3CC2: D4 07        	pei	<R1+2
 13270 00:3CC4: D4 05        	pei	<R1
 13271                        	xref	~~~ludv
 13272 00:3CC6: 22 xx xx xx  	jsl	~~~ludv
 13273 00:3CCA: 85 05        	sta	<R1
 13274 00:3CCC: 86 07        	stx	<R1+2
 13275 00:3CCE: A5 05        	lda	<R1
 13276 00:3CD0: C5 01        	cmp	<R0
  Thu May 20 2021 21:37                                                Page 268


 13277 00:3CD2: A5 07        	lda	<R1+2
 13278 00:3CD4: E5 03        	sbc	<R0+2
 13279 00:3CD6: B0 03        	bcs	L550
 13280 00:3CD8: 82 6A 00     	brl	L10293
 13281                        L550:
 13282                        ;				fp->fptr = (ifptr - 1) &
                     ~(FSIZE_t)(bcs - 1);	/* start from the current cluste
                    r */
 13283 00:3CDB: 18           	clc
 13284 00:3CDC: A9 FF FF     	lda	#$ffff
 13285 00:3CDF: 65 1F        	adc	<L541+ifptr_1
 13286 00:3CE1: 85 01        	sta	<R0
 13287 00:3CE3: A9 FF FF     	lda	#$ffff
 13288 00:3CE6: 65 21        	adc	<L541+ifptr_1+2
 13289 00:3CE8: 85 03        	sta	<R0+2
 13290 00:3CEA: 18           	clc
 13291 00:3CEB: A9 FF FF     	lda	#$ffff
 13292 00:3CEE: 65 17        	adc	<L541+bcs_1
 13293 00:3CF0: 85 05        	sta	<R1
 13294 00:3CF2: A9 FF FF     	lda	#$ffff
 13295 00:3CF5: 65 19        	adc	<L541+bcs_1+2
 13296 00:3CF7: 85 07        	sta	<R1+2
 13297 00:3CF9: A5 05        	lda	<R1
 13298 00:3CFB: 49 FF FF     	eor	#<$ffffffff
 13299 00:3CFE: 85 09        	sta	<R2
 13300 00:3D00: A5 07        	lda	<R1+2
 13301 00:3D02: 49 FF FF     	eor	#^$ffffffff
 13302 00:3D05: 85 0B        	sta	<R2+2
 13303 00:3D07: A5 09        	lda	<R2
 13304 00:3D09: 25 01        	and	<R0
 13305 00:3D0B: 85 05        	sta	<R1
 13306 00:3D0D: A5 0B        	lda	<R2+2
 13307 00:3D0F: 25 03        	and	<R0+2
 13308 00:3D11: 85 07        	sta	<R1+2
 13309 00:3D13: A5 05        	lda	<R1
 13310 00:3D15: A0 12 00     	ldy	#$12
 13311 00:3D18: 97 26        	sta	[<L540+fp_0],Y
 13312 00:3D1A: A5 07        	lda	<R1+2
 13313 00:3D1C: A0 14 00     	ldy	#$14
 13314 00:3D1F: 97 26        	sta	[<L540+fp_0],Y
 13315                        ;				ofs -= fp->fptr;
 13316 00:3D21: 38           	sec
 13317 00:3D22: A5 2A        	lda	<L540+ofs_0
 13318 00:3D24: A0 12 00     	ldy	#$12
 13319 00:3D27: F7 26        	sbc	[<L540+fp_0],Y
 13320 00:3D29: 85 2A        	sta	<L540+ofs_0
 13321 00:3D2B: A5 2C        	lda	<L540+ofs_0+2
 13322 00:3D2D: A0 14 00     	ldy	#$14
 13323 00:3D30: F7 26        	sbc	[<L540+fp_0],Y
 13324 00:3D32: 85 2C        	sta	<L540+ofs_0+2
 13325                        ;				clst = fp->clust;
 13326 00:3D34: A0 16 00     	ldy	#$16
 13327 00:3D37: B7 26        	lda	[<L540+fp_0],Y
 13328 00:3D39: 85 13        	sta	<L541+clst_1
 13329 00:3D3B: A0 18 00     	ldy	#$18
 13330 00:3D3E: B7 26        	lda	[<L540+fp_0],Y
 13331 00:3D40: 85 15        	sta	<L541+clst_1+2
 13332                        ;			} else {			
  Thu May 20 2021 21:37                                                Page 269


                    						/* When seek to 
                    back cluster, */
 13333 00:3D42: 82 89 00     	brl	L10294
 13334                        L10293:
 13335                        ;				clst = fp->obj.sclust;	
                    				/* start from the first cluster 
                    */
 13336 00:3D45: A0 08 00     	ldy	#$8
 13337 00:3D48: B7 26        	lda	[<L540+fp_0],Y
 13338 00:3D4A: 85 13        	sta	<L541+clst_1
 13339 00:3D4C: A0 0A 00     	ldy	#$a
 13340 00:3D4F: B7 26        	lda	[<L540+fp_0],Y
 13341 00:3D51: 85 15        	sta	<L541+clst_1+2
 13342                        ;#if !FF_FS_READONLY
 13343                        ;				if (clst == 0) {	
                    					/* If no cluster chain, 
                    create a new chain */
 13344 00:3D53: A5 13        	lda	<L541+clst_1
 13345 00:3D55: 05 15        	ora	<L541+clst_1+2
 13346 00:3D57: F0 03        	beq	L551
 13347 00:3D59: 82 64 00     	brl	L10295
 13348                        L551:
 13349                        ;					clst = create_ch
                    ain(&fp->obj, 0);
 13350 00:3D5C: F4 00 00     	pea	#^$0
 13351 00:3D5F: F4 00 00     	pea	#<$0
 13352 00:3D62: D4 28        	pei	<L540+fp_0+2
 13353 00:3D64: D4 26        	pei	<L540+fp_0
 13354 00:3D66: 22 xx xx xx  	jsl	~~create_chain
 13355 00:3D6A: 85 13        	sta	<L541+clst_1
 13356 00:3D6C: 86 15        	stx	<L541+clst_1+2
 13357                        ;					if (clst == 1) A
                    BORT(fs, FR_INT_ERR);
 13358 00:3D6E: A5 13        	lda	<L541+clst_1
 13359 00:3D70: C9 01 00     	cmp	#<$1
 13360 00:3D73: D0 05        	bne	L552
 13361 00:3D75: A5 15        	lda	<L541+clst_1+2
 13362 00:3D77: C9 00 00     	cmp	#^$1
 13363                        L552:
 13364 00:3D7A: F0 03        	beq	L553
 13365 00:3D7C: 82 11 00     	brl	L10296
 13366                        L553:
 13367 00:3D7F: E2 20        	sep	#$20
 13368                        	longa	off
 13369 00:3D81: A9 02        	lda	#$2
 13370 00:3D83: A0 11 00     	ldy	#$11
 13371 00:3D86: 97 26        	sta	[<L540+fp_0],Y
 13372 00:3D88: C2 20        	rep	#$20
 13373                        	longa	on
 13374 00:3D8A: A9 02 00     	lda	#$2
 13375 00:3D8D: 82 65 FE     	brl	L544
 13376                        L10296:
 13377                        ;					if (clst == 0xFF
                    FFFFFF) ABORT(fs, FR_DISK_ERR);
 13378 00:3D90: A5 13        	lda	<L541+clst_1
 13379 00:3D92: C9 FF FF     	cmp	#<$ffffffff
 13380 00:3D95: D0 05        	bne	L554
 13381 00:3D97: A5 15        	lda	<L541+clst_1+2
  Thu May 20 2021 21:37                                                Page 270


 13382 00:3D99: C9 FF FF     	cmp	#^$ffffffff
 13383                        L554:
 13384 00:3D9C: F0 03        	beq	L555
 13385 00:3D9E: 82 11 00     	brl	L10297
 13386                        L555:
 13387 00:3DA1: E2 20        	sep	#$20
 13388                        	longa	off
 13389 00:3DA3: A9 01        	lda	#$1
 13390 00:3DA5: A0 11 00     	ldy	#$11
 13391 00:3DA8: 97 26        	sta	[<L540+fp_0],Y
 13392 00:3DAA: C2 20        	rep	#$20
 13393                        	longa	on
 13394 00:3DAC: A9 01 00     	lda	#$1
 13395 00:3DAF: 82 43 FE     	brl	L544
 13396                        L10297:
 13397                        ;					fp->obj.sclust =
                     clst;
 13398 00:3DB2: A5 13        	lda	<L541+clst_1
 13399 00:3DB4: A0 08 00     	ldy	#$8
 13400 00:3DB7: 97 26        	sta	[<L540+fp_0],Y
 13401 00:3DB9: A5 15        	lda	<L541+clst_1+2
 13402 00:3DBB: A0 0A 00     	ldy	#$a
 13403 00:3DBE: 97 26        	sta	[<L540+fp_0],Y
 13404                        ;				}
 13405                        ;#endif
 13406                        ;				fp->clust = clst;
 13407                        L10295:
 13408 00:3DC0: A5 13        	lda	<L541+clst_1
 13409 00:3DC2: A0 16 00     	ldy	#$16
 13410 00:3DC5: 97 26        	sta	[<L540+fp_0],Y
 13411 00:3DC7: A5 15        	lda	<L541+clst_1+2
 13412 00:3DC9: A0 18 00     	ldy	#$18
 13413 00:3DCC: 97 26        	sta	[<L540+fp_0],Y
 13414                        ;			}
 13415                        L10294:
 13416                        ;			if (clst != 0) {
 13417 00:3DCE: A5 13        	lda	<L541+clst_1
 13418 00:3DD0: 05 15        	ora	<L541+clst_1+2
 13419 00:3DD2: D0 03        	bne	L556
 13420 00:3DD4: 82 A0 01     	brl	L10298
 13421                        L556:
 13422                        ;				while (ofs > bcs) {	
                    					/* Cluster following loo
                    p */
 13423                        L10299:
 13424 00:3DD7: A5 17        	lda	<L541+bcs_1
 13425 00:3DD9: C5 2A        	cmp	<L540+ofs_0
 13426 00:3DDB: A5 19        	lda	<L541+bcs_1+2
 13427 00:3DDD: E5 2C        	sbc	<L540+ofs_0+2
 13428 00:3DDF: 90 03        	bcc	L557
 13429 00:3DE1: 82 21 01     	brl	L10300
 13430                        L557:
 13431                        ;					ofs -= bcs; fp->
                    fptr += bcs;
 13432 00:3DE4: 38           	sec
 13433 00:3DE5: A5 2A        	lda	<L540+ofs_0
 13434 00:3DE7: E5 17        	sbc	<L541+bcs_1
 13435 00:3DE9: 85 2A        	sta	<L540+ofs_0
  Thu May 20 2021 21:37                                                Page 271


 13436 00:3DEB: A5 2C        	lda	<L540+ofs_0+2
 13437 00:3DED: E5 19        	sbc	<L541+bcs_1+2
 13438 00:3DEF: 85 2C        	sta	<L540+ofs_0+2
 13439 00:3DF1: 18           	clc
 13440 00:3DF2: A9 12 00     	lda	#$12
 13441 00:3DF5: 65 26        	adc	<L540+fp_0
 13442 00:3DF7: 85 01        	sta	<R0
 13443 00:3DF9: A9 00 00     	lda	#$0
 13444 00:3DFC: 65 28        	adc	<L540+fp_0+2
 13445 00:3DFE: 85 03        	sta	<R0+2
 13446 00:3E00: 18           	clc
 13447 00:3E01: A7 01        	lda	[<R0]
 13448 00:3E03: 65 17        	adc	<L541+bcs_1
 13449 00:3E05: 87 01        	sta	[<R0]
 13450 00:3E07: A0 02 00     	ldy	#$2
 13451 00:3E0A: B7 01        	lda	[<R0],Y
 13452 00:3E0C: 65 19        	adc	<L541+bcs_1+2
 13453 00:3E0E: A0 02 00     	ldy	#$2
 13454 00:3E11: 97 01        	sta	[<R0],Y
 13455                        ;#if !FF_FS_READONLY
 13456                        ;					if (fp->flag & F
                    A_WRITE) {			/* Check if in write mode or not
                     */
 13457 00:3E13: E2 20        	sep	#$20
 13458                        	longa	off
 13459 00:3E15: A0 10 00     	ldy	#$10
 13460 00:3E18: B7 26        	lda	[<L540+fp_0],Y
 13461 00:3E1A: 29 02        	and	#<$2
 13462 00:3E1C: C2 20        	rep	#$20
 13463                        	longa	on
 13464 00:3E1E: D0 03        	bne	L558
 13465 00:3E20: 82 6C 00     	brl	L10301
 13466                        L558:
 13467                        ;						if (FF_F
                    S_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain 
                    object needs correct objsize to generate FAT value */
 13468 00:3E23: 82 46 00     	brl	L10302
 13469 00:3E26: A0 0C 00     	ldy	#$c
 13470 00:3E29: B7 26        	lda	[<L540+fp_0],Y
 13471 00:3E2B: A0 12 00     	ldy	#$12
 13472 00:3E2E: D7 26        	cmp	[<L540+fp_0],Y
 13473 00:3E30: A0 0E 00     	ldy	#$e
 13474 00:3E33: B7 26        	lda	[<L540+fp_0],Y
 13475 00:3E35: A0 14 00     	ldy	#$14
 13476 00:3E38: F7 26        	sbc	[<L540+fp_0],Y
 13477 00:3E3A: 90 03        	bcc	L559
 13478 00:3E3C: 82 2D 00     	brl	L10302
 13479                        L559:
 13480                        ;							
                    fp->obj.objsize = fp->fptr;
 13481 00:3E3F: A0 12 00     	ldy	#$12
 13482 00:3E42: B7 26        	lda	[<L540+fp_0],Y
 13483 00:3E44: A0 0C 00     	ldy	#$c
 13484 00:3E47: 97 26        	sta	[<L540+fp_0],Y
 13485 00:3E49: A0 14 00     	ldy	#$14
 13486 00:3E4C: B7 26        	lda	[<L540+fp_0],Y
 13487 00:3E4E: A0 0E 00     	ldy	#$e
 13488 00:3E51: 97 26        	sta	[<L540+fp_0],Y
  Thu May 20 2021 21:37                                                Page 272


 13489                        ;							
                    fp->flag |= FA_MODIFIED;
 13490 00:3E53: 18           	clc
 13491 00:3E54: A9 10 00     	lda	#$10
 13492 00:3E57: 65 26        	adc	<L540+fp_0
 13493 00:3E59: 85 01        	sta	<R0
 13494 00:3E5B: A9 00 00     	lda	#$0
 13495 00:3E5E: 65 28        	adc	<L540+fp_0+2
 13496 00:3E60: 85 03        	sta	<R0+2
 13497 00:3E62: E2 20        	sep	#$20
 13498                        	longa	off
 13499 00:3E64: A7 01        	lda	[<R0]
 13500 00:3E66: 09 40        	ora	#<$40
 13501 00:3E68: 87 01        	sta	[<R0]
 13502 00:3E6A: C2 20        	rep	#$20
 13503                        	longa	on
 13504                        ;						}
 13505                        ;						clst = c
                    reate_chain(&fp->obj, clst);	/* Follow chain with for
                    ceed stretch */
 13506                        L10302:
 13507 00:3E6C: D4 15        	pei	<L541+clst_1+2
 13508 00:3E6E: D4 13        	pei	<L541+clst_1
 13509 00:3E70: D4 28        	pei	<L540+fp_0+2
 13510 00:3E72: D4 26        	pei	<L540+fp_0
 13511 00:3E74: 22 xx xx xx  	jsl	~~create_chain
 13512 00:3E78: 85 13        	sta	<L541+clst_1
 13513 00:3E7A: 86 15        	stx	<L541+clst_1+2
 13514                        ;						if (clst
                     == 0) {				/* Clip file size in cas
                    e of disk full */
 13515 00:3E7C: A5 13        	lda	<L541+clst_1
 13516 00:3E7E: 05 15        	ora	<L541+clst_1+2
 13517 00:3E80: F0 03        	beq	L560
 13518 00:3E82: 82 07 00     	brl	L10303
 13519                        L560:
 13520                        ;							
                    ofs = 0; break;
 13521 00:3E85: 64 2A        	stz	<L540+ofs_0
 13522 00:3E87: 64 2C        	stz	<L540+ofs_0+2
 13523 00:3E89: 82 79 00     	brl	L10300
 13524                        ;						}
 13525                        ;					} else
 13526                        L10303:
 13527 00:3E8C: 82 10 00     	brl	L10304
 13528                        L10301:
 13529                        ;#endif
 13530                        ;					{
 13531                        ;						clst = g
                    et_fat(&fp->obj, clst);	/* Follow cluster chain if not i
                    n write mode */
 13532 00:3E8F: D4 15        	pei	<L541+clst_1+2
 13533 00:3E91: D4 13        	pei	<L541+clst_1
 13534 00:3E93: D4 28        	pei	<L540+fp_0+2
 13535 00:3E95: D4 26        	pei	<L540+fp_0
 13536 00:3E97: 22 xx xx xx  	jsl	~~get_fat
 13537 00:3E9B: 85 13        	sta	<L541+clst_1
 13538 00:3E9D: 86 15        	stx	<L541+clst_1+2
  Thu May 20 2021 21:37                                                Page 273


 13539                        ;					}
 13540                        L10304:
 13541                        ;					if (clst == 0xFF
                    FFFFFF) ABORT(fs, FR_DISK_ERR);
 13542 00:3E9F: A5 13        	lda	<L541+clst_1
 13543 00:3EA1: C9 FF FF     	cmp	#<$ffffffff
 13544 00:3EA4: D0 05        	bne	L561
 13545 00:3EA6: A5 15        	lda	<L541+clst_1+2
 13546 00:3EA8: C9 FF FF     	cmp	#^$ffffffff
 13547                        L561:
 13548 00:3EAB: F0 03        	beq	L562
 13549 00:3EAD: 82 11 00     	brl	L10305
 13550                        L562:
 13551 00:3EB0: E2 20        	sep	#$20
 13552                        	longa	off
 13553 00:3EB2: A9 01        	lda	#$1
 13554 00:3EB4: A0 11 00     	ldy	#$11
 13555 00:3EB7: 97 26        	sta	[<L540+fp_0],Y
 13556 00:3EB9: C2 20        	rep	#$20
 13557                        	longa	on
 13558 00:3EBB: A9 01 00     	lda	#$1
 13559 00:3EBE: 82 34 FD     	brl	L544
 13560                        L10305:
 13561                        ;					if (clst <= 1 ||
                     clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 13562 00:3EC1: A9 01 00     	lda	#$1
 13563 00:3EC4: C5 13        	cmp	<L541+clst_1
 13564 00:3EC6: A9 00 00     	lda	#$0
 13565 00:3EC9: E5 15        	sbc	<L541+clst_1+2
 13566 00:3ECB: 90 03        	bcc	L564
 13567 00:3ECD: 82 13 00     	brl	L563
 13568                        L564:
 13569 00:3ED0: A5 13        	lda	<L541+clst_1
 13570 00:3ED2: A0 13 00     	ldy	#$13
 13571 00:3ED5: D7 0F        	cmp	[<L541+fs_1],Y
 13572 00:3ED7: A5 15        	lda	<L541+clst_1+2
 13573 00:3ED9: A0 15 00     	ldy	#$15
 13574 00:3EDC: F7 0F        	sbc	[<L541+fs_1],Y
 13575 00:3EDE: B0 03        	bcs	L565
 13576 00:3EE0: 82 11 00     	brl	L10306
 13577                        L565:
 13578                        L563:
 13579 00:3EE3: E2 20        	sep	#$20
 13580                        	longa	off
 13581 00:3EE5: A9 02        	lda	#$2
 13582 00:3EE7: A0 11 00     	ldy	#$11
 13583 00:3EEA: 97 26        	sta	[<L540+fp_0],Y
 13584 00:3EEC: C2 20        	rep	#$20
 13585                        	longa	on
 13586 00:3EEE: A9 02 00     	lda	#$2
 13587 00:3EF1: 82 01 FD     	brl	L544
 13588                        L10306:
 13589                        ;					fp->clust = clst
                    ;
 13590 00:3EF4: A5 13        	lda	<L541+clst_1
 13591 00:3EF6: A0 16 00     	ldy	#$16
 13592 00:3EF9: 97 26        	sta	[<L540+fp_0],Y
 13593 00:3EFB: A5 15        	lda	<L541+clst_1+2
  Thu May 20 2021 21:37                                                Page 274


 13594 00:3EFD: A0 18 00     	ldy	#$18
 13595 00:3F00: 97 26        	sta	[<L540+fp_0],Y
 13596                        ;				}
 13597 00:3F02: 82 D2 FE     	brl	L10299
 13598                        L10300:
 13599                        ;				fp->fptr += ofs;
 13600 00:3F05: 18           	clc
 13601 00:3F06: A9 12 00     	lda	#$12
 13602 00:3F09: 65 26        	adc	<L540+fp_0
 13603 00:3F0B: 85 01        	sta	<R0
 13604 00:3F0D: A9 00 00     	lda	#$0
 13605 00:3F10: 65 28        	adc	<L540+fp_0+2
 13606 00:3F12: 85 03        	sta	<R0+2
 13607 00:3F14: 18           	clc
 13608 00:3F15: A7 01        	lda	[<R0]
 13609 00:3F17: 65 2A        	adc	<L540+ofs_0
 13610 00:3F19: 87 01        	sta	[<R0]
 13611 00:3F1B: A0 02 00     	ldy	#$2
 13612 00:3F1E: B7 01        	lda	[<R0],Y
 13613 00:3F20: 65 2C        	adc	<L540+ofs_0+2
 13614 00:3F22: A0 02 00     	ldy	#$2
 13615 00:3F25: 97 01        	sta	[<R0],Y
 13616                        ;				if (ofs % SS(fs)) {
 13617 00:3F27: A5 2A        	lda	<L540+ofs_0
 13618 00:3F29: 29 FF 01     	and	#<$1ff
 13619 00:3F2C: D0 03        	bne	L566
 13620 00:3F2E: 82 46 00     	brl	L10307
 13621                        L566:
 13622                        ;					nsect = clst2sec
                    t(fs, clst);	/* Current sector */
 13623 00:3F31: D4 15        	pei	<L541+clst_1+2
 13624 00:3F33: D4 13        	pei	<L541+clst_1
 13625 00:3F35: D4 11        	pei	<L541+fs_1+2
 13626 00:3F37: D4 0F        	pei	<L541+fs_1
 13627 00:3F39: 22 xx xx xx  	jsl	~~clst2sect
 13628 00:3F3D: 85 1B        	sta	<L541+nsect_1
 13629 00:3F3F: 86 1D        	stx	<L541+nsect_1+2
 13630                        ;					if (nsect == 0) 
                    ABORT(fs, FR_INT_ERR);
 13631 00:3F41: A5 1B        	lda	<L541+nsect_1
 13632 00:3F43: 05 1D        	ora	<L541+nsect_1+2
 13633 00:3F45: F0 03        	beq	L567
 13634 00:3F47: 82 11 00     	brl	L10308
 13635                        L567:
 13636 00:3F4A: E2 20        	sep	#$20
 13637                        	longa	off
 13638 00:3F4C: A9 02        	lda	#$2
 13639 00:3F4E: A0 11 00     	ldy	#$11
 13640 00:3F51: 97 26        	sta	[<L540+fp_0],Y
 13641 00:3F53: C2 20        	rep	#$20
 13642                        	longa	on
 13643 00:3F55: A9 02 00     	lda	#$2
 13644 00:3F58: 82 9A FC     	brl	L544
 13645                        L10308:
 13646                        ;					nsect += (DWORD)
                    (ofs / SS(fs));
 13647 00:3F5B: D4 2C        	pei	<L540+ofs_0+2
 13648 00:3F5D: D4 2A        	pei	<L540+ofs_0
  Thu May 20 2021 21:37                                                Page 275


 13649 00:3F5F: A9 09 00     	lda	#$9
 13650                        	xref	~~~llsr
 13651 00:3F62: 22 xx xx xx  	jsl	~~~llsr
 13652 00:3F66: 85 01        	sta	<R0
 13653 00:3F68: 86 03        	stx	<R0+2
 13654 00:3F6A: 18           	clc
 13655 00:3F6B: A5 01        	lda	<R0
 13656 00:3F6D: 65 1B        	adc	<L541+nsect_1
 13657 00:3F6F: 85 1B        	sta	<L541+nsect_1
 13658 00:3F71: A5 03        	lda	<R0+2
 13659 00:3F73: 65 1D        	adc	<L541+nsect_1+2
 13660 00:3F75: 85 1D        	sta	<L541+nsect_1+2
 13661                        ;				}
 13662                        ;			}
 13663                        L10307:
 13664                        ;		}
 13665                        L10298:
 13666                        ;		if (!FF_FS_READONLY && fp->fptr > fp->ob
                    j.objsize) {	/* Set file change flag if the file size
                     is extended */
 13667                        L10292:
 13668 00:3F77: A0 0C 00     	ldy	#$c
 13669 00:3F7A: B7 26        	lda	[<L540+fp_0],Y
 13670 00:3F7C: A0 12 00     	ldy	#$12
 13671 00:3F7F: D7 26        	cmp	[<L540+fp_0],Y
 13672 00:3F81: A0 0E 00     	ldy	#$e
 13673 00:3F84: B7 26        	lda	[<L540+fp_0],Y
 13674 00:3F86: A0 14 00     	ldy	#$14
 13675 00:3F89: F7 26        	sbc	[<L540+fp_0],Y
 13676 00:3F8B: 90 03        	bcc	L568
 13677 00:3F8D: 82 2D 00     	brl	L10309
 13678                        L568:
 13679                        ;			fp->obj.objsize = fp->fptr;
 13680 00:3F90: A0 12 00     	ldy	#$12
 13681 00:3F93: B7 26        	lda	[<L540+fp_0],Y
 13682 00:3F95: A0 0C 00     	ldy	#$c
 13683 00:3F98: 97 26        	sta	[<L540+fp_0],Y
 13684 00:3F9A: A0 14 00     	ldy	#$14
 13685 00:3F9D: B7 26        	lda	[<L540+fp_0],Y
 13686 00:3F9F: A0 0E 00     	ldy	#$e
 13687 00:3FA2: 97 26        	sta	[<L540+fp_0],Y
 13688                        ;			fp->flag |= FA_MODIFIED;
 13689 00:3FA4: 18           	clc
 13690 00:3FA5: A9 10 00     	lda	#$10
 13691 00:3FA8: 65 26        	adc	<L540+fp_0
 13692 00:3FAA: 85 01        	sta	<R0
 13693 00:3FAC: A9 00 00     	lda	#$0
 13694 00:3FAF: 65 28        	adc	<L540+fp_0+2
 13695 00:3FB1: 85 03        	sta	<R0+2
 13696 00:3FB3: E2 20        	sep	#$20
 13697                        	longa	off
 13698 00:3FB5: A7 01        	lda	[<R0]
 13699 00:3FB7: 09 40        	ora	#<$40
 13700 00:3FB9: 87 01        	sta	[<R0]
 13701 00:3FBB: C2 20        	rep	#$20
 13702                        	longa	on
 13703                        ;		}
 13704                        ;		if (fp->fptr % SS(fs) && nsect != fp->se
  Thu May 20 2021 21:37                                                Page 276


                    ct) {	/* Fill sector cache if needed */
 13705                        L10309:
 13706 00:3FBD: A0 12 00     	ldy	#$12
 13707 00:3FC0: B7 26        	lda	[<L540+fp_0],Y
 13708 00:3FC2: 29 FF 01     	and	#<$1ff
 13709 00:3FC5: D0 03        	bne	L569
 13710 00:3FC7: 82 CA 00     	brl	L10310
 13711                        L569:
 13712 00:3FCA: A5 1B        	lda	<L541+nsect_1
 13713 00:3FCC: A0 1A 00     	ldy	#$1a
 13714 00:3FCF: D7 26        	cmp	[<L540+fp_0],Y
 13715 00:3FD1: D0 07        	bne	L570
 13716 00:3FD3: A5 1D        	lda	<L541+nsect_1+2
 13717 00:3FD5: A0 1C 00     	ldy	#$1c
 13718 00:3FD8: D7 26        	cmp	[<L540+fp_0],Y
 13719                        L570:
 13720 00:3FDA: D0 03        	bne	L571
 13721 00:3FDC: 82 B5 00     	brl	L10310
 13722                        L571:
 13723                        ;#if !FF_FS_TINY
 13724                        ;#if !FF_FS_READONLY
 13725                        ;			if (fp->flag & FA_DIRTY) {	
                    		/* Write-back dirty sector cache */
 13726 00:3FDF: E2 20        	sep	#$20
 13727                        	longa	off
 13728 00:3FE1: A0 10 00     	ldy	#$10
 13729 00:3FE4: B7 26        	lda	[<L540+fp_0],Y
 13730 00:3FE6: 29 80        	and	#<$80
 13731 00:3FE8: C2 20        	rep	#$20
 13732                        	longa	on
 13733 00:3FEA: D0 03        	bne	L572
 13734 00:3FEC: 82 5C 00     	brl	L10311
 13735                        L572:
 13736                        ;				if (disk_write(fs->pdrv,
                     fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 13737 00:3FEF: F4 01 00     	pea	#<$1
 13738 00:3FF2: A0 1C 00     	ldy	#$1c
 13739 00:3FF5: B7 26        	lda	[<L540+fp_0],Y
 13740 00:3FF7: 48           	pha
 13741 00:3FF8: A0 1A 00     	ldy	#$1a
 13742 00:3FFB: B7 26        	lda	[<L540+fp_0],Y
 13743 00:3FFD: 48           	pha
 13744 00:3FFE: 18           	clc
 13745 00:3FFF: A9 26 00     	lda	#$26
 13746 00:4002: 65 26        	adc	<L540+fp_0
 13747 00:4004: 85 01        	sta	<R0
 13748 00:4006: A9 00 00     	lda	#$0
 13749 00:4009: 65 28        	adc	<L540+fp_0+2
 13750 00:400B: 85 03        	sta	<R0+2
 13751 00:400D: D4 03        	pei	<R0+2
 13752 00:400F: D4 01        	pei	<R0
 13753 00:4011: A0 01 00     	ldy	#$1
 13754 00:4014: B7 0F        	lda	[<L541+fs_1],Y
 13755 00:4016: 48           	pha
 13756 00:4017: 22 xx xx xx  	jsl	~~disk_write
 13757 00:401B: AA           	tax
 13758 00:401C: D0 03        	bne	L573
 13759 00:401E: 82 11 00     	brl	L10312
  Thu May 20 2021 21:37                                                Page 277


 13760                        L573:
 13761 00:4021: E2 20        	sep	#$20
 13762                        	longa	off
 13763 00:4023: A9 01        	lda	#$1
 13764 00:4025: A0 11 00     	ldy	#$11
 13765 00:4028: 97 26        	sta	[<L540+fp_0],Y
 13766 00:402A: C2 20        	rep	#$20
 13767                        	longa	on
 13768 00:402C: A9 01 00     	lda	#$1
 13769 00:402F: 82 C3 FB     	brl	L544
 13770                        L10312:
 13771                        ;				fp->flag &= (BYTE)~FA_DI
                    RTY;
 13772 00:4032: 18           	clc
 13773 00:4033: A9 10 00     	lda	#$10
 13774 00:4036: 65 26        	adc	<L540+fp_0
 13775 00:4038: 85 01        	sta	<R0
 13776 00:403A: A9 00 00     	lda	#$0
 13777 00:403D: 65 28        	adc	<L540+fp_0+2
 13778 00:403F: 85 03        	sta	<R0+2
 13779 00:4041: E2 20        	sep	#$20
 13780                        	longa	off
 13781 00:4043: A7 01        	lda	[<R0]
 13782 00:4045: 29 7F        	and	#<$7f
 13783 00:4047: 87 01        	sta	[<R0]
 13784 00:4049: C2 20        	rep	#$20
 13785                        	longa	on
 13786                        ;			}
 13787                        ;#endif
 13788                        ;			if (disk_read(fs->pdrv, fp->buf,
                     nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill 
                    sector cache */
 13789                        L10311:
 13790 00:404B: F4 01 00     	pea	#<$1
 13791 00:404E: D4 1D        	pei	<L541+nsect_1+2
 13792 00:4050: D4 1B        	pei	<L541+nsect_1
 13793 00:4052: 18           	clc
 13794 00:4053: A9 26 00     	lda	#$26
 13795 00:4056: 65 26        	adc	<L540+fp_0
 13796 00:4058: 85 01        	sta	<R0
 13797 00:405A: A9 00 00     	lda	#$0
 13798 00:405D: 65 28        	adc	<L540+fp_0+2
 13799 00:405F: 85 03        	sta	<R0+2
 13800 00:4061: D4 03        	pei	<R0+2
 13801 00:4063: D4 01        	pei	<R0
 13802 00:4065: A0 01 00     	ldy	#$1
 13803 00:4068: B7 0F        	lda	[<L541+fs_1],Y
 13804 00:406A: 48           	pha
 13805 00:406B: 22 xx xx xx  	jsl	~~disk_read
 13806 00:406F: AA           	tax
 13807 00:4070: D0 03        	bne	L574
 13808 00:4072: 82 11 00     	brl	L10313
 13809                        L574:
 13810 00:4075: E2 20        	sep	#$20
 13811                        	longa	off
 13812 00:4077: A9 01        	lda	#$1
 13813 00:4079: A0 11 00     	ldy	#$11
 13814 00:407C: 97 26        	sta	[<L540+fp_0],Y
  Thu May 20 2021 21:37                                                Page 278


 13815 00:407E: C2 20        	rep	#$20
 13816                        	longa	on
 13817 00:4080: A9 01 00     	lda	#$1
 13818 00:4083: 82 6F FB     	brl	L544
 13819                        L10313:
 13820                        ;#endif
 13821                        ;			fp->sect = nsect;
 13822 00:4086: A5 1B        	lda	<L541+nsect_1
 13823 00:4088: A0 1A 00     	ldy	#$1a
 13824 00:408B: 97 26        	sta	[<L540+fp_0],Y
 13825 00:408D: A5 1D        	lda	<L541+nsect_1+2
 13826 00:408F: A0 1C 00     	ldy	#$1c
 13827 00:4092: 97 26        	sta	[<L540+fp_0],Y
 13828                        ;		}
 13829                        ;	}
 13830                        L10310:
 13831                        ;
 13832                        ;	LEAVE_FF(fs, res);
 13833 00:4094: A5 0D        	lda	<L541+res_1
 13834 00:4096: 82 5C FB     	brl	L544
 13835                        ;}
 13836             00000022   L540	equ	34
 13837             0000000D   L541	equ	13
 13838                        	ends
 13839                        	efunc
 13840                        ;
 13841                        ;
 13842                        ;
 13843                        ;#if FF_FS_MINIMIZE <= 1
 13844                        ;/*-----------------------------------------------
                    ------------------------*/
 13845                        ;/* Create a Directory Object                     
                                            */
 13846                        ;/*-----------------------------------------------
                    ------------------------*/
 13847                        ;
 13848                        ;FRESULT f_opendir (
 13849                        ;	DIR* dp,			/* Pointer to di
                    rectory object to create */
 13850                        ;	const TCHAR* path	/* Pointer to the direct
                    ory path */
 13851                        ;)
 13852                        ;{
 13853                        	code
 13854                        	xdef	~~f_opendir
 13855                        	func
 13856                        ~~f_opendir:
 13857                        	longa	on
 13858                        	longi	on
 13859 00:4099: 3B           	tsc
 13860 00:409A: 38           	sec
 13861 00:409B: E9 0A 00     	sbc	#L575
 13862 00:409E: 1B           	tcs
 13863 00:409F: 0B           	phd
 13864 00:40A0: 5B           	tcd
 13865             00000004   dp_0	set	4
 13866             00000008   path_0	set	8
 13867                        ;	FRESULT res;
  Thu May 20 2021 21:37                                                Page 279


 13868                        ;	FATFS *fs;
 13869                        ;	DEF_NAMBUF
 13870                        ;
 13871                        ;
 13872                        ;	if (!dp) return FR_INVALID_OBJECT;
 13873             00000000   res_1	set	0
 13874             00000002   fs_1	set	2
 13875 00:40A1: A5 0E        	lda	<L575+dp_0
 13876 00:40A3: 05 10        	ora	<L575+dp_0+2
 13877 00:40A5: F0 03        	beq	L577
 13878 00:40A7: 82 15 00     	brl	L10314
 13879                        L577:
 13880 00:40AA: A9 09 00     	lda	#$9
 13881                        L578:
 13882 00:40AD: A8           	tay
 13883 00:40AE: A5 0C        	lda	<L575+2
 13884 00:40B0: 85 14        	sta	<L575+2+8
 13885 00:40B2: A5 0B        	lda	<L575+1
 13886 00:40B4: 85 13        	sta	<L575+1+8
 13887 00:40B6: 2B           	pld
 13888 00:40B7: 3B           	tsc
 13889 00:40B8: 18           	clc
 13890 00:40B9: 69 12 00     	adc	#L575+8
 13891 00:40BC: 1B           	tcs
 13892 00:40BD: 98           	tya
 13893 00:40BE: 6B           	rtl
 13894                        ;
 13895                        ;	/* Get logical drive */
 13896                        ;	res = mount_volume(&path, &fs, 0);
 13897                        L10314:
 13898 00:40BF: F4 00 00     	pea	#<$0
 13899 00:40C2: F4 00 00     	pea	#0
 13900 00:40C5: 18           	clc
 13901 00:40C6: 7B           	tdc
 13902 00:40C7: 69 07 00     	adc	#<L576+fs_1
 13903 00:40CA: 48           	pha
 13904 00:40CB: F4 00 00     	pea	#0
 13905 00:40CE: 18           	clc
 13906 00:40CF: 7B           	tdc
 13907 00:40D0: 69 12 00     	adc	#<L575+path_0
 13908 00:40D3: 48           	pha
 13909 00:40D4: 22 xx xx xx  	jsl	~~mount_volume
 13910 00:40D8: 85 05        	sta	<L576+res_1
 13911                        ;	if (res == FR_OK) {
 13912 00:40DA: A5 05        	lda	<L576+res_1
 13913 00:40DC: F0 03        	beq	L579
 13914 00:40DE: 82 9E 00     	brl	L10315
 13915                        L579:
 13916                        ;		dp->obj.fs = fs;
 13917 00:40E1: A5 07        	lda	<L576+fs_1
 13918 00:40E3: 87 0E        	sta	[<L575+dp_0]
 13919 00:40E5: A5 09        	lda	<L576+fs_1+2
 13920 00:40E7: A0 02 00     	ldy	#$2
 13921 00:40EA: 97 0E        	sta	[<L575+dp_0],Y
 13922                        ;		INIT_NAMBUF(fs);
 13923                        ;		res = follow_path(dp, path);		
                    	/* Follow the path to the directory */
 13924 00:40EC: D4 14        	pei	<L575+path_0+2
  Thu May 20 2021 21:37                                                Page 280


 13925 00:40EE: D4 12        	pei	<L575+path_0
 13926 00:40F0: D4 10        	pei	<L575+dp_0+2
 13927 00:40F2: D4 0E        	pei	<L575+dp_0
 13928 00:40F4: 22 xx xx xx  	jsl	~~follow_path
 13929 00:40F8: 85 05        	sta	<L576+res_1
 13930                        ;		if (res == FR_OK) {			
                    			/* Follow completed */
 13931 00:40FA: A5 05        	lda	<L576+res_1
 13932 00:40FC: F0 03        	beq	L580
 13933 00:40FE: 82 6F 00     	brl	L10316
 13934                        L580:
 13935                        ;			if (!(dp->fn[NSFLAG] & NS_NONAME
                    )) {	/* It is not the origin directory itself */
 13936 00:4101: E2 20        	sep	#$20
 13937                        	longa	off
 13938 00:4103: A0 2B 00     	ldy	#$2b
 13939 00:4106: B7 0E        	lda	[<L575+dp_0],Y
 13940 00:4108: 29 80        	and	#<$80
 13941 00:410A: C2 20        	rep	#$20
 13942                        	longa	on
 13943 00:410C: F0 03        	beq	L581
 13944 00:410E: 82 3E 00     	brl	L10317
 13945                        L581:
 13946                        ;				if (dp->obj.attr & AM_DI
                    R) {		/* This object is a sub-directory */
 13947 00:4111: E2 20        	sep	#$20
 13948                        	longa	off
 13949 00:4113: A0 06 00     	ldy	#$6
 13950 00:4116: B7 0E        	lda	[<L575+dp_0],Y
 13951 00:4118: 29 10        	and	#<$10
 13952 00:411A: C2 20        	rep	#$20
 13953                        	longa	on
 13954 00:411C: D0 03        	bne	L582
 13955 00:411E: 82 29 00     	brl	L10318
 13956                        L582:
 13957                        ;#if FF_FS_EXFAT
 13958                        ;					if (fs->fs_type 
                    == FS_EXFAT) {
 13959                        ;						dp->obj.
                    c_scl = dp->obj.sclust;					
                    		/* Get containing directory inforamation */
 13960                        ;						dp->obj.
                    c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.sta
                    t;
 13961                        ;						dp->obj.
                    c_ofs = dp->blk_ofs;
 13962                        ;						init_all
                    oc_info(fs, &dp->obj);	/* Get object allocation info */
 13963                        ;					} else
 13964                        ;#endif
 13965                        ;					{
 13966                        ;						dp->obj.
                    sclust = ld_clust(fs, dp->dir);	/* Get object allocation
                     info */
 13967 00:4121: A0 1E 00     	ldy	#$1e
 13968 00:4124: B7 0E        	lda	[<L575+dp_0],Y
 13969 00:4126: 48           	pha
 13970 00:4127: A0 1C 00     	ldy	#$1c
  Thu May 20 2021 21:37                                                Page 281


 13971 00:412A: B7 0E        	lda	[<L575+dp_0],Y
 13972 00:412C: 48           	pha
 13973 00:412D: D4 09        	pei	<L576+fs_1+2
 13974 00:412F: D4 07        	pei	<L576+fs_1
 13975 00:4131: 22 xx xx xx  	jsl	~~ld_clust
 13976 00:4135: 85 01        	sta	<R0
 13977 00:4137: 86 03        	stx	<R0+2
 13978 00:4139: A5 01        	lda	<R0
 13979 00:413B: A0 08 00     	ldy	#$8
 13980 00:413E: 97 0E        	sta	[<L575+dp_0],Y
 13981 00:4140: A5 03        	lda	<R0+2
 13982 00:4142: A0 0A 00     	ldy	#$a
 13983 00:4145: 97 0E        	sta	[<L575+dp_0],Y
 13984                        ;					}
 13985                        ;				} else {		
                    				/* This object is a file */
 13986 00:4147: 82 05 00     	brl	L10319
 13987                        L10318:
 13988                        ;					res = FR_NO_PATH
                    ;
 13989 00:414A: A9 05 00     	lda	#$5
 13990 00:414D: 85 05        	sta	<L576+res_1
 13991                        ;				}
 13992                        L10319:
 13993                        ;			}
 13994                        ;			if (res == FR_OK) {
 13995                        L10317:
 13996 00:414F: A5 05        	lda	<L576+res_1
 13997 00:4151: F0 03        	beq	L583
 13998 00:4153: 82 1A 00     	brl	L10320
 13999                        L583:
 14000                        ;				dp->obj.id = fs->id;
 14001 00:4156: A0 05 00     	ldy	#$5
 14002 00:4159: B7 07        	lda	[<L576+fs_1],Y
 14003 00:415B: A0 04 00     	ldy	#$4
 14004 00:415E: 97 0E        	sta	[<L575+dp_0],Y
 14005                        ;				res = dir_sdi(dp, 0);	
                    		/* Rewind directory */
 14006 00:4160: F4 00 00     	pea	#^$0
 14007 00:4163: F4 00 00     	pea	#<$0
 14008 00:4166: D4 10        	pei	<L575+dp_0+2
 14009 00:4168: D4 0E        	pei	<L575+dp_0
 14010 00:416A: 22 xx xx xx  	jsl	~~dir_sdi
 14011 00:416E: 85 05        	sta	<L576+res_1
 14012                        ;#if FF_FS_LOCK != 0
 14013                        ;				if (res == FR_OK) {
 14014                        ;					if (dp->obj.sclu
                    st != 0) {
 14015                        ;						dp->obj.
                    lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 14016                        ;						if (!dp-
                    >obj.lockid) res = FR_TOO_MANY_OPEN_FILES;
 14017                        ;					} else {
 14018                        ;						dp->obj.
                    lockid = 0;	/* Root directory need not to be locked */
 14019                        ;					}
 14020                        ;				}
 14021                        ;#endif
  Thu May 20 2021 21:37                                                Page 282


 14022                        ;			}
 14023                        ;		}
 14024                        L10320:
 14025                        ;		FREE_NAMBUF();
 14026                        L10316:
 14027                        ;		if (res == FR_NO_FILE) res = FR_NO_PATH;
 14028 00:4170: A5 05        	lda	<L576+res_1
 14029 00:4172: C9 04 00     	cmp	#<$4
 14030 00:4175: F0 03        	beq	L584
 14031 00:4177: 82 05 00     	brl	L10321
 14032                        L584:
 14033 00:417A: A9 05 00     	lda	#$5
 14034 00:417D: 85 05        	sta	<L576+res_1
 14035                        ;	}
 14036                        L10321:
 14037                        ;	if (res != FR_OK) dp->obj.fs = 0;		
                    /* Invalidate the directory object if function faild */
 14038                        L10315:
 14039 00:417F: A5 05        	lda	<L576+res_1
 14040 00:4181: D0 03        	bne	L585
 14041 00:4183: 82 0D 00     	brl	L10322
 14042                        L585:
 14043 00:4186: A9 00 00     	lda	#$0
 14044 00:4189: 87 0E        	sta	[<L575+dp_0]
 14045 00:418B: A9 00 00     	lda	#$0
 14046 00:418E: A0 02 00     	ldy	#$2
 14047 00:4191: 97 0E        	sta	[<L575+dp_0],Y
 14048                        ;
 14049                        ;	LEAVE_FF(fs, res);
 14050                        L10322:
 14051 00:4193: A5 05        	lda	<L576+res_1
 14052 00:4195: 82 15 FF     	brl	L578
 14053                        ;}
 14054             0000000A   L575	equ	10
 14055             00000005   L576	equ	5
 14056                        	ends
 14057                        	efunc
 14058                        ;
 14059                        ;
 14060                        ;
 14061                        ;
 14062                        ;/*-----------------------------------------------
                    ------------------------*/
 14063                        ;/* Close Directory                               
                                            */
 14064                        ;/*-----------------------------------------------
                    ------------------------*/
 14065                        ;
 14066                        ;FRESULT f_closedir (
 14067                        ;	DIR *dp		/* Pointer to the directory obje
                    ct to be closed */
 14068                        ;)
 14069                        ;{
 14070                        	code
 14071                        	xdef	~~f_closedir
 14072                        	func
 14073                        ~~f_closedir:
 14074                        	longa	on
  Thu May 20 2021 21:37                                                Page 283


 14075                        	longi	on
 14076 00:4198: 3B           	tsc
 14077 00:4199: 38           	sec
 14078 00:419A: E9 06 00     	sbc	#L586
 14079 00:419D: 1B           	tcs
 14080 00:419E: 0B           	phd
 14081 00:419F: 5B           	tcd
 14082             00000004   dp_0	set	4
 14083                        ;	FRESULT res;
 14084                        ;	FATFS *fs;
 14085                        ;
 14086                        ;
 14087                        ;	res = validate(&dp->obj, &fs);	/* Check validit
                    y of the file object */
 14088             00000000   res_1	set	0
 14089             00000002   fs_1	set	2
 14090 00:41A0: F4 00 00     	pea	#0
 14091 00:41A3: 18           	clc
 14092 00:41A4: 7B           	tdc
 14093 00:41A5: 69 03 00     	adc	#<L587+fs_1
 14094 00:41A8: 48           	pha
 14095 00:41A9: D4 0C        	pei	<L586+dp_0+2
 14096 00:41AB: D4 0A        	pei	<L586+dp_0
 14097 00:41AD: 22 xx xx xx  	jsl	~~validate
 14098 00:41B1: 85 01        	sta	<L587+res_1
 14099                        ;	if (res == FR_OK) {
 14100 00:41B3: A5 01        	lda	<L587+res_1
 14101 00:41B5: F0 03        	beq	L588
 14102 00:41B7: 82 0D 00     	brl	L10323
 14103                        L588:
 14104                        ;#if FF_FS_LOCK != 0
 14105                        ;		if (dp->obj.lockid) res = dec_lock(dp->o
                    bj.lockid);	/* Decrement sub-directory open counter */
 14106                        ;		if (res == FR_OK) dp->obj.fs = 0;	
                    /* Invalidate directory object */
 14107                        ;#else
 14108                        ;		dp->obj.fs = 0;	/* Invalidate directory 
                    object */
 14109 00:41BA: A9 00 00     	lda	#$0
 14110 00:41BD: 87 0A        	sta	[<L586+dp_0]
 14111 00:41BF: A9 00 00     	lda	#$0
 14112 00:41C2: A0 02 00     	ldy	#$2
 14113 00:41C5: 97 0A        	sta	[<L586+dp_0],Y
 14114                        ;#endif
 14115                        ;#if FF_FS_REENTRANT
 14116                        ;		unlock_fs(fs, FR_OK);		/* Unloc
                    k volume */
 14117                        ;#endif
 14118                        ;	}
 14119                        ;	return res;
 14120                        L10323:
 14121 00:41C7: A5 01        	lda	<L587+res_1
 14122                        L589:
 14123 00:41C9: A8           	tay
 14124 00:41CA: A5 08        	lda	<L586+2
 14125 00:41CC: 85 0C        	sta	<L586+2+4
 14126 00:41CE: A5 07        	lda	<L586+1
 14127 00:41D0: 85 0B        	sta	<L586+1+4
  Thu May 20 2021 21:37                                                Page 284


 14128 00:41D2: 2B           	pld
 14129 00:41D3: 3B           	tsc
 14130 00:41D4: 18           	clc
 14131 00:41D5: 69 0A 00     	adc	#L586+4
 14132 00:41D8: 1B           	tcs
 14133 00:41D9: 98           	tya
 14134 00:41DA: 6B           	rtl
 14135                        ;}
 14136             00000006   L586	equ	6
 14137             00000001   L587	equ	1
 14138                        	ends
 14139                        	efunc
 14140                        ;
 14141                        ;
 14142                        ;
 14143                        ;
 14144                        ;/*-----------------------------------------------
                    ------------------------*/
 14145                        ;/* Read Directory Entries in Sequence            
                                            */
 14146                        ;/*-----------------------------------------------
                    ------------------------*/
 14147                        ;
 14148                        ;FRESULT f_readdir (
 14149                        ;	DIR* dp,			/* Pointer to th
                    e open directory object */
 14150                        ;	FILINFO* fno		/* Pointer to file infor
                    mation to return */
 14151                        ;)
 14152                        ;{
 14153                        	code
 14154                        	xdef	~~f_readdir
 14155                        	func
 14156                        ~~f_readdir:
 14157                        	longa	on
 14158                        	longi	on
 14159 00:41DB: 3B           	tsc
 14160 00:41DC: 38           	sec
 14161 00:41DD: E9 06 00     	sbc	#L590
 14162 00:41E0: 1B           	tcs
 14163 00:41E1: 0B           	phd
 14164 00:41E2: 5B           	tcd
 14165             00000004   dp_0	set	4
 14166             00000008   fno_0	set	8
 14167                        ;	FRESULT res;
 14168                        ;	FATFS *fs;
 14169                        ;	DEF_NAMBUF
 14170                        ;
 14171                        ;
 14172                        ;	res = validate(&dp->obj, &fs);	/* Check validit
                    y of the directory object */
 14173             00000000   res_1	set	0
 14174             00000002   fs_1	set	2
 14175 00:41E3: F4 00 00     	pea	#0
 14176 00:41E6: 18           	clc
 14177 00:41E7: 7B           	tdc
 14178 00:41E8: 69 03 00     	adc	#<L591+fs_1
 14179 00:41EB: 48           	pha
  Thu May 20 2021 21:37                                                Page 285


 14180 00:41EC: D4 0C        	pei	<L590+dp_0+2
 14181 00:41EE: D4 0A        	pei	<L590+dp_0
 14182 00:41F0: 22 xx xx xx  	jsl	~~validate
 14183 00:41F4: 85 01        	sta	<L591+res_1
 14184                        ;	if (res == FR_OK) {
 14185 00:41F6: A5 01        	lda	<L591+res_1
 14186 00:41F8: F0 03        	beq	L592
 14187 00:41FA: 82 61 00     	brl	L10324
 14188                        L592:
 14189                        ;		if (!fno) {
 14190 00:41FD: A5 0E        	lda	<L590+fno_0
 14191 00:41FF: 05 10        	ora	<L590+fno_0+2
 14192 00:4201: F0 03        	beq	L593
 14193 00:4203: 82 13 00     	brl	L10325
 14194                        L593:
 14195                        ;			res = dir_sdi(dp, 0);		
                    	/* Rewind the directory object */
 14196 00:4206: F4 00 00     	pea	#^$0
 14197 00:4209: F4 00 00     	pea	#<$0
 14198 00:420C: D4 0C        	pei	<L590+dp_0+2
 14199 00:420E: D4 0A        	pei	<L590+dp_0
 14200 00:4210: 22 xx xx xx  	jsl	~~dir_sdi
 14201 00:4214: 85 01        	sta	<L591+res_1
 14202                        ;		} else {
 14203 00:4216: 82 45 00     	brl	L10326
 14204                        L10325:
 14205                        ;			INIT_NAMBUF(fs);
 14206                        ;			res = DIR_READ_FILE(dp);	
                    	/* Read an item */
 14207 00:4219: F4 00 00     	pea	#<$0
 14208 00:421C: D4 0C        	pei	<L590+dp_0+2
 14209 00:421E: D4 0A        	pei	<L590+dp_0
 14210 00:4220: 22 xx xx xx  	jsl	~~dir_read
 14211 00:4224: 85 01        	sta	<L591+res_1
 14212                        ;			if (res == FR_NO_FILE) res = FR_
                    OK;	/* Ignore end of directory */
 14213 00:4226: A5 01        	lda	<L591+res_1
 14214 00:4228: C9 04 00     	cmp	#<$4
 14215 00:422B: F0 03        	beq	L594
 14216 00:422D: 82 02 00     	brl	L10327
 14217                        L594:
 14218 00:4230: 64 01        	stz	<L591+res_1
 14219                        ;			if (res == FR_OK) {		
                    		/* A valid entry is found */
 14220                        L10327:
 14221 00:4232: A5 01        	lda	<L591+res_1
 14222 00:4234: F0 03        	beq	L595
 14223 00:4236: 82 25 00     	brl	L10328
 14224                        L595:
 14225                        ;				get_fileinfo(dp, fno);	
                    	/* Get the object information */
 14226 00:4239: D4 10        	pei	<L590+fno_0+2
 14227 00:423B: D4 0E        	pei	<L590+fno_0
 14228 00:423D: D4 0C        	pei	<L590+dp_0+2
 14229 00:423F: D4 0A        	pei	<L590+dp_0
 14230 00:4241: 22 xx xx xx  	jsl	~~get_fileinfo
 14231                        ;				res = dir_next(dp, 0);	
                    	/* Increment index for next */
  Thu May 20 2021 21:37                                                Page 286


 14232 00:4245: F4 00 00     	pea	#<$0
 14233 00:4248: D4 0C        	pei	<L590+dp_0+2
 14234 00:424A: D4 0A        	pei	<L590+dp_0
 14235 00:424C: 22 xx xx xx  	jsl	~~dir_next
 14236 00:4250: 85 01        	sta	<L591+res_1
 14237                        ;				if (res == FR_NO_FILE) r
                    es = FR_OK;	/* Ignore end of directory now */
 14238 00:4252: A5 01        	lda	<L591+res_1
 14239 00:4254: C9 04 00     	cmp	#<$4
 14240 00:4257: F0 03        	beq	L596
 14241 00:4259: 82 02 00     	brl	L10329
 14242                        L596:
 14243 00:425C: 64 01        	stz	<L591+res_1
 14244                        ;			}
 14245                        L10329:
 14246                        ;			FREE_NAMBUF();
 14247                        L10328:
 14248                        ;		}
 14249                        L10326:
 14250                        ;	}
 14251                        ;	LEAVE_FF(fs, res);
 14252                        L10324:
 14253 00:425E: A5 01        	lda	<L591+res_1
 14254                        L597:
 14255 00:4260: A8           	tay
 14256 00:4261: A5 08        	lda	<L590+2
 14257 00:4263: 85 10        	sta	<L590+2+8
 14258 00:4265: A5 07        	lda	<L590+1
 14259 00:4267: 85 0F        	sta	<L590+1+8
 14260 00:4269: 2B           	pld
 14261 00:426A: 3B           	tsc
 14262 00:426B: 18           	clc
 14263 00:426C: 69 0E 00     	adc	#L590+8
 14264 00:426F: 1B           	tcs
 14265 00:4270: 98           	tya
 14266 00:4271: 6B           	rtl
 14267                        ;}
 14268             00000006   L590	equ	6
 14269             00000001   L591	equ	1
 14270                        	ends
 14271                        	efunc
 14272                        ;
 14273                        ;
 14274                        ;
 14275                        ;#if FF_USE_FIND
 14276                        ;/*-----------------------------------------------
                    ------------------------*/
 14277                        ;/* Find Next File                                
                                            */
 14278                        ;/*-----------------------------------------------
                    ------------------------*/
 14279                        ;
 14280                        ;FRESULT f_findnext (
 14281                        ;	DIR* dp,		/* Pointer to the open d
                    irectory object */
 14282                        ;	FILINFO* fno	/* Pointer to the file informati
                    on structure */
 14283                        ;)
  Thu May 20 2021 21:37                                                Page 287


 14284                        ;{
 14285                        ;	FRESULT res;
 14286                        ;
 14287                        ;
 14288                        ;	for (;;) {
 14289                        ;		res = f_readdir(dp, fno);		
                    /* Get a directory item */
 14290                        ;		if (res != FR_OK || !fno || !fno->fname[
                    0]) break;	/* Terminate if any error or end of directory */
 14291                        ;		if (pattern_match(dp->pat, fno->fname, 0
                    , FIND_RECURS)) break;		/* Test for the file nam
                    e */
 14292                        ;#if FF_USE_LFN && FF_USE_FIND == 2
 14293                        ;		if (pattern_match(dp->pat, fno->altname,
                     0, FIND_RECURS)) break;	/* Test for alternative name if 
                    exist */
 14294                        ;#endif
 14295                        ;	}
 14296                        ;	return res;
 14297                        ;}
 14298                        ;
 14299                        ;
 14300                        ;
 14301                        ;/*-----------------------------------------------
                    ------------------------*/
 14302                        ;/* Find First File                               
                                            */
 14303                        ;/*-----------------------------------------------
                    ------------------------*/
 14304                        ;
 14305                        ;FRESULT f_findfirst (
 14306                        ;	DIR* dp,				/* Point
                    er to the blank directory object */
 14307                        ;	FILINFO* fno,			/* Pointer to th
                    e file information structure */
 14308                        ;	const TCHAR* path,		/* Pointer to th
                    e directory to open */
 14309                        ;	const TCHAR* pattern	/* Pointer to the matchi
                    ng pattern */
 14310                        ;)
 14311                        ;{
 14312                        ;	FRESULT res;
 14313                        ;
 14314                        ;
 14315                        ;	dp->pat = pattern;		/* Save pointer 
                    to pattern string */
 14316                        ;	res = f_opendir(dp, path);		/* Open 
                    the target directory */
 14317                        ;	if (res == FR_OK) {
 14318                        ;		res = f_findnext(dp, fno);	/* Find 
                    the first item */
 14319                        ;	}
 14320                        ;	return res;
 14321                        ;}
 14322                        ;
 14323                        ;#endif	/* FF_USE_FIND */
 14324                        ;
 14325                        ;
  Thu May 20 2021 21:37                                                Page 288


 14326                        ;
 14327                        ;#if FF_FS_MINIMIZE == 0
 14328                        ;/*-----------------------------------------------
                    ------------------------*/
 14329                        ;/* Get File Status                               
                                            */
 14330                        ;/*-----------------------------------------------
                    ------------------------*/
 14331                        ;
 14332                        ;FRESULT f_stat (
 14333                        ;	const TCHAR* path,	/* Pointer to the file p
                    ath */
 14334                        ;	FILINFO* fno		/* Pointer to file infor
                    mation to return */
 14335                        ;)
 14336                        ;{
 14337                        	code
 14338                        	xdef	~~f_stat
 14339                        	func
 14340                        ~~f_stat:
 14341                        	longa	on
 14342                        	longi	on
 14343 00:4272: 3B           	tsc
 14344 00:4273: 38           	sec
 14345 00:4274: E9 2E 00     	sbc	#L598
 14346 00:4277: 1B           	tcs
 14347 00:4278: 0B           	phd
 14348 00:4279: 5B           	tcd
 14349             00000004   path_0	set	4
 14350             00000008   fno_0	set	8
 14351                        ;	FRESULT res;
 14352                        ;	DIR dj;
 14353                        ;	DEF_NAMBUF
 14354                        ;
 14355                        ;
 14356                        ;	/* Get logical drive */
 14357                        ;	res = mount_volume(&path, &dj.obj.fs, 0);
 14358             00000000   res_1	set	0
 14359             00000002   dj_1	set	2
 14360 00:427A: F4 00 00     	pea	#<$0
 14361 00:427D: F4 00 00     	pea	#0
 14362 00:4280: 18           	clc
 14363 00:4281: 7B           	tdc
 14364 00:4282: 69 03 00     	adc	#<L599+dj_1
 14365 00:4285: 48           	pha
 14366 00:4286: F4 00 00     	pea	#0
 14367 00:4289: 18           	clc
 14368 00:428A: 7B           	tdc
 14369 00:428B: 69 32 00     	adc	#<L598+path_0
 14370 00:428E: 48           	pha
 14371 00:428F: 22 xx xx xx  	jsl	~~mount_volume
 14372 00:4293: 85 01        	sta	<L599+res_1
 14373                        ;	if (res == FR_OK) {
 14374 00:4295: A5 01        	lda	<L599+res_1
 14375 00:4297: F0 03        	beq	L600
 14376 00:4299: 82 49 00     	brl	L10330
 14377                        L600:
 14378                        ;		INIT_NAMBUF(dj.obj.fs);
  Thu May 20 2021 21:37                                                Page 289


 14379                        ;		res = follow_path(&dj, path);	/* Follo
                    w the file path */
 14380 00:429C: D4 34        	pei	<L598+path_0+2
 14381 00:429E: D4 32        	pei	<L598+path_0
 14382 00:42A0: F4 00 00     	pea	#0
 14383 00:42A3: 18           	clc
 14384 00:42A4: 7B           	tdc
 14385 00:42A5: 69 03 00     	adc	#<L599+dj_1
 14386 00:42A8: 48           	pha
 14387 00:42A9: 22 xx xx xx  	jsl	~~follow_path
 14388 00:42AD: 85 01        	sta	<L599+res_1
 14389                        ;		if (res == FR_OK) {			
                    	/* Follow completed */
 14390 00:42AF: A5 01        	lda	<L599+res_1
 14391 00:42B1: F0 03        	beq	L601
 14392 00:42B3: 82 2F 00     	brl	L10331
 14393                        L601:
 14394                        ;			if (dj.fn[NSFLAG] & NS_NONAME) {
                    	/* It is origin directory */
 14395 00:42B6: E2 20        	sep	#$20
 14396                        	longa	off
 14397 00:42B8: A5 2E        	lda	<L599+dj_1+43
 14398 00:42BA: 29 80        	and	#<$80
 14399 00:42BC: C2 20        	rep	#$20
 14400                        	longa	on
 14401 00:42BE: D0 03        	bne	L602
 14402 00:42C0: 82 08 00     	brl	L10332
 14403                        L602:
 14404                        ;				res = FR_INVALID_NAME;
 14405 00:42C3: A9 06 00     	lda	#$6
 14406 00:42C6: 85 01        	sta	<L599+res_1
 14407                        ;			} else {			
                    				/* Found an object */
 14408 00:42C8: 82 1A 00     	brl	L10333
 14409                        L10332:
 14410                        ;				if (fno) get_fileinfo(&d
                    j, fno);
 14411 00:42CB: A5 36        	lda	<L598+fno_0
 14412 00:42CD: 05 38        	ora	<L598+fno_0+2
 14413 00:42CF: D0 03        	bne	L603
 14414 00:42D1: 82 11 00     	brl	L10334
 14415                        L603:
 14416 00:42D4: D4 38        	pei	<L598+fno_0+2
 14417 00:42D6: D4 36        	pei	<L598+fno_0
 14418 00:42D8: F4 00 00     	pea	#0
 14419 00:42DB: 18           	clc
 14420 00:42DC: 7B           	tdc
 14421 00:42DD: 69 03 00     	adc	#<L599+dj_1
 14422 00:42E0: 48           	pha
 14423 00:42E1: 22 xx xx xx  	jsl	~~get_fileinfo
 14424                        ;			}
 14425                        L10334:
 14426                        L10333:
 14427                        ;		}
 14428                        ;		FREE_NAMBUF();
 14429                        L10331:
 14430                        ;	}
 14431                        ;
  Thu May 20 2021 21:37                                                Page 290


 14432                        ;	LEAVE_FF(dj.obj.fs, res);
 14433                        L10330:
 14434 00:42E5: A5 01        	lda	<L599+res_1
 14435                        L604:
 14436 00:42E7: A8           	tay
 14437 00:42E8: A5 30        	lda	<L598+2
 14438 00:42EA: 85 38        	sta	<L598+2+8
 14439 00:42EC: A5 2F        	lda	<L598+1
 14440 00:42EE: 85 37        	sta	<L598+1+8
 14441 00:42F0: 2B           	pld
 14442 00:42F1: 3B           	tsc
 14443 00:42F2: 18           	clc
 14444 00:42F3: 69 36 00     	adc	#L598+8
 14445 00:42F6: 1B           	tcs
 14446 00:42F7: 98           	tya
 14447 00:42F8: 6B           	rtl
 14448                        ;}
 14449             0000002E   L598	equ	46
 14450             00000001   L599	equ	1
 14451                        	ends
 14452                        	efunc
 14453                        ;
 14454                        ;
 14455                        ;
 14456                        ;#if !FF_FS_READONLY
 14457                        ;/*-----------------------------------------------
                    ------------------------*/
 14458                        ;/* Get Number of Free Clusters                   
                                            */
 14459                        ;/*-----------------------------------------------
                    ------------------------*/
 14460                        ;
 14461                        ;FRESULT f_getfree (
 14462                        ;	const TCHAR* path,	/* Logical drive number 
                    */
 14463                        ;	DWORD* nclst,		/* Pointer to a variable
                     to return number of free clusters */
 14464                        ;	FATFS** fatfs		/* Pointer to return poi
                    nter to corresponding filesystem object */
 14465                        ;)
 14466                        ;{
 14467                        	code
 14468                        	xdef	~~f_getfree
 14469                        	func
 14470                        ~~f_getfree:
 14471                        	longa	on
 14472                        	longi	on
 14473 00:42F9: 3B           	tsc
 14474 00:42FA: 38           	sec
 14475 00:42FB: E9 38 00     	sbc	#L605
 14476 00:42FE: 1B           	tcs
 14477 00:42FF: 0B           	phd
 14478 00:4300: 5B           	tcd
 14479             00000004   path_0	set	4
 14480             00000008   nclst_0	set	8
 14481             0000000C   fatfs_0	set	12
 14482                        ;	FRESULT res;
 14483                        ;	FATFS *fs;
  Thu May 20 2021 21:37                                                Page 291


 14484                        ;	DWORD nfree, clst, stat;
 14485                        ;	LBA_t sect;
 14486                        ;	UINT i;
 14487                        ;	FFOBJID obj;
 14488                        ;
 14489                        ;
 14490                        ;	/* Get logical drive */
 14491                        ;	res = mount_volume(&path, &fs, 0);
 14492             00000000   res_1	set	0
 14493             00000002   fs_1	set	2
 14494             00000006   nfree_1	set	6
 14495             0000000A   clst_1	set	10
 14496             0000000E   stat_1	set	14
 14497             00000012   sect_1	set	18
 14498             00000016   i_1	set	22
 14499             00000018   obj_1	set	24
 14500 00:4301: F4 00 00     	pea	#<$0
 14501 00:4304: F4 00 00     	pea	#0
 14502 00:4307: 18           	clc
 14503 00:4308: 7B           	tdc
 14504 00:4309: 69 13 00     	adc	#<L606+fs_1
 14505 00:430C: 48           	pha
 14506 00:430D: F4 00 00     	pea	#0
 14507 00:4310: 18           	clc
 14508 00:4311: 7B           	tdc
 14509 00:4312: 69 3C 00     	adc	#<L605+path_0
 14510 00:4315: 48           	pha
 14511 00:4316: 22 xx xx xx  	jsl	~~mount_volume
 14512 00:431A: 85 11        	sta	<L606+res_1
 14513                        ;	if (res == FR_OK) {
 14514 00:431C: A5 11        	lda	<L606+res_1
 14515 00:431E: F0 03        	beq	L607
 14516 00:4320: 82 0D 02     	brl	L10335
 14517                        L607:
 14518                        ;		*fatfs = fs;				
                    /* Return ptr to the fs object */
 14519 00:4323: A5 13        	lda	<L606+fs_1
 14520 00:4325: 87 44        	sta	[<L605+fatfs_0]
 14521 00:4327: A5 15        	lda	<L606+fs_1+2
 14522 00:4329: A0 02 00     	ldy	#$2
 14523 00:432C: 97 44        	sta	[<L605+fatfs_0],Y
 14524                        ;		/* If free_clst is valid, return it with
                    out full FAT scan */
 14525                        ;		if (fs->free_clst <= fs->n_fatent - 2) {
 14526 00:432E: 18           	clc
 14527 00:432F: A9 FE FF     	lda	#$fffe
 14528 00:4332: A0 13 00     	ldy	#$13
 14529 00:4335: 77 13        	adc	[<L606+fs_1],Y
 14530 00:4337: 85 01        	sta	<R0
 14531 00:4339: A9 FF FF     	lda	#$ffff
 14532 00:433C: A0 15 00     	ldy	#$15
 14533 00:433F: 77 13        	adc	[<L606+fs_1],Y
 14534 00:4341: 85 03        	sta	<R0+2
 14535 00:4343: A5 01        	lda	<R0
 14536 00:4345: A0 0F 00     	ldy	#$f
 14537 00:4348: D7 13        	cmp	[<L606+fs_1],Y
 14538 00:434A: A5 03        	lda	<R0+2
 14539 00:434C: A0 11 00     	ldy	#$11
  Thu May 20 2021 21:37                                                Page 292


 14540 00:434F: F7 13        	sbc	[<L606+fs_1],Y
 14541 00:4351: B0 03        	bcs	L608
 14542 00:4353: 82 14 00     	brl	L10336
 14543                        L608:
 14544                        ;			*nclst = fs->free_clst;
 14545 00:4356: A0 0F 00     	ldy	#$f
 14546 00:4359: B7 13        	lda	[<L606+fs_1],Y
 14547 00:435B: 87 40        	sta	[<L605+nclst_0]
 14548 00:435D: A0 11 00     	ldy	#$11
 14549 00:4360: B7 13        	lda	[<L606+fs_1],Y
 14550 00:4362: A0 02 00     	ldy	#$2
 14551 00:4365: 97 40        	sta	[<L605+nclst_0],Y
 14552                        ;		} else {
 14553 00:4367: 82 C6 01     	brl	L10337
 14554                        L10336:
 14555                        ;			/* Scan FAT to obtain number of 
                    free clusters */
 14556                        ;			nfree = 0;
 14557 00:436A: 64 17        	stz	<L606+nfree_1
 14558 00:436C: 64 19        	stz	<L606+nfree_1+2
 14559                        ;			if (fs->fs_type == FS_FAT12) {	
                    /* FAT12: Scan bit field FAT entries */
 14560 00:436E: E2 20        	sep	#$20
 14561                        	longa	off
 14562 00:4370: A7 13        	lda	[<L606+fs_1]
 14563 00:4372: C9 01        	cmp	#<$1
 14564 00:4374: C2 20        	rep	#$20
 14565                        	longa	on
 14566 00:4376: F0 03        	beq	L609
 14567 00:4378: 82 84 00     	brl	L10338
 14568                        L609:
 14569                        ;				clst = 2; obj.fs = fs;
 14570 00:437B: A9 02 00     	lda	#$2
 14571 00:437E: 85 1B        	sta	<L606+clst_1
 14572 00:4380: A9 00 00     	lda	#$0
 14573 00:4383: 85 1D        	sta	<L606+clst_1+2
 14574 00:4385: A5 13        	lda	<L606+fs_1
 14575 00:4387: 85 29        	sta	<L606+obj_1
 14576 00:4389: A5 15        	lda	<L606+fs_1+2
 14577 00:438B: 85 2B        	sta	<L606+obj_1+2
 14578                        ;				do {
 14579                        L10341:
 14580                        ;					stat = get_fat(&
                    obj, clst);
 14581 00:438D: D4 1D        	pei	<L606+clst_1+2
 14582 00:438F: D4 1B        	pei	<L606+clst_1
 14583 00:4391: F4 00 00     	pea	#0
 14584 00:4394: 18           	clc
 14585 00:4395: 7B           	tdc
 14586 00:4396: 69 29 00     	adc	#<L606+obj_1
 14587 00:4399: 48           	pha
 14588 00:439A: 22 xx xx xx  	jsl	~~get_fat
 14589 00:439E: 85 1F        	sta	<L606+stat_1
 14590 00:43A0: 86 21        	stx	<L606+stat_1+2
 14591                        ;					if (stat == 0xFF
                    FFFFFF) { res = FR_DISK_ERR; break; }
 14592 00:43A2: A5 1F        	lda	<L606+stat_1
 14593 00:43A4: C9 FF FF     	cmp	#<$ffffffff
  Thu May 20 2021 21:37                                                Page 293


 14594 00:43A7: D0 05        	bne	L610
 14595 00:43A9: A5 21        	lda	<L606+stat_1+2
 14596 00:43AB: C9 FF FF     	cmp	#^$ffffffff
 14597                        L610:
 14598 00:43AE: F0 03        	beq	L611
 14599 00:43B0: 82 08 00     	brl	L10342
 14600                        L611:
 14601 00:43B3: A9 01 00     	lda	#$1
 14602 00:43B6: 85 11        	sta	<L606+res_1
 14603 00:43B8: 82 41 00     	brl	L10340
 14604                        ;					if (stat == 1) {
                     res = FR_INT_ERR; break; }
 14605                        L10342:
 14606 00:43BB: A5 1F        	lda	<L606+stat_1
 14607 00:43BD: C9 01 00     	cmp	#<$1
 14608 00:43C0: D0 05        	bne	L612
 14609 00:43C2: A5 21        	lda	<L606+stat_1+2
 14610 00:43C4: C9 00 00     	cmp	#^$1
 14611                        L612:
 14612 00:43C7: F0 03        	beq	L613
 14613 00:43C9: 82 08 00     	brl	L10343
 14614                        L613:
 14615 00:43CC: A9 02 00     	lda	#$2
 14616 00:43CF: 85 11        	sta	<L606+res_1
 14617 00:43D1: 82 28 00     	brl	L10340
 14618                        ;					if (stat == 0) n
                    free++;
 14619                        L10343:
 14620 00:43D4: A5 1F        	lda	<L606+stat_1
 14621 00:43D6: 05 21        	ora	<L606+stat_1+2
 14622 00:43D8: F0 03        	beq	L614
 14623 00:43DA: 82 06 00     	brl	L10344
 14624                        L614:
 14625 00:43DD: E6 17        	inc	<L606+nfree_1
 14626 00:43DF: D0 02        	bne	L615
 14627 00:43E1: E6 19        	inc	<L606+nfree_1+2
 14628                        L615:
 14629                        ;				} while (++clst < fs->n_
                    fatent);
 14630                        L10344:
 14631                        L10339:
 14632 00:43E3: E6 1B        	inc	<L606+clst_1
 14633 00:43E5: D0 02        	bne	L616
 14634 00:43E7: E6 1D        	inc	<L606+clst_1+2
 14635                        L616:
 14636 00:43E9: A5 1B        	lda	<L606+clst_1
 14637 00:43EB: A0 13 00     	ldy	#$13
 14638 00:43EE: D7 13        	cmp	[<L606+fs_1],Y
 14639 00:43F0: A5 1D        	lda	<L606+clst_1+2
 14640 00:43F2: A0 15 00     	ldy	#$15
 14641 00:43F5: F7 13        	sbc	[<L606+fs_1],Y
 14642 00:43F7: B0 03        	bcs	L617
 14643 00:43F9: 82 91 FF     	brl	L10341
 14644                        L617:
 14645                        L10340:
 14646                        ;			} else {
 14647 00:43FC: 82 F8 00     	brl	L10345
 14648                        L10338:
  Thu May 20 2021 21:37                                                Page 294


 14649                        ;#if FF_FS_EXFAT
 14650                        ;				if (fs->fs_type == FS_EX
                    FAT) {	/* exFAT: Scan allocation bitmap */
 14651                        ;					BYTE bm;
 14652                        ;					UINT b;
 14653                        ;
 14654                        ;					clst = fs->n_fat
                    ent - 2;	/* Number of clusters */
 14655                        ;					sect = fs->bitba
                    se;			/* Bitmap sector */
 14656                        ;					i = 0;		
                    				/* Offset in the sector */
 14657                        ;					do {	/* Count
                    s numbuer of bits with zero in the bitmap */
 14658                        ;						if (i ==
                     0) {
 14659                        ;							
                    res = move_window(fs, sect++);
 14660                        ;							
                    if (res != FR_OK) break;
 14661                        ;						}
 14662                        ;						for (b =
                     8, bm = fs->win[i]; b && clst; b--, clst--) {
 14663                        ;							
                    if (!(bm & 1)) nfree++;
 14664                        ;							
                    bm >>= 1;
 14665                        ;						}
 14666                        ;						i = (i +
                     1) % SS(fs);
 14667                        ;					} while (clst);
 14668                        ;				} else
 14669                        ;#endif
 14670                        ;				{	/* FAT16/32: Sca
                    n WORD/DWORD FAT entries */
 14671                        ;					clst = fs->n_fat
                    ent;	/* Number of entries */
 14672 00:43FF: A0 13 00     	ldy	#$13
 14673 00:4402: B7 13        	lda	[<L606+fs_1],Y
 14674 00:4404: 85 1B        	sta	<L606+clst_1
 14675 00:4406: A0 15 00     	ldy	#$15
 14676 00:4409: B7 13        	lda	[<L606+fs_1],Y
 14677 00:440B: 85 1D        	sta	<L606+clst_1+2
 14678                        ;					sect = fs->fatba
                    se;		/* Top of the FAT */
 14679 00:440D: A0 1F 00     	ldy	#$1f
 14680 00:4410: B7 13        	lda	[<L606+fs_1],Y
 14681 00:4412: 85 23        	sta	<L606+sect_1
 14682 00:4414: A0 21 00     	ldy	#$21
 14683 00:4417: B7 13        	lda	[<L606+fs_1],Y
 14684 00:4419: 85 25        	sta	<L606+sect_1+2
 14685                        ;					i = 0;		
                    			/* Offset in the sector */
 14686 00:441B: 64 27        	stz	<L606+i_1
 14687                        ;					do {	/* Count
                    s numbuer of entries with zero in the FAT */
 14688                        L10348:
 14689                        ;						if (i ==
  Thu May 20 2021 21:37                                                Page 295


                     0) {
 14690 00:441D: A5 27        	lda	<L606+i_1
 14691 00:441F: F0 03        	beq	L618
 14692 00:4421: 82 23 00     	brl	L10349
 14693                        L618:
 14694                        ;							
                    res = move_window(fs, sect++);
 14695 00:4424: A5 23        	lda	<L606+sect_1
 14696 00:4426: 85 01        	sta	<R0
 14697 00:4428: A5 25        	lda	<L606+sect_1+2
 14698 00:442A: 85 03        	sta	<R0+2
 14699 00:442C: E6 23        	inc	<L606+sect_1
 14700 00:442E: D0 02        	bne	L619
 14701 00:4430: E6 25        	inc	<L606+sect_1+2
 14702                        L619:
 14703 00:4432: D4 03        	pei	<R0+2
 14704 00:4434: D4 01        	pei	<R0
 14705 00:4436: D4 15        	pei	<L606+fs_1+2
 14706 00:4438: D4 13        	pei	<L606+fs_1
 14707 00:443A: 22 xx xx xx  	jsl	~~move_window
 14708 00:443E: 85 11        	sta	<L606+res_1
 14709                        ;							
                    if (res != FR_OK) break;
 14710 00:4440: A5 11        	lda	<L606+res_1
 14711 00:4442: F0 03        	beq	L620
 14712 00:4444: 82 B0 00     	brl	L10347
 14713                        L620:
 14714                        ;						}
 14715                        ;						if (fs->
                    fs_type == FS_FAT16) {
 14716                        L10349:
 14717 00:4447: E2 20        	sep	#$20
 14718                        	longa	off
 14719 00:4449: A7 13        	lda	[<L606+fs_1]
 14720 00:444B: C9 02        	cmp	#<$2
 14721 00:444D: C2 20        	rep	#$20
 14722                        	longa	on
 14723 00:444F: F0 03        	beq	L621
 14724 00:4451: 82 3D 00     	brl	L10350
 14725                        L621:
 14726                        ;							
                    if (ld_word(fs->win + i) == 0) nfree++;
 14727 00:4454: A5 27        	lda	<L606+i_1
 14728 00:4456: 85 01        	sta	<R0
 14729 00:4458: 64 03        	stz	<R0+2
 14730 00:445A: 18           	clc
 14731 00:445B: A9 2F 00     	lda	#$2f
 14732 00:445E: 65 01        	adc	<R0
 14733 00:4460: 85 05        	sta	<R1
 14734 00:4462: A9 00 00     	lda	#$0
 14735 00:4465: 65 03        	adc	<R0+2
 14736 00:4467: 85 07        	sta	<R1+2
 14737 00:4469: 18           	clc
 14738 00:446A: A5 13        	lda	<L606+fs_1
 14739 00:446C: 65 05        	adc	<R1
 14740 00:446E: 85 01        	sta	<R0
 14741 00:4470: A5 15        	lda	<L606+fs_1+2
 14742 00:4472: 65 07        	adc	<R1+2
  Thu May 20 2021 21:37                                                Page 296


 14743 00:4474: 85 03        	sta	<R0+2
 14744 00:4476: D4 03        	pei	<R0+2
 14745 00:4478: D4 01        	pei	<R0
 14746 00:447A: 22 xx xx xx  	jsl	~~ld_word
 14747 00:447E: AA           	tax
 14748 00:447F: F0 03        	beq	L622
 14749 00:4481: 82 06 00     	brl	L10351
 14750                        L622:
 14751 00:4484: E6 17        	inc	<L606+nfree_1
 14752 00:4486: D0 02        	bne	L623
 14753 00:4488: E6 19        	inc	<L606+nfree_1+2
 14754                        L623:
 14755                        ;							
                    i += 2;
 14756                        L10351:
 14757 00:448A: E6 27        	inc	<L606+i_1
 14758 00:448C: E6 27        	inc	<L606+i_1
 14759                        ;						} else {
 14760 00:448E: 82 50 00     	brl	L10352
 14761                        L10350:
 14762                        ;							
                    if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
 14763 00:4491: A5 27        	lda	<L606+i_1
 14764 00:4493: 85 01        	sta	<R0
 14765 00:4495: 64 03        	stz	<R0+2
 14766 00:4497: 18           	clc
 14767 00:4498: A9 2F 00     	lda	#$2f
 14768 00:449B: 65 01        	adc	<R0
 14769 00:449D: 85 05        	sta	<R1
 14770 00:449F: A9 00 00     	lda	#$0
 14771 00:44A2: 65 03        	adc	<R0+2
 14772 00:44A4: 85 07        	sta	<R1+2
 14773 00:44A6: 18           	clc
 14774 00:44A7: A5 13        	lda	<L606+fs_1
 14775 00:44A9: 65 05        	adc	<R1
 14776 00:44AB: 85 01        	sta	<R0
 14777 00:44AD: A5 15        	lda	<L606+fs_1+2
 14778 00:44AF: 65 07        	adc	<R1+2
 14779 00:44B1: 85 03        	sta	<R0+2
 14780 00:44B3: D4 03        	pei	<R0+2
 14781 00:44B5: D4 01        	pei	<R0
 14782 00:44B7: 22 xx xx xx  	jsl	~~ld_dword
 14783 00:44BB: 85 09        	sta	<R2
 14784 00:44BD: 86 0B        	stx	<R2+2
 14785 00:44BF: A5 09        	lda	<R2
 14786 00:44C1: 85 0D        	sta	<R3
 14787 00:44C3: A5 0B        	lda	<R2+2
 14788 00:44C5: 29 FF 0F     	and	#^$fffffff
 14789 00:44C8: 85 0F        	sta	<R3+2
 14790 00:44CA: A5 0D        	lda	<R3
 14791 00:44CC: 05 0F        	ora	<R3+2
 14792 00:44CE: F0 03        	beq	L624
 14793 00:44D0: 82 06 00     	brl	L10353
 14794                        L624:
 14795 00:44D3: E6 17        	inc	<L606+nfree_1
 14796 00:44D5: D0 02        	bne	L625
 14797 00:44D7: E6 19        	inc	<L606+nfree_1+2
 14798                        L625:
  Thu May 20 2021 21:37                                                Page 297


 14799                        ;							
                    i += 4;
 14800                        L10353:
 14801 00:44D9: 18           	clc
 14802 00:44DA: A9 04 00     	lda	#$4
 14803 00:44DD: 65 27        	adc	<L606+i_1
 14804 00:44DF: 85 27        	sta	<L606+i_1
 14805                        ;						}
 14806                        L10352:
 14807                        ;						i %= SS(
                    fs);
 14808 00:44E1: A9 00 FE     	lda	#$fe00
 14809 00:44E4: 14 27        	trb	<L606+i_1
 14810                        ;					} while (--clst)
                    ;
 14811                        L10346:
 14812 00:44E6: A5 1B        	lda	<L606+clst_1
 14813 00:44E8: D0 02        	bne	L626
 14814 00:44EA: C6 1D        	dec	<L606+clst_1+2
 14815                        L626:
 14816 00:44EC: C6 1B        	dec	<L606+clst_1
 14817 00:44EE: A5 1B        	lda	<L606+clst_1
 14818 00:44F0: 05 1D        	ora	<L606+clst_1+2
 14819 00:44F2: F0 03        	beq	L627
 14820 00:44F4: 82 26 FF     	brl	L10348
 14821                        L627:
 14822                        L10347:
 14823                        ;				}
 14824                        ;			}
 14825                        L10345:
 14826                        ;			if (res == FR_OK) {		
                    /* Update parameters if succeeded */
 14827 00:44F7: A5 11        	lda	<L606+res_1
 14828 00:44F9: F0 03        	beq	L628
 14829 00:44FB: 82 32 00     	brl	L10354
 14830                        L628:
 14831                        ;				*nclst = nfree;		
                    	/* Return the free clusters */
 14832 00:44FE: A5 17        	lda	<L606+nfree_1
 14833 00:4500: 87 40        	sta	[<L605+nclst_0]
 14834 00:4502: A5 19        	lda	<L606+nfree_1+2
 14835 00:4504: A0 02 00     	ldy	#$2
 14836 00:4507: 97 40        	sta	[<L605+nclst_0],Y
 14837                        ;				fs->free_clst = nfree;	
                    /* Now free_clst is valid */
 14838 00:4509: A5 17        	lda	<L606+nfree_1
 14839 00:450B: A0 0F 00     	ldy	#$f
 14840 00:450E: 97 13        	sta	[<L606+fs_1],Y
 14841 00:4510: A5 19        	lda	<L606+nfree_1+2
 14842 00:4512: A0 11 00     	ldy	#$11
 14843 00:4515: 97 13        	sta	[<L606+fs_1],Y
 14844                        ;				fs->fsi_flag |= 1;	
                    	/* FAT32: FSInfo is to be updated */
 14845 00:4517: 18           	clc
 14846 00:4518: A9 04 00     	lda	#$4
 14847 00:451B: 65 13        	adc	<L606+fs_1
 14848 00:451D: 85 01        	sta	<R0
 14849 00:451F: A9 00 00     	lda	#$0
  Thu May 20 2021 21:37                                                Page 298


 14850 00:4522: 65 15        	adc	<L606+fs_1+2
 14851 00:4524: 85 03        	sta	<R0+2
 14852 00:4526: E2 20        	sep	#$20
 14853                        	longa	off
 14854 00:4528: A7 01        	lda	[<R0]
 14855 00:452A: 09 01        	ora	#<$1
 14856 00:452C: 87 01        	sta	[<R0]
 14857 00:452E: C2 20        	rep	#$20
 14858                        	longa	on
 14859                        ;			}
 14860                        ;		}
 14861                        L10354:
 14862                        L10337:
 14863                        ;	}
 14864                        ;
 14865                        ;	LEAVE_FF(fs, res);
 14866                        L10335:
 14867 00:4530: A5 11        	lda	<L606+res_1
 14868                        L629:
 14869 00:4532: A8           	tay
 14870 00:4533: A5 3A        	lda	<L605+2
 14871 00:4535: 85 46        	sta	<L605+2+12
 14872 00:4537: A5 39        	lda	<L605+1
 14873 00:4539: 85 45        	sta	<L605+1+12
 14874 00:453B: 2B           	pld
 14875 00:453C: 3B           	tsc
 14876 00:453D: 18           	clc
 14877 00:453E: 69 44 00     	adc	#L605+12
 14878 00:4541: 1B           	tcs
 14879 00:4542: 98           	tya
 14880 00:4543: 6B           	rtl
 14881                        ;}
 14882             00000038   L605	equ	56
 14883             00000011   L606	equ	17
 14884                        	ends
 14885                        	efunc
 14886                        ;
 14887                        ;
 14888                        ;
 14889                        ;
 14890                        ;/*-----------------------------------------------
                    ------------------------*/
 14891                        ;/* Truncate File                                 
                                            */
 14892                        ;/*-----------------------------------------------
                    ------------------------*/
 14893                        ;
 14894                        ;FRESULT f_truncate (
 14895                        ;	FIL* fp		/* Pointer to the file object */
 14896                        ;)
 14897                        ;{
 14898                        	code
 14899                        	xdef	~~f_truncate
 14900                        	func
 14901                        ~~f_truncate:
 14902                        	longa	on
 14903                        	longi	on
 14904 00:4544: 3B           	tsc
  Thu May 20 2021 21:37                                                Page 299


 14905 00:4545: 38           	sec
 14906 00:4546: E9 0E 00     	sbc	#L630
 14907 00:4549: 1B           	tcs
 14908 00:454A: 0B           	phd
 14909 00:454B: 5B           	tcd
 14910             00000004   fp_0	set	4
 14911                        ;	FRESULT res;
 14912                        ;	FATFS *fs;
 14913                        ;	DWORD ncl;
 14914                        ;
 14915                        ;
 14916                        ;	res = validate(&fp->obj, &fs);	/* Check validit
                    y of the file object */
 14917             00000000   res_1	set	0
 14918             00000002   fs_1	set	2
 14919             00000006   ncl_1	set	6
 14920 00:454C: F4 00 00     	pea	#0
 14921 00:454F: 18           	clc
 14922 00:4550: 7B           	tdc
 14923 00:4551: 69 07 00     	adc	#<L631+fs_1
 14924 00:4554: 48           	pha
 14925 00:4555: D4 14        	pei	<L630+fp_0+2
 14926 00:4557: D4 12        	pei	<L630+fp_0
 14927 00:4559: 22 xx xx xx  	jsl	~~validate
 14928 00:455D: 85 05        	sta	<L631+res_1
 14929                        ;	if (res != FR_OK || (res = (FRESULT)fp->err) != 
                    FR_OK) LEAVE_FF(fs, res);
 14930 00:455F: A5 05        	lda	<L631+res_1
 14931 00:4561: F0 03        	beq	L633
 14932 00:4563: 82 11 00     	brl	L632
 14933                        L633:
 14934 00:4566: A0 11 00     	ldy	#$11
 14935 00:4569: B7 12        	lda	[<L630+fp_0],Y
 14936 00:456B: 29 FF 00     	and	#$ff
 14937 00:456E: 85 05        	sta	<L631+res_1
 14938 00:4570: A5 05        	lda	<L631+res_1
 14939 00:4572: D0 03        	bne	L634
 14940 00:4574: 82 14 00     	brl	L10355
 14941                        L634:
 14942                        L632:
 14943 00:4577: A5 05        	lda	<L631+res_1
 14944                        L635:
 14945 00:4579: A8           	tay
 14946 00:457A: A5 10        	lda	<L630+2
 14947 00:457C: 85 14        	sta	<L630+2+4
 14948 00:457E: A5 0F        	lda	<L630+1
 14949 00:4580: 85 13        	sta	<L630+1+4
 14950 00:4582: 2B           	pld
 14951 00:4583: 3B           	tsc
 14952 00:4584: 18           	clc
 14953 00:4585: 69 12 00     	adc	#L630+4
 14954 00:4588: 1B           	tcs
 14955 00:4589: 98           	tya
 14956 00:458A: 6B           	rtl
 14957                        ;	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENI
                    ED);	/* Check access mode */
 14958                        L10355:
 14959 00:458B: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 300


 14960                        	longa	off
 14961 00:458D: A0 10 00     	ldy	#$10
 14962 00:4590: B7 12        	lda	[<L630+fp_0],Y
 14963 00:4592: 29 02        	and	#<$2
 14964 00:4594: C2 20        	rep	#$20
 14965                        	longa	on
 14966 00:4596: F0 03        	beq	L636
 14967 00:4598: 82 06 00     	brl	L10356
 14968                        L636:
 14969 00:459B: A9 07 00     	lda	#$7
 14970 00:459E: 82 D8 FF     	brl	L635
 14971                        ;
 14972                        ;	if (fp->fptr < fp->obj.objsize) {	/* Proce
                    ss when fptr is not on the eof */
 14973                        L10356:
 14974 00:45A1: A0 12 00     	ldy	#$12
 14975 00:45A4: B7 12        	lda	[<L630+fp_0],Y
 14976 00:45A6: A0 0C 00     	ldy	#$c
 14977 00:45A9: D7 12        	cmp	[<L630+fp_0],Y
 14978 00:45AB: A0 14 00     	ldy	#$14
 14979 00:45AE: B7 12        	lda	[<L630+fp_0],Y
 14980 00:45B0: A0 0E 00     	ldy	#$e
 14981 00:45B3: F7 12        	sbc	[<L630+fp_0],Y
 14982 00:45B5: 90 03        	bcc	L637
 14983 00:45B7: 82 66 01     	brl	L10357
 14984                        L637:
 14985                        ;		if (fp->fptr == 0) {	/* When set file
                     size to zero, remove entire cluster chain */
 14986 00:45BA: A0 12 00     	ldy	#$12
 14987 00:45BD: B7 12        	lda	[<L630+fp_0],Y
 14988 00:45BF: A0 14 00     	ldy	#$14
 14989 00:45C2: 17 12        	ora	[<L630+fp_0],Y
 14990 00:45C4: F0 03        	beq	L638
 14991 00:45C6: 82 2F 00     	brl	L10358
 14992                        L638:
 14993                        ;			res = remove_chain(&fp->obj, fp-
                    >obj.sclust, 0);
 14994 00:45C9: F4 00 00     	pea	#^$0
 14995 00:45CC: F4 00 00     	pea	#<$0
 14996 00:45CF: A0 0A 00     	ldy	#$a
 14997 00:45D2: B7 12        	lda	[<L630+fp_0],Y
 14998 00:45D4: 48           	pha
 14999 00:45D5: A0 08 00     	ldy	#$8
 15000 00:45D8: B7 12        	lda	[<L630+fp_0],Y
 15001 00:45DA: 48           	pha
 15002 00:45DB: D4 14        	pei	<L630+fp_0+2
 15003 00:45DD: D4 12        	pei	<L630+fp_0
 15004 00:45DF: 22 xx xx xx  	jsl	~~remove_chain
 15005 00:45E3: 85 05        	sta	<L631+res_1
 15006                        ;			fp->obj.sclust = 0;
 15007 00:45E5: A9 00 00     	lda	#$0
 15008 00:45E8: A0 08 00     	ldy	#$8
 15009 00:45EB: 97 12        	sta	[<L630+fp_0],Y
 15010 00:45ED: A9 00 00     	lda	#$0
 15011 00:45F0: A0 0A 00     	ldy	#$a
 15012 00:45F3: 97 12        	sta	[<L630+fp_0],Y
 15013                        ;		} else {				
                    /* When truncate a part of the file, remove remaining cluste
  Thu May 20 2021 21:37                                                Page 301


                    rs */
 15014 00:45F5: 82 7A 00     	brl	L10359
 15015                        L10358:
 15016                        ;			ncl = get_fat(&fp->obj, fp->clus
                    t);
 15017 00:45F8: A0 18 00     	ldy	#$18
 15018 00:45FB: B7 12        	lda	[<L630+fp_0],Y
 15019 00:45FD: 48           	pha
 15020 00:45FE: A0 16 00     	ldy	#$16
 15021 00:4601: B7 12        	lda	[<L630+fp_0],Y
 15022 00:4603: 48           	pha
 15023 00:4604: D4 14        	pei	<L630+fp_0+2
 15024 00:4606: D4 12        	pei	<L630+fp_0
 15025 00:4608: 22 xx xx xx  	jsl	~~get_fat
 15026 00:460C: 85 0B        	sta	<L631+ncl_1
 15027 00:460E: 86 0D        	stx	<L631+ncl_1+2
 15028                        ;			res = FR_OK;
 15029 00:4610: 64 05        	stz	<L631+res_1
 15030                        ;			if (ncl == 0xFFFFFFFF) res = FR_
                    DISK_ERR;
 15031 00:4612: A5 0B        	lda	<L631+ncl_1
 15032 00:4614: C9 FF FF     	cmp	#<$ffffffff
 15033 00:4617: D0 05        	bne	L639
 15034 00:4619: A5 0D        	lda	<L631+ncl_1+2
 15035 00:461B: C9 FF FF     	cmp	#^$ffffffff
 15036                        L639:
 15037 00:461E: F0 03        	beq	L640
 15038 00:4620: 82 05 00     	brl	L10360
 15039                        L640:
 15040 00:4623: A9 01 00     	lda	#$1
 15041 00:4626: 85 05        	sta	<L631+res_1
 15042                        ;			if (ncl == 1) res = FR_INT_ERR;
 15043                        L10360:
 15044 00:4628: A5 0B        	lda	<L631+ncl_1
 15045 00:462A: C9 01 00     	cmp	#<$1
 15046 00:462D: D0 05        	bne	L641
 15047 00:462F: A5 0D        	lda	<L631+ncl_1+2
 15048 00:4631: C9 00 00     	cmp	#^$1
 15049                        L641:
 15050 00:4634: F0 03        	beq	L642
 15051 00:4636: 82 05 00     	brl	L10361
 15052                        L642:
 15053 00:4639: A9 02 00     	lda	#$2
 15054 00:463C: 85 05        	sta	<L631+res_1
 15055                        ;			if (res == FR_OK && ncl < fs->n_
                    fatent) {
 15056                        L10361:
 15057 00:463E: A5 05        	lda	<L631+res_1
 15058 00:4640: F0 03        	beq	L643
 15059 00:4642: 82 2D 00     	brl	L10362
 15060                        L643:
 15061 00:4645: A5 0B        	lda	<L631+ncl_1
 15062 00:4647: A0 13 00     	ldy	#$13
 15063 00:464A: D7 07        	cmp	[<L631+fs_1],Y
 15064 00:464C: A5 0D        	lda	<L631+ncl_1+2
 15065 00:464E: A0 15 00     	ldy	#$15
 15066 00:4651: F7 07        	sbc	[<L631+fs_1],Y
 15067 00:4653: 90 03        	bcc	L644
  Thu May 20 2021 21:37                                                Page 302


 15068 00:4655: 82 1A 00     	brl	L10362
 15069                        L644:
 15070                        ;				res = remove_chain(&fp->
                    obj, ncl, fp->clust);
 15071 00:4658: A0 18 00     	ldy	#$18
 15072 00:465B: B7 12        	lda	[<L630+fp_0],Y
 15073 00:465D: 48           	pha
 15074 00:465E: A0 16 00     	ldy	#$16
 15075 00:4661: B7 12        	lda	[<L630+fp_0],Y
 15076 00:4663: 48           	pha
 15077 00:4664: D4 0D        	pei	<L631+ncl_1+2
 15078 00:4666: D4 0B        	pei	<L631+ncl_1
 15079 00:4668: D4 14        	pei	<L630+fp_0+2
 15080 00:466A: D4 12        	pei	<L630+fp_0
 15081 00:466C: 22 xx xx xx  	jsl	~~remove_chain
 15082 00:4670: 85 05        	sta	<L631+res_1
 15083                        ;			}
 15084                        ;		}
 15085                        L10362:
 15086                        L10359:
 15087                        ;		fp->obj.objsize = fp->fptr;	/* Set f
                    ile size to current read/write point */
 15088 00:4672: A0 12 00     	ldy	#$12
 15089 00:4675: B7 12        	lda	[<L630+fp_0],Y
 15090 00:4677: A0 0C 00     	ldy	#$c
 15091 00:467A: 97 12        	sta	[<L630+fp_0],Y
 15092 00:467C: A0 14 00     	ldy	#$14
 15093 00:467F: B7 12        	lda	[<L630+fp_0],Y
 15094 00:4681: A0 0E 00     	ldy	#$e
 15095 00:4684: 97 12        	sta	[<L630+fp_0],Y
 15096                        ;		fp->flag |= FA_MODIFIED;
 15097 00:4686: 18           	clc
 15098 00:4687: A9 10 00     	lda	#$10
 15099 00:468A: 65 12        	adc	<L630+fp_0
 15100 00:468C: 85 01        	sta	<R0
 15101 00:468E: A9 00 00     	lda	#$0
 15102 00:4691: 65 14        	adc	<L630+fp_0+2
 15103 00:4693: 85 03        	sta	<R0+2
 15104 00:4695: E2 20        	sep	#$20
 15105                        	longa	off
 15106 00:4697: A7 01        	lda	[<R0]
 15107 00:4699: 09 40        	ora	#<$40
 15108 00:469B: 87 01        	sta	[<R0]
 15109 00:469D: C2 20        	rep	#$20
 15110                        	longa	on
 15111                        ;#if !FF_FS_TINY
 15112                        ;		if (res == FR_OK && (fp->flag & FA_DIRTY
                    )) {
 15113 00:469F: A5 05        	lda	<L631+res_1
 15114 00:46A1: F0 03        	beq	L645
 15115 00:46A3: 82 63 00     	brl	L10363
 15116                        L645:
 15117 00:46A6: E2 20        	sep	#$20
 15118                        	longa	off
 15119 00:46A8: A0 10 00     	ldy	#$10
 15120 00:46AB: B7 12        	lda	[<L630+fp_0],Y
 15121 00:46AD: 29 80        	and	#<$80
 15122 00:46AF: C2 20        	rep	#$20
  Thu May 20 2021 21:37                                                Page 303


 15123                        	longa	on
 15124 00:46B1: D0 03        	bne	L646
 15125 00:46B3: 82 53 00     	brl	L10363
 15126                        L646:
 15127                        ;			if (disk_write(fs->pdrv, fp->buf
                    , fp->sect, 1) != RES_OK) {
 15128 00:46B6: F4 01 00     	pea	#<$1
 15129 00:46B9: A0 1C 00     	ldy	#$1c
 15130 00:46BC: B7 12        	lda	[<L630+fp_0],Y
 15131 00:46BE: 48           	pha
 15132 00:46BF: A0 1A 00     	ldy	#$1a
 15133 00:46C2: B7 12        	lda	[<L630+fp_0],Y
 15134 00:46C4: 48           	pha
 15135 00:46C5: 18           	clc
 15136 00:46C6: A9 26 00     	lda	#$26
 15137 00:46C9: 65 12        	adc	<L630+fp_0
 15138 00:46CB: 85 01        	sta	<R0
 15139 00:46CD: A9 00 00     	lda	#$0
 15140 00:46D0: 65 14        	adc	<L630+fp_0+2
 15141 00:46D2: 85 03        	sta	<R0+2
 15142 00:46D4: D4 03        	pei	<R0+2
 15143 00:46D6: D4 01        	pei	<R0
 15144 00:46D8: A0 01 00     	ldy	#$1
 15145 00:46DB: B7 07        	lda	[<L631+fs_1],Y
 15146 00:46DD: 48           	pha
 15147 00:46DE: 22 xx xx xx  	jsl	~~disk_write
 15148 00:46E2: AA           	tax
 15149 00:46E3: D0 03        	bne	L647
 15150 00:46E5: 82 08 00     	brl	L10364
 15151                        L647:
 15152                        ;				res = FR_DISK_ERR;
 15153 00:46E8: A9 01 00     	lda	#$1
 15154 00:46EB: 85 05        	sta	<L631+res_1
 15155                        ;			} else {
 15156 00:46ED: 82 19 00     	brl	L10365
 15157                        L10364:
 15158                        ;				fp->flag &= (BYTE)~FA_DI
                    RTY;
 15159 00:46F0: 18           	clc
 15160 00:46F1: A9 10 00     	lda	#$10
 15161 00:46F4: 65 12        	adc	<L630+fp_0
 15162 00:46F6: 85 01        	sta	<R0
 15163 00:46F8: A9 00 00     	lda	#$0
 15164 00:46FB: 65 14        	adc	<L630+fp_0+2
 15165 00:46FD: 85 03        	sta	<R0+2
 15166 00:46FF: E2 20        	sep	#$20
 15167                        	longa	off
 15168 00:4701: A7 01        	lda	[<R0]
 15169 00:4703: 29 7F        	and	#<$7f
 15170 00:4705: 87 01        	sta	[<R0]
 15171 00:4707: C2 20        	rep	#$20
 15172                        	longa	on
 15173                        ;			}
 15174                        L10365:
 15175                        ;		}
 15176                        ;#endif
 15177                        ;		if (res != FR_OK) ABORT(fs, res);
 15178                        L10363:
  Thu May 20 2021 21:37                                                Page 304


 15179 00:4709: A5 05        	lda	<L631+res_1
 15180 00:470B: D0 03        	bne	L648
 15181 00:470D: 82 10 00     	brl	L10366
 15182                        L648:
 15183 00:4710: E2 20        	sep	#$20
 15184                        	longa	off
 15185 00:4712: A5 05        	lda	<L631+res_1
 15186 00:4714: A0 11 00     	ldy	#$11
 15187 00:4717: 97 12        	sta	[<L630+fp_0],Y
 15188 00:4719: C2 20        	rep	#$20
 15189                        	longa	on
 15190 00:471B: A5 05        	lda	<L631+res_1
 15191 00:471D: 82 59 FE     	brl	L635
 15192                        L10366:
 15193                        ;	}
 15194                        ;
 15195                        ;	LEAVE_FF(fs, res);
 15196                        L10357:
 15197 00:4720: A5 05        	lda	<L631+res_1
 15198 00:4722: 82 54 FE     	brl	L635
 15199                        ;}
 15200             0000000E   L630	equ	14
 15201             00000005   L631	equ	5
 15202                        	ends
 15203                        	efunc
 15204                        ;
 15205                        ;
 15206                        ;
 15207                        ;
 15208                        ;/*-----------------------------------------------
                    ------------------------*/
 15209                        ;/* Delete a File/Directory                       
                                            */
 15210                        ;/*-----------------------------------------------
                    ------------------------*/
 15211                        ;
 15212                        ;FRESULT f_unlink (
 15213                        ;	const TCHAR* path		/* Pointer to th
                    e file or directory path */
 15214                        ;)
 15215                        ;{
 15216                        	code
 15217                        	xdef	~~f_unlink
 15218                        	func
 15219                        ~~f_unlink:
 15220                        	longa	on
 15221                        	longi	on
 15222 00:4725: 3B           	tsc
 15223 00:4726: 38           	sec
 15224 00:4727: E9 62 00     	sbc	#L649
 15225 00:472A: 1B           	tcs
 15226 00:472B: 0B           	phd
 15227 00:472C: 5B           	tcd
 15228             00000004   path_0	set	4
 15229                        ;	FRESULT res;
 15230                        ;	DIR dj, sdj;
 15231                        ;	DWORD dclst = 0;
 15232                        ;	FATFS *fs;
  Thu May 20 2021 21:37                                                Page 305


 15233                        ;#if FF_FS_EXFAT
 15234                        ;	FFOBJID obj;
 15235                        ;#endif
 15236                        ;	DEF_NAMBUF
 15237                        ;
 15238                        ;
 15239                        ;	/* Get logical drive */
 15240                        ;	res = mount_volume(&path, &fs, FA_WRITE);
 15241             00000000   res_1	set	0
 15242             00000002   dj_1	set	2
 15243             0000002E   sdj_1	set	46
 15244             0000005A   dclst_1	set	90
 15245             0000005E   fs_1	set	94
 15246 00:472D: 64 5B        	stz	<L650+dclst_1
 15247 00:472F: 64 5D        	stz	<L650+dclst_1+2
 15248 00:4731: F4 02 00     	pea	#<$2
 15249 00:4734: F4 00 00     	pea	#0
 15250 00:4737: 18           	clc
 15251 00:4738: 7B           	tdc
 15252 00:4739: 69 5F 00     	adc	#<L650+fs_1
 15253 00:473C: 48           	pha
 15254 00:473D: F4 00 00     	pea	#0
 15255 00:4740: 18           	clc
 15256 00:4741: 7B           	tdc
 15257 00:4742: 69 66 00     	adc	#<L649+path_0
 15258 00:4745: 48           	pha
 15259 00:4746: 22 xx xx xx  	jsl	~~mount_volume
 15260 00:474A: 85 01        	sta	<L650+res_1
 15261                        ;	if (res == FR_OK) {
 15262 00:474C: A5 01        	lda	<L650+res_1
 15263 00:474E: F0 03        	beq	L651
 15264 00:4750: 82 2F 01     	brl	L10367
 15265                        L651:
 15266                        ;		dj.obj.fs = fs;
 15267 00:4753: A5 5F        	lda	<L650+fs_1
 15268 00:4755: 85 03        	sta	<L650+dj_1
 15269 00:4757: A5 61        	lda	<L650+fs_1+2
 15270 00:4759: 85 05        	sta	<L650+dj_1+2
 15271                        ;		INIT_NAMBUF(fs);
 15272                        ;		res = follow_path(&dj, path);		
                    /* Follow the file path */
 15273 00:475B: D4 68        	pei	<L649+path_0+2
 15274 00:475D: D4 66        	pei	<L649+path_0
 15275 00:475F: F4 00 00     	pea	#0
 15276 00:4762: 18           	clc
 15277 00:4763: 7B           	tdc
 15278 00:4764: 69 03 00     	adc	#<L650+dj_1
 15279 00:4767: 48           	pha
 15280 00:4768: 22 xx xx xx  	jsl	~~follow_path
 15281 00:476C: 85 01        	sta	<L650+res_1
 15282                        ;		if (FF_FS_RPATH && res == FR_OK && (dj.f
                    n[NSFLAG] & NS_DOT)) {
 15283 00:476E: 82 19 00     	brl	L10368
 15284 00:4771: A5 01        	lda	<L650+res_1
 15285 00:4773: F0 03        	beq	L652
 15286 00:4775: 82 12 00     	brl	L10368
 15287                        L652:
 15288 00:4778: E2 20        	sep	#$20
  Thu May 20 2021 21:37                                                Page 306


 15289                        	longa	off
 15290 00:477A: A5 2E        	lda	<L650+dj_1+43
 15291 00:477C: 29 20        	and	#<$20
 15292 00:477E: C2 20        	rep	#$20
 15293                        	longa	on
 15294 00:4780: D0 03        	bne	L653
 15295 00:4782: 82 05 00     	brl	L10368
 15296                        L653:
 15297                        ;			res = FR_INVALID_NAME;		
                    	/* Cannot remove dot entry */
 15298 00:4785: A9 06 00     	lda	#$6
 15299 00:4788: 85 01        	sta	<L650+res_1
 15300                        ;		}
 15301                        ;#if FF_FS_LOCK != 0
 15302                        ;		if (res == FR_OK) res = chk_lock(&dj, 2)
                    ;	/* Check if it is an open object */
 15303                        ;#endif
 15304                        ;		if (res == FR_OK) {			
                    		/* The object is accessible */
 15305                        L10368:
 15306 00:478A: A5 01        	lda	<L650+res_1
 15307 00:478C: F0 03        	beq	L654
 15308 00:478E: 82 F1 00     	brl	L10369
 15309                        L654:
 15310                        ;			if (dj.fn[NSFLAG] & NS_NONAME) {
 15311 00:4791: E2 20        	sep	#$20
 15312                        	longa	off
 15313 00:4793: A5 2E        	lda	<L650+dj_1+43
 15314 00:4795: 29 80        	and	#<$80
 15315 00:4797: C2 20        	rep	#$20
 15316                        	longa	on
 15317 00:4799: D0 03        	bne	L655
 15318 00:479B: 82 08 00     	brl	L10370
 15319                        L655:
 15320                        ;				res = FR_INVALID_NAME;	
                    	/* Cannot remove the origin directory */
 15321 00:479E: A9 06 00     	lda	#$6
 15322 00:47A1: 85 01        	sta	<L650+res_1
 15323                        ;			} else {
 15324 00:47A3: 82 12 00     	brl	L10371
 15325                        L10370:
 15326                        ;				if (dj.obj.attr & AM_RDO
                    ) {
 15327 00:47A6: E2 20        	sep	#$20
 15328                        	longa	off
 15329 00:47A8: A5 09        	lda	<L650+dj_1+6
 15330 00:47AA: 29 01        	and	#<$1
 15331 00:47AC: C2 20        	rep	#$20
 15332                        	longa	on
 15333 00:47AE: D0 03        	bne	L656
 15334 00:47B0: 82 05 00     	brl	L10372
 15335                        L656:
 15336                        ;					res = FR_DENIED;
                    		/* Cannot remove R/O object */
 15337 00:47B3: A9 07 00     	lda	#$7
 15338 00:47B6: 85 01        	sta	<L650+res_1
 15339                        ;				}
 15340                        ;			}
  Thu May 20 2021 21:37                                                Page 307


 15341                        L10372:
 15342                        L10371:
 15343                        ;			if (res == FR_OK) {
 15344 00:47B8: A5 01        	lda	<L650+res_1
 15345 00:47BA: F0 03        	beq	L657
 15346 00:47BC: 82 73 00     	brl	L10373
 15347                        L657:
 15348                        ;#if FF_FS_EXFAT
 15349                        ;				obj.fs = fs;
 15350                        ;				if (fs->fs_type == FS_EX
                    FAT) {
 15351                        ;					init_alloc_info(
                    fs, &obj);
 15352                        ;					dclst = obj.sclu
                    st;
 15353                        ;				} else
 15354                        ;#endif
 15355                        ;				{
 15356                        ;					dclst = ld_clust
                    (fs, dj.dir);
 15357 00:47BF: D4 21        	pei	<L650+dj_1+30
 15358 00:47C1: D4 1F        	pei	<L650+dj_1+28
 15359 00:47C3: D4 61        	pei	<L650+fs_1+2
 15360 00:47C5: D4 5F        	pei	<L650+fs_1
 15361 00:47C7: 22 xx xx xx  	jsl	~~ld_clust
 15362 00:47CB: 85 5B        	sta	<L650+dclst_1
 15363 00:47CD: 86 5D        	stx	<L650+dclst_1+2
 15364                        ;				}
 15365                        ;				if (dj.obj.attr & AM_DIR
                    ) {			/* Is it a sub-directory? */
 15366 00:47CF: E2 20        	sep	#$20
 15367                        	longa	off
 15368 00:47D1: A5 09        	lda	<L650+dj_1+6
 15369 00:47D3: 29 10        	and	#<$10
 15370 00:47D5: C2 20        	rep	#$20
 15371                        	longa	on
 15372 00:47D7: D0 03        	bne	L658
 15373 00:47D9: 82 56 00     	brl	L10374
 15374                        L658:
 15375                        ;#if FF_FS_RPATH != 0
 15376                        ;					if (dclst == fs-
                    >cdir) {	 	/* Is it the current directory? */
 15377                        ;						res = FR
                    _DENIED;
 15378                        ;					} else
 15379                        ;#endif
 15380                        ;					{
 15381                        ;						sdj.obj.
                    fs = fs;			/* Open the sub-directory */
 15382 00:47DC: A5 5F        	lda	<L650+fs_1
 15383 00:47DE: 85 2F        	sta	<L650+sdj_1
 15384 00:47E0: A5 61        	lda	<L650+fs_1+2
 15385 00:47E2: 85 31        	sta	<L650+sdj_1+2
 15386                        ;						sdj.obj.
                    sclust = dclst;
 15387 00:47E4: A5 5B        	lda	<L650+dclst_1
 15388 00:47E6: 85 37        	sta	<L650+sdj_1+8
 15389 00:47E8: A5 5D        	lda	<L650+dclst_1+2
  Thu May 20 2021 21:37                                                Page 308


 15390 00:47EA: 85 39        	sta	<L650+sdj_1+10
 15391                        ;#if FF_FS_EXFAT
 15392                        ;						if (fs->
                    fs_type == FS_EXFAT) {
 15393                        ;							
                    sdj.obj.objsize = obj.objsize;
 15394                        ;							
                    sdj.obj.stat = obj.stat;
 15395                        ;						}
 15396                        ;#endif
 15397                        ;						res = di
                    r_sdi(&sdj, 0);
 15398 00:47EC: F4 00 00     	pea	#^$0
 15399 00:47EF: F4 00 00     	pea	#<$0
 15400 00:47F2: F4 00 00     	pea	#0
 15401 00:47F5: 18           	clc
 15402 00:47F6: 7B           	tdc
 15403 00:47F7: 69 2F 00     	adc	#<L650+sdj_1
 15404 00:47FA: 48           	pha
 15405 00:47FB: 22 xx xx xx  	jsl	~~dir_sdi
 15406 00:47FF: 85 01        	sta	<L650+res_1
 15407                        ;						if (res 
                    == FR_OK) {
 15408 00:4801: A5 01        	lda	<L650+res_1
 15409 00:4803: F0 03        	beq	L659
 15410 00:4805: 82 2A 00     	brl	L10375
 15411                        L659:
 15412                        ;							
                    res = DIR_READ_FILE(&sdj);			/* Test if the d
                    irectory is empty */
 15413 00:4808: F4 00 00     	pea	#<$0
 15414 00:480B: F4 00 00     	pea	#0
 15415 00:480E: 18           	clc
 15416 00:480F: 7B           	tdc
 15417 00:4810: 69 2F 00     	adc	#<L650+sdj_1
 15418 00:4813: 48           	pha
 15419 00:4814: 22 xx xx xx  	jsl	~~dir_read
 15420 00:4818: 85 01        	sta	<L650+res_1
 15421                        ;							
                    if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 15422 00:481A: A5 01        	lda	<L650+res_1
 15423 00:481C: F0 03        	beq	L660
 15424 00:481E: 82 05 00     	brl	L10376
 15425                        L660:
 15426 00:4821: A9 07 00     	lda	#$7
 15427 00:4824: 85 01        	sta	<L650+res_1
 15428                        ;							
                    if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 15429                        L10376:
 15430 00:4826: A5 01        	lda	<L650+res_1
 15431 00:4828: C9 04 00     	cmp	#<$4
 15432 00:482B: F0 03        	beq	L661
 15433 00:482D: 82 02 00     	brl	L10377
 15434                        L661:
 15435 00:4830: 64 01        	stz	<L650+res_1
 15436                        ;						}
 15437                        L10377:
 15438                        ;					}
  Thu May 20 2021 21:37                                                Page 309


 15439                        L10375:
 15440                        ;				}
 15441                        ;			}
 15442                        L10374:
 15443                        ;			if (res == FR_OK) {
 15444                        L10373:
 15445 00:4832: A5 01        	lda	<L650+res_1
 15446 00:4834: F0 03        	beq	L662
 15447 00:4836: 82 49 00     	brl	L10378
 15448                        L662:
 15449                        ;				res = dir_remove(&dj);	
                    		/* Remove the directory entry */
 15450 00:4839: F4 00 00     	pea	#0
 15451 00:483C: 18           	clc
 15452 00:483D: 7B           	tdc
 15453 00:483E: 69 03 00     	adc	#<L650+dj_1
 15454 00:4841: 48           	pha
 15455 00:4842: 22 xx xx xx  	jsl	~~dir_remove
 15456 00:4846: 85 01        	sta	<L650+res_1
 15457                        ;				if (res == FR_OK && dcls
                    t != 0) {	/* Remove the cluster chain if exist */
 15458 00:4848: A5 01        	lda	<L650+res_1
 15459 00:484A: F0 03        	beq	L663
 15460 00:484C: 82 22 00     	brl	L10379
 15461                        L663:
 15462 00:484F: A5 5B        	lda	<L650+dclst_1
 15463 00:4851: 05 5D        	ora	<L650+dclst_1+2
 15464 00:4853: D0 03        	bne	L664
 15465 00:4855: 82 19 00     	brl	L10379
 15466                        L664:
 15467                        ;#if FF_FS_EXFAT
 15468                        ;					res = remove_cha
                    in(&obj, dclst, 0);
 15469                        ;#else
 15470                        ;					res = remove_cha
                    in(&dj.obj, dclst, 0);
 15471 00:4858: F4 00 00     	pea	#^$0
 15472 00:485B: F4 00 00     	pea	#<$0
 15473 00:485E: D4 5D        	pei	<L650+dclst_1+2
 15474 00:4860: D4 5B        	pei	<L650+dclst_1
 15475 00:4862: F4 00 00     	pea	#0
 15476 00:4865: 18           	clc
 15477 00:4866: 7B           	tdc
 15478 00:4867: 69 03 00     	adc	#<L650+dj_1
 15479 00:486A: 48           	pha
 15480 00:486B: 22 xx xx xx  	jsl	~~remove_chain
 15481 00:486F: 85 01        	sta	<L650+res_1
 15482                        ;#endif
 15483                        ;				}
 15484                        ;				if (res == FR_OK) res = 
                    sync_fs(fs);
 15485                        L10379:
 15486 00:4871: A5 01        	lda	<L650+res_1
 15487 00:4873: F0 03        	beq	L665
 15488 00:4875: 82 0A 00     	brl	L10380
 15489                        L665:
 15490 00:4878: D4 61        	pei	<L650+fs_1+2
 15491 00:487A: D4 5F        	pei	<L650+fs_1
  Thu May 20 2021 21:37                                                Page 310


 15492 00:487C: 22 xx xx xx  	jsl	~~sync_fs
 15493 00:4880: 85 01        	sta	<L650+res_1
 15494                        ;			}
 15495                        L10380:
 15496                        ;		}
 15497                        L10378:
 15498                        ;		FREE_NAMBUF();
 15499                        L10369:
 15500                        ;	}
 15501                        ;
 15502                        ;	LEAVE_FF(fs, res);
 15503                        L10367:
 15504 00:4882: A5 01        	lda	<L650+res_1
 15505                        L666:
 15506 00:4884: A8           	tay
 15507 00:4885: A5 64        	lda	<L649+2
 15508 00:4887: 85 68        	sta	<L649+2+4
 15509 00:4889: A5 63        	lda	<L649+1
 15510 00:488B: 85 67        	sta	<L649+1+4
 15511 00:488D: 2B           	pld
 15512 00:488E: 3B           	tsc
 15513 00:488F: 18           	clc
 15514 00:4890: 69 66 00     	adc	#L649+4
 15515 00:4893: 1B           	tcs
 15516 00:4894: 98           	tya
 15517 00:4895: 6B           	rtl
 15518                        ;}
 15519             00000062   L649	equ	98
 15520             00000001   L650	equ	1
 15521                        	ends
 15522                        	efunc
 15523                        ;
 15524                        ;
 15525                        ;
 15526                        ;
 15527                        ;/*-----------------------------------------------
                    ------------------------*/
 15528                        ;/* Create a Directory                            
                                            */
 15529                        ;/*-----------------------------------------------
                    ------------------------*/
 15530                        ;
 15531                        ;FRESULT f_mkdir (
 15532                        ;	const TCHAR* path		/* Pointer to th
                    e directory path */
 15533                        ;)
 15534                        ;{
 15535                        	code
 15536                        	xdef	~~f_mkdir
 15537                        	func
 15538                        ~~f_mkdir:
 15539                        	longa	on
 15540                        	longi	on
 15541 00:4896: 3B           	tsc
 15542 00:4897: 38           	sec
 15543 00:4898: E9 56 00     	sbc	#L667
 15544 00:489B: 1B           	tcs
 15545 00:489C: 0B           	phd
  Thu May 20 2021 21:37                                                Page 311


 15546 00:489D: 5B           	tcd
 15547             00000004   path_0	set	4
 15548                        ;	FRESULT res;
 15549                        ;	DIR dj;
 15550                        ;	FFOBJID sobj;
 15551                        ;	FATFS *fs;
 15552                        ;	DWORD dcl, pcl, tm;
 15553                        ;	DEF_NAMBUF
 15554                        ;
 15555                        ;
 15556                        ;	res = mount_volume(&path, &fs, FA_WRITE);	
                    /* Get logical drive */
 15557             00000000   res_1	set	0
 15558             00000002   dj_1	set	2
 15559             0000002E   sobj_1	set	46
 15560             0000003E   fs_1	set	62
 15561             00000042   dcl_1	set	66
 15562             00000046   pcl_1	set	70
 15563             0000004A   tm_1	set	74
 15564 00:489E: F4 02 00     	pea	#<$2
 15565 00:48A1: F4 00 00     	pea	#0
 15566 00:48A4: 18           	clc
 15567 00:48A5: 7B           	tdc
 15568 00:48A6: 69 47 00     	adc	#<L668+fs_1
 15569 00:48A9: 48           	pha
 15570 00:48AA: F4 00 00     	pea	#0
 15571 00:48AD: 18           	clc
 15572 00:48AE: 7B           	tdc
 15573 00:48AF: 69 5A 00     	adc	#<L667+path_0
 15574 00:48B2: 48           	pha
 15575 00:48B3: 22 xx xx xx  	jsl	~~mount_volume
 15576 00:48B7: 85 09        	sta	<L668+res_1
 15577                        ;	if (res == FR_OK) {
 15578 00:48B9: A5 09        	lda	<L668+res_1
 15579 00:48BB: F0 03        	beq	L669
 15580 00:48BD: 82 3A 02     	brl	L10381
 15581                        L669:
 15582                        ;		dj.obj.fs = fs;
 15583 00:48C0: A5 47        	lda	<L668+fs_1
 15584 00:48C2: 85 0B        	sta	<L668+dj_1
 15585 00:48C4: A5 49        	lda	<L668+fs_1+2
 15586 00:48C6: 85 0D        	sta	<L668+dj_1+2
 15587                        ;		INIT_NAMBUF(fs);
 15588                        ;		res = follow_path(&dj, path);		
                    	/* Follow the file path */
 15589 00:48C8: D4 5C        	pei	<L667+path_0+2
 15590 00:48CA: D4 5A        	pei	<L667+path_0
 15591 00:48CC: F4 00 00     	pea	#0
 15592 00:48CF: 18           	clc
 15593 00:48D0: 7B           	tdc
 15594 00:48D1: 69 0B 00     	adc	#<L668+dj_1
 15595 00:48D4: 48           	pha
 15596 00:48D5: 22 xx xx xx  	jsl	~~follow_path
 15597 00:48D9: 85 09        	sta	<L668+res_1
 15598                        ;		if (res == FR_OK) res = FR_EXIST;	
                    	/* Name collision? */
 15599 00:48DB: A5 09        	lda	<L668+res_1
 15600 00:48DD: F0 03        	beq	L670
  Thu May 20 2021 21:37                                                Page 312


 15601 00:48DF: 82 05 00     	brl	L10382
 15602                        L670:
 15603 00:48E2: A9 08 00     	lda	#$8
 15604 00:48E5: 85 09        	sta	<L668+res_1
 15605                        ;		if (FF_FS_RPATH && res == FR_NO_FILE && 
                    (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
 15606                        L10382:
 15607 00:48E7: 82 1C 00     	brl	L10383
 15608 00:48EA: A5 09        	lda	<L668+res_1
 15609 00:48EC: C9 04 00     	cmp	#<$4
 15610 00:48EF: F0 03        	beq	L671
 15611 00:48F1: 82 12 00     	brl	L10383
 15612                        L671:
 15613 00:48F4: E2 20        	sep	#$20
 15614                        	longa	off
 15615 00:48F6: A5 36        	lda	<L668+dj_1+43
 15616 00:48F8: 29 20        	and	#<$20
 15617 00:48FA: C2 20        	rep	#$20
 15618                        	longa	on
 15619 00:48FC: D0 03        	bne	L672
 15620 00:48FE: 82 05 00     	brl	L10383
 15621                        L672:
 15622                        ;			res = FR_INVALID_NAME;
 15623 00:4901: A9 06 00     	lda	#$6
 15624 00:4904: 85 09        	sta	<L668+res_1
 15625                        ;		}
 15626                        ;		if (res == FR_NO_FILE) {		
                    		/* It is clear to create a new directory */
 15627                        L10383:
 15628 00:4906: A5 09        	lda	<L668+res_1
 15629 00:4908: C9 04 00     	cmp	#<$4
 15630 00:490B: F0 03        	beq	L673
 15631 00:490D: 82 EA 01     	brl	L10384
 15632                        L673:
 15633                        ;			sobj.fs = fs;			
                    			/* New object id to create a new chain *
                    /
 15634 00:4910: A5 47        	lda	<L668+fs_1
 15635 00:4912: 85 37        	sta	<L668+sobj_1
 15636 00:4914: A5 49        	lda	<L668+fs_1+2
 15637 00:4916: 85 39        	sta	<L668+sobj_1+2
 15638                        ;			dcl = create_chain(&sobj, 0);	
                    	/* Allocate a cluster for the new directory */
 15639 00:4918: F4 00 00     	pea	#^$0
 15640 00:491B: F4 00 00     	pea	#<$0
 15641 00:491E: F4 00 00     	pea	#0
 15642 00:4921: 18           	clc
 15643 00:4922: 7B           	tdc
 15644 00:4923: 69 37 00     	adc	#<L668+sobj_1
 15645 00:4926: 48           	pha
 15646 00:4927: 22 xx xx xx  	jsl	~~create_chain
 15647 00:492B: 85 4B        	sta	<L668+dcl_1
 15648 00:492D: 86 4D        	stx	<L668+dcl_1+2
 15649                        ;			res = FR_OK;
 15650 00:492F: 64 09        	stz	<L668+res_1
 15651                        ;			if (dcl == 0) res = FR_DENIED;	
                    	/* No space to allocate a new cluster? */
 15652 00:4931: A5 4B        	lda	<L668+dcl_1
  Thu May 20 2021 21:37                                                Page 313


 15653 00:4933: 05 4D        	ora	<L668+dcl_1+2
 15654 00:4935: F0 03        	beq	L674
 15655 00:4937: 82 05 00     	brl	L10385
 15656                        L674:
 15657 00:493A: A9 07 00     	lda	#$7
 15658 00:493D: 85 09        	sta	<L668+res_1
 15659                        ;			if (dcl == 1) res = FR_INT_ERR;	
                    	/* Any insanity? */
 15660                        L10385:
 15661 00:493F: A5 4B        	lda	<L668+dcl_1
 15662 00:4941: C9 01 00     	cmp	#<$1
 15663 00:4944: D0 05        	bne	L675
 15664 00:4946: A5 4D        	lda	<L668+dcl_1+2
 15665 00:4948: C9 00 00     	cmp	#^$1
 15666                        L675:
 15667 00:494B: F0 03        	beq	L676
 15668 00:494D: 82 05 00     	brl	L10386
 15669                        L676:
 15670 00:4950: A9 02 00     	lda	#$2
 15671 00:4953: 85 09        	sta	<L668+res_1
 15672                        ;			if (dcl == 0xFFFFFFFF) res = FR_
                    DISK_ERR;	/* Disk error? */
 15673                        L10386:
 15674 00:4955: A5 4B        	lda	<L668+dcl_1
 15675 00:4957: C9 FF FF     	cmp	#<$ffffffff
 15676 00:495A: D0 05        	bne	L677
 15677 00:495C: A5 4D        	lda	<L668+dcl_1+2
 15678 00:495E: C9 FF FF     	cmp	#^$ffffffff
 15679                        L677:
 15680 00:4961: F0 03        	beq	L678
 15681 00:4963: 82 05 00     	brl	L10387
 15682                        L678:
 15683 00:4966: A9 01 00     	lda	#$1
 15684 00:4969: 85 09        	sta	<L668+res_1
 15685                        ;			tm = GET_FATTIME();
 15686                        L10387:
 15687 00:496B: A9 00 00     	lda	#$0
 15688 00:496E: 85 53        	sta	<L668+tm_1
 15689 00:4970: A9 21 50     	lda	#$5021
 15690 00:4973: 85 55        	sta	<L668+tm_1+2
 15691                        ;			if (res == FR_OK) {
 15692 00:4975: A5 09        	lda	<L668+res_1
 15693 00:4977: F0 03        	beq	L679
 15694 00:4979: 82 0B 01     	brl	L10388
 15695                        L679:
 15696                        ;				res = dir_clear(fs, dcl)
                    ;		/* Clean up the new table */
 15697 00:497C: D4 4D        	pei	<L668+dcl_1+2
 15698 00:497E: D4 4B        	pei	<L668+dcl_1
 15699 00:4980: D4 49        	pei	<L668+fs_1+2
 15700 00:4982: D4 47        	pei	<L668+fs_1
 15701 00:4984: 22 xx xx xx  	jsl	~~dir_clear
 15702 00:4988: 85 09        	sta	<L668+res_1
 15703                        ;				if (res == FR_OK) {
 15704 00:498A: A5 09        	lda	<L668+res_1
 15705 00:498C: F0 03        	beq	L680
 15706 00:498E: 82 F6 00     	brl	L10389
 15707                        L680:
  Thu May 20 2021 21:37                                                Page 314


 15708                        ;					if (!FF_FS_EXFAT
                     || fs->fs_type != FS_EXFAT) {	/* Create dot entries (F
                    AT only) */
 15709 00:4991: 82 0D 00     	brl	L681
 15710 00:4994: E2 20        	sep	#$20
 15711                        	longa	off
 15712 00:4996: A7 47        	lda	[<L668+fs_1]
 15713 00:4998: C9 04        	cmp	#<$4
 15714 00:499A: C2 20        	rep	#$20
 15715                        	longa	on
 15716 00:499C: D0 03        	bne	L682
 15717 00:499E: 82 D7 00     	brl	L10390
 15718                        L682:
 15719                        L681:
 15720                        ;						memset(f
                    s->win + DIR_Name, ' ', 11);	/* Create "." entry */
 15721 00:49A1: F4 0B 00     	pea	#<$b
 15722 00:49A4: F4 20 00     	pea	#<$20
 15723 00:49A7: 18           	clc
 15724 00:49A8: A9 2F 00     	lda	#$2f
 15725 00:49AB: 65 47        	adc	<L668+fs_1
 15726 00:49AD: 85 01        	sta	<R0
 15727 00:49AF: A9 00 00     	lda	#$0
 15728 00:49B2: 65 49        	adc	<L668+fs_1+2
 15729 00:49B4: 85 03        	sta	<R0+2
 15730 00:49B6: D4 03        	pei	<R0+2
 15731 00:49B8: D4 01        	pei	<R0
 15732 00:49BA: 22 xx xx xx  	jsl	~~memset
 15733                        ;						fs->win[
                    DIR_Name] = '.';
 15734 00:49BE: E2 20        	sep	#$20
 15735                        	longa	off
 15736 00:49C0: A9 2E        	lda	#$2e
 15737 00:49C2: A0 2F 00     	ldy	#$2f
 15738 00:49C5: 97 47        	sta	[<L668+fs_1],Y
 15739 00:49C7: C2 20        	rep	#$20
 15740                        	longa	on
 15741                        ;						fs->win[
                    DIR_Attr] = AM_DIR;
 15742 00:49C9: E2 20        	sep	#$20
 15743                        	longa	off
 15744 00:49CB: A9 10        	lda	#$10
 15745 00:49CD: A0 3A 00     	ldy	#$3a
 15746 00:49D0: 97 47        	sta	[<L668+fs_1],Y
 15747 00:49D2: C2 20        	rep	#$20
 15748                        	longa	on
 15749                        ;						st_dword
                    (fs->win + DIR_ModTime, tm);
 15750 00:49D4: D4 55        	pei	<L668+tm_1+2
 15751 00:49D6: D4 53        	pei	<L668+tm_1
 15752 00:49D8: 18           	clc
 15753 00:49D9: A9 45 00     	lda	#$45
 15754 00:49DC: 65 47        	adc	<L668+fs_1
 15755 00:49DE: 85 01        	sta	<R0
 15756 00:49E0: A9 00 00     	lda	#$0
 15757 00:49E3: 65 49        	adc	<L668+fs_1+2
 15758 00:49E5: 85 03        	sta	<R0+2
 15759 00:49E7: D4 03        	pei	<R0+2
  Thu May 20 2021 21:37                                                Page 315


 15760 00:49E9: D4 01        	pei	<R0
 15761 00:49EB: 22 xx xx xx  	jsl	~~st_dword
 15762                        ;						st_clust
                    (fs, fs->win, dcl);
 15763 00:49EF: D4 4D        	pei	<L668+dcl_1+2
 15764 00:49F1: D4 4B        	pei	<L668+dcl_1
 15765 00:49F3: 18           	clc
 15766 00:49F4: A9 2F 00     	lda	#$2f
 15767 00:49F7: 65 47        	adc	<L668+fs_1
 15768 00:49F9: 85 01        	sta	<R0
 15769 00:49FB: A9 00 00     	lda	#$0
 15770 00:49FE: 65 49        	adc	<L668+fs_1+2
 15771 00:4A00: 85 03        	sta	<R0+2
 15772 00:4A02: D4 03        	pei	<R0+2
 15773 00:4A04: D4 01        	pei	<R0
 15774 00:4A06: D4 49        	pei	<L668+fs_1+2
 15775 00:4A08: D4 47        	pei	<L668+fs_1
 15776 00:4A0A: 22 xx xx xx  	jsl	~~st_clust
 15777                        ;						memcpy(f
                    s->win + SZDIRE, fs->win, SZDIRE);	/* Create ".." entry */
 15778 00:4A0E: F4 20 00     	pea	#<$20
 15779 00:4A11: 18           	clc
 15780 00:4A12: A9 2F 00     	lda	#$2f
 15781 00:4A15: 65 47        	adc	<L668+fs_1
 15782 00:4A17: 85 01        	sta	<R0
 15783 00:4A19: A9 00 00     	lda	#$0
 15784 00:4A1C: 65 49        	adc	<L668+fs_1+2
 15785 00:4A1E: 85 03        	sta	<R0+2
 15786 00:4A20: D4 03        	pei	<R0+2
 15787 00:4A22: D4 01        	pei	<R0
 15788 00:4A24: 18           	clc
 15789 00:4A25: A9 4F 00     	lda	#$4f
 15790 00:4A28: 65 47        	adc	<L668+fs_1
 15791 00:4A2A: 85 05        	sta	<R1
 15792 00:4A2C: A9 00 00     	lda	#$0
 15793 00:4A2F: 65 49        	adc	<L668+fs_1+2
 15794 00:4A31: 85 07        	sta	<R1+2
 15795 00:4A33: D4 07        	pei	<R1+2
 15796 00:4A35: D4 05        	pei	<R1
 15797 00:4A37: 22 xx xx xx  	jsl	~~memcpy
 15798                        ;						fs->win[
                    SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 15799 00:4A3B: E2 20        	sep	#$20
 15800                        	longa	off
 15801 00:4A3D: A9 2E        	lda	#$2e
 15802 00:4A3F: A0 50 00     	ldy	#$50
 15803 00:4A42: 97 47        	sta	[<L668+fs_1],Y
 15804 00:4A44: C2 20        	rep	#$20
 15805                        	longa	on
 15806 00:4A46: A5 13        	lda	<L668+dj_1+8
 15807 00:4A48: 85 4F        	sta	<L668+pcl_1
 15808 00:4A4A: A5 15        	lda	<L668+dj_1+10
 15809 00:4A4C: 85 51        	sta	<L668+pcl_1+2
 15810                        ;						st_clust
                    (fs, fs->win + SZDIRE, pcl);
 15811 00:4A4E: D4 51        	pei	<L668+pcl_1+2
 15812 00:4A50: D4 4F        	pei	<L668+pcl_1
 15813 00:4A52: 18           	clc
  Thu May 20 2021 21:37                                                Page 316


 15814 00:4A53: A9 4F 00     	lda	#$4f
 15815 00:4A56: 65 47        	adc	<L668+fs_1
 15816 00:4A58: 85 01        	sta	<R0
 15817 00:4A5A: A9 00 00     	lda	#$0
 15818 00:4A5D: 65 49        	adc	<L668+fs_1+2
 15819 00:4A5F: 85 03        	sta	<R0+2
 15820 00:4A61: D4 03        	pei	<R0+2
 15821 00:4A63: D4 01        	pei	<R0
 15822 00:4A65: D4 49        	pei	<L668+fs_1+2
 15823 00:4A67: D4 47        	pei	<L668+fs_1
 15824 00:4A69: 22 xx xx xx  	jsl	~~st_clust
 15825                        ;						fs->wfla
                    g = 1;
 15826 00:4A6D: E2 20        	sep	#$20
 15827                        	longa	off
 15828 00:4A6F: A9 01        	lda	#$1
 15829 00:4A71: A0 03 00     	ldy	#$3
 15830 00:4A74: 97 47        	sta	[<L668+fs_1],Y
 15831 00:4A76: C2 20        	rep	#$20
 15832                        	longa	on
 15833                        ;					}
 15834                        ;					res = dir_regist
                    er(&dj);	/* Register the object to the parent directoy */
 15835                        L10390:
 15836 00:4A78: F4 00 00     	pea	#0
 15837 00:4A7B: 18           	clc
 15838 00:4A7C: 7B           	tdc
 15839 00:4A7D: 69 0B 00     	adc	#<L668+dj_1
 15840 00:4A80: 48           	pha
 15841 00:4A81: 22 xx xx xx  	jsl	~~dir_register
 15842 00:4A85: 85 09        	sta	<L668+res_1
 15843                        ;				}
 15844                        ;			}
 15845                        L10389:
 15846                        ;			if (res == FR_OK) {
 15847                        L10388:
 15848 00:4A87: A5 09        	lda	<L668+res_1
 15849 00:4A89: F0 03        	beq	L683
 15850 00:4A8B: 82 55 00     	brl	L10391
 15851                        L683:
 15852                        ;#if FF_FS_EXFAT
 15853                        ;				if (fs->fs_type == FS_EX
                    FAT) {	/* Initialize directory entry block */
 15854                        ;					st_dword(fs->dir
                    buf + XDIR_ModTime, tm);	/* Created time */
 15855                        ;					st_dword(fs->dir
                    buf + XDIR_FstClus, dcl);	/* Table start cluster */
 15856                        ;					st_dword(fs->dir
                    buf + XDIR_FileSize, (DWORD)fs->csize * SS(fs));	/* Direc
                    tory size needs to be valid */
 15857                        ;					st_dword(fs->dir
                    buf + XDIR_ValidFileSize, (DWORD)fs->csize * SS(fs));
 15858                        ;					fs->dirbuf[XDIR_
                    GenFlags] = 3;				/* Initialize th
                    e object flag */
 15859                        ;					fs->dirbuf[XDIR_
                    Attr] = AM_DIR;				/* Attribute */
 15860                        ;					res = store_xdir
  Thu May 20 2021 21:37                                                Page 317


                    (&dj);
 15861                        ;				} else
 15862                        ;#endif
 15863                        ;				{
 15864                        ;					st_dword(dj.dir 
                    + DIR_ModTime, tm);	/* Created time */
 15865 00:4A8E: D4 55        	pei	<L668+tm_1+2
 15866 00:4A90: D4 53        	pei	<L668+tm_1
 15867 00:4A92: 18           	clc
 15868 00:4A93: A9 16 00     	lda	#$16
 15869 00:4A96: 65 27        	adc	<L668+dj_1+28
 15870 00:4A98: 85 01        	sta	<R0
 15871 00:4A9A: A9 00 00     	lda	#$0
 15872 00:4A9D: 65 29        	adc	<L668+dj_1+30
 15873 00:4A9F: 85 03        	sta	<R0+2
 15874 00:4AA1: D4 03        	pei	<R0+2
 15875 00:4AA3: D4 01        	pei	<R0
 15876 00:4AA5: 22 xx xx xx  	jsl	~~st_dword
 15877                        ;					st_clust(fs, dj.
                    dir, dcl);			/* Table start cluster */
 15878 00:4AA9: D4 4D        	pei	<L668+dcl_1+2
 15879 00:4AAB: D4 4B        	pei	<L668+dcl_1
 15880 00:4AAD: D4 29        	pei	<L668+dj_1+30
 15881 00:4AAF: D4 27        	pei	<L668+dj_1+28
 15882 00:4AB1: D4 49        	pei	<L668+fs_1+2
 15883 00:4AB3: D4 47        	pei	<L668+fs_1
 15884 00:4AB5: 22 xx xx xx  	jsl	~~st_clust
 15885                        ;					dj.dir[DIR_Attr]
                     = AM_DIR;			/* Attribute */
 15886 00:4AB9: E2 20        	sep	#$20
 15887                        	longa	off
 15888 00:4ABB: A9 10        	lda	#$10
 15889 00:4ABD: A0 0B 00     	ldy	#$b
 15890 00:4AC0: 97 27        	sta	[<L668+dj_1+28],Y
 15891 00:4AC2: C2 20        	rep	#$20
 15892                        	longa	on
 15893                        ;					fs->wflag = 1;
 15894 00:4AC4: E2 20        	sep	#$20
 15895                        	longa	off
 15896 00:4AC6: A9 01        	lda	#$1
 15897 00:4AC8: A0 03 00     	ldy	#$3
 15898 00:4ACB: 97 47        	sta	[<L668+fs_1],Y
 15899 00:4ACD: C2 20        	rep	#$20
 15900                        	longa	on
 15901                        ;				}
 15902                        ;				if (res == FR_OK) {
 15903 00:4ACF: A5 09        	lda	<L668+res_1
 15904 00:4AD1: F0 03        	beq	L684
 15905 00:4AD3: 82 0A 00     	brl	L10392
 15906                        L684:
 15907                        ;					res = sync_fs(fs
                    );
 15908 00:4AD6: D4 49        	pei	<L668+fs_1+2
 15909 00:4AD8: D4 47        	pei	<L668+fs_1
 15910 00:4ADA: 22 xx xx xx  	jsl	~~sync_fs
 15911 00:4ADE: 85 09        	sta	<L668+res_1
 15912                        ;				}
 15913                        ;			} else {
  Thu May 20 2021 21:37                                                Page 318


 15914                        L10392:
 15915 00:4AE0: 82 17 00     	brl	L10393
 15916                        L10391:
 15917                        ;				remove_chain(&sobj, dcl,
                     0);		/* Could not register, remove the alloca
                    ted cluster */
 15918 00:4AE3: F4 00 00     	pea	#^$0
 15919 00:4AE6: F4 00 00     	pea	#<$0
 15920 00:4AE9: D4 4D        	pei	<L668+dcl_1+2
 15921 00:4AEB: D4 4B        	pei	<L668+dcl_1
 15922 00:4AED: F4 00 00     	pea	#0
 15923 00:4AF0: 18           	clc
 15924 00:4AF1: 7B           	tdc
 15925 00:4AF2: 69 37 00     	adc	#<L668+sobj_1
 15926 00:4AF5: 48           	pha
 15927 00:4AF6: 22 xx xx xx  	jsl	~~remove_chain
 15928                        ;			}
 15929                        L10393:
 15930                        ;		}
 15931                        ;		FREE_NAMBUF();
 15932                        L10384:
 15933                        ;	}
 15934                        ;
 15935                        ;	LEAVE_FF(fs, res);
 15936                        L10381:
 15937 00:4AFA: A5 09        	lda	<L668+res_1
 15938                        L685:
 15939 00:4AFC: A8           	tay
 15940 00:4AFD: A5 58        	lda	<L667+2
 15941 00:4AFF: 85 5C        	sta	<L667+2+4
 15942 00:4B01: A5 57        	lda	<L667+1
 15943 00:4B03: 85 5B        	sta	<L667+1+4
 15944 00:4B05: 2B           	pld
 15945 00:4B06: 3B           	tsc
 15946 00:4B07: 18           	clc
 15947 00:4B08: 69 5A 00     	adc	#L667+4
 15948 00:4B0B: 1B           	tcs
 15949 00:4B0C: 98           	tya
 15950 00:4B0D: 6B           	rtl
 15951                        ;}
 15952             00000056   L667	equ	86
 15953             00000009   L668	equ	9
 15954                        	ends
 15955                        	efunc
 15956                        ;
 15957                        ;
 15958                        ;
 15959                        ;
 15960                        ;/*-----------------------------------------------
                    ------------------------*/
 15961                        ;/* Rename a File/Directory                       
                                            */
 15962                        ;/*-----------------------------------------------
                    ------------------------*/
 15963                        ;
 15964                        ;FRESULT f_rename (
 15965                        ;	const TCHAR* path_old,	/* Pointer to the object
                     name to be renamed */
  Thu May 20 2021 21:37                                                Page 319


 15966                        ;	const TCHAR* path_new	/* Pointer to the new na
                    me */
 15967                        ;)
 15968                        ;{
 15969                        	code
 15970                        	xdef	~~f_rename
 15971                        	func
 15972                        ~~f_rename:
 15973                        	longa	on
 15974                        	longi	on
 15975 00:4B0E: 3B           	tsc
 15976 00:4B0F: 38           	sec
 15977 00:4B10: E9 8A 00     	sbc	#L686
 15978 00:4B13: 1B           	tcs
 15979 00:4B14: 0B           	phd
 15980 00:4B15: 5B           	tcd
 15981             00000004   path_old_0	set	4
 15982             00000008   path_new_0	set	8
 15983                        ;	FRESULT res;
 15984                        ;	DIR djo, djn;
 15985                        ;	FATFS *fs;
 15986                        ;	BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *di
                    r;
 15987                        ;	LBA_t sect;
 15988                        ;	DEF_NAMBUF
 15989                        ;
 15990                        ;
 15991                        ;	get_ldnumber(&path_new);			
                    			/* Snip the drive number of new name off
                     */
 15992             00000000   res_1	set	0
 15993             00000002   djo_1	set	2
 15994             0000002E   djn_1	set	46
 15995             0000005A   fs_1	set	90
 15996             0000005E   buf_1	set	94
 15997             0000007E   dir_1	set	126
 15998             00000082   sect_1	set	130
 15999 00:4B16: F4 00 00     	pea	#0
 16000 00:4B19: 18           	clc
 16001 00:4B1A: 7B           	tdc
 16002 00:4B1B: 69 92 00     	adc	#<L686+path_new_0
 16003 00:4B1E: 48           	pha
 16004 00:4B1F: 22 xx xx xx  	jsl	~~get_ldnumber
 16005                        ;	res = mount_volume(&path_old, &fs, FA_WRITE);	
                    /* Get logical drive of the old object */
 16006 00:4B23: F4 02 00     	pea	#<$2
 16007 00:4B26: F4 00 00     	pea	#0
 16008 00:4B29: 18           	clc
 16009 00:4B2A: 7B           	tdc
 16010 00:4B2B: 69 5F 00     	adc	#<L687+fs_1
 16011 00:4B2E: 48           	pha
 16012 00:4B2F: F4 00 00     	pea	#0
 16013 00:4B32: 18           	clc
 16014 00:4B33: 7B           	tdc
 16015 00:4B34: 69 8E 00     	adc	#<L686+path_old_0
 16016 00:4B37: 48           	pha
 16017 00:4B38: 22 xx xx xx  	jsl	~~mount_volume
 16018 00:4B3C: 85 05        	sta	<L687+res_1
  Thu May 20 2021 21:37                                                Page 320


 16019                        ;	if (res == FR_OK) {
 16020 00:4B3E: A5 05        	lda	<L687+res_1
 16021 00:4B40: F0 03        	beq	L688
 16022 00:4B42: 82 F8 01     	brl	L10394
 16023                        L688:
 16024                        ;		djo.obj.fs = fs;
 16025 00:4B45: A5 5F        	lda	<L687+fs_1
 16026 00:4B47: 85 07        	sta	<L687+djo_1
 16027 00:4B49: A5 61        	lda	<L687+fs_1+2
 16028 00:4B4B: 85 09        	sta	<L687+djo_1+2
 16029                        ;		INIT_NAMBUF(fs);
 16030                        ;		res = follow_path(&djo, path_old);	
                    		/* Check old object */
 16031 00:4B4D: D4 90        	pei	<L686+path_old_0+2
 16032 00:4B4F: D4 8E        	pei	<L686+path_old_0
 16033 00:4B51: F4 00 00     	pea	#0
 16034 00:4B54: 18           	clc
 16035 00:4B55: 7B           	tdc
 16036 00:4B56: 69 07 00     	adc	#<L687+djo_1
 16037 00:4B59: 48           	pha
 16038 00:4B5A: 22 xx xx xx  	jsl	~~follow_path
 16039 00:4B5E: 85 05        	sta	<L687+res_1
 16040                        ;		if (res == FR_OK && (djo.fn[NSFLAG] & (N
                    S_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validit
                    y of name */
 16041 00:4B60: A5 05        	lda	<L687+res_1
 16042 00:4B62: F0 03        	beq	L689
 16043 00:4B64: 82 12 00     	brl	L10395
 16044                        L689:
 16045 00:4B67: E2 20        	sep	#$20
 16046                        	longa	off
 16047 00:4B69: A5 32        	lda	<L687+djo_1+43
 16048 00:4B6B: 29 A0        	and	#<$a0
 16049 00:4B6D: C2 20        	rep	#$20
 16050                        	longa	on
 16051 00:4B6F: D0 03        	bne	L690
 16052 00:4B71: 82 05 00     	brl	L10395
 16053                        L690:
 16054 00:4B74: A9 06 00     	lda	#$6
 16055 00:4B77: 85 05        	sta	<L687+res_1
 16056                        ;#if FF_FS_LOCK != 0
 16057                        ;		if (res == FR_OK) {
 16058                        ;			res = chk_lock(&djo, 2);
 16059                        ;		}
 16060                        ;#endif
 16061                        ;		if (res == FR_OK) {			
                    		/* Object to be renamed is found */
 16062                        L10395:
 16063 00:4B79: A5 05        	lda	<L687+res_1
 16064 00:4B7B: F0 03        	beq	L691
 16065 00:4B7D: 82 BD 01     	brl	L10396
 16066                        L691:
 16067                        ;#if FF_FS_EXFAT
 16068                        ;			if (fs->fs_type == FS_EXFAT) {	
                    /* At exFAT volume */
 16069                        ;				BYTE nf, nn;
 16070                        ;				WORD nh;
 16071                        ;
  Thu May 20 2021 21:37                                                Page 321


 16072                        ;				memcpy(buf, fs->dirbuf, 
                    SZDIRE * 2);	/* Save 85+C0 entry of old object */
 16073                        ;				memcpy(&djn, &djo, sizeo
                    f djo);
 16074                        ;				res = follow_path(&djn, 
                    path_new);		/* Make sure if new object name is not i
                    n use */
 16075                        ;				if (res == FR_OK) {	
                    					/* Is new name already i
                    n use by any other object? */
 16076                        ;					res = (djn.obj.s
                    clust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FIL
                    E : FR_EXIST;
 16077                        ;				}
 16078                        ;				if (res == FR_NO_FILE) {
                     				/* It is a valid path and no nam
                    e collision */
 16079                        ;					res = dir_regist
                    er(&djn);			/* Register the new entry */
 16080                        ;					if (res == FR_OK
                    ) {
 16081                        ;						nf = fs-
                    >dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
 16082                        ;						nh = ld_
                    word(fs->dirbuf + XDIR_NameHash);
 16083                        ;						memcpy(f
                    s->dirbuf, buf, SZDIRE * 2);	/* Restore 85+C0 entry *
                    /
 16084                        ;						fs->dirb
                    uf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
 16085                        ;						st_word(
                    fs->dirbuf + XDIR_NameHash, nh);
 16086                        ;						if (!(fs
                    ->dirbuf[XDIR_Attr] & AM_DIR)) fs->dirbuf[XDIR_Attr] |= AM_A
                    RC;	/* Set archive attribute if it is a file */
 16087                        ;/* Start of critical section where an interruptio
                    n can cause a cross-link */
 16088                        ;						res = st
                    ore_xdir(&djn);
 16089                        ;					}
 16090                        ;				}
 16091                        ;			} else
 16092                        ;#endif
 16093                        ;			{	/* At FAT/FAT32 volume *
                    /
 16094                        ;				memcpy(buf, djo.dir, SZD
                    IRE);			/* Save directory entry of the o
                    bject */
 16095 00:4B80: F4 20 00     	pea	#<$20
 16096 00:4B83: D4 25        	pei	<L687+djo_1+30
 16097 00:4B85: D4 23        	pei	<L687+djo_1+28
 16098 00:4B87: F4 00 00     	pea	#0
 16099 00:4B8A: 18           	clc
 16100 00:4B8B: 7B           	tdc
 16101 00:4B8C: 69 63 00     	adc	#<L687+buf_1
 16102 00:4B8F: 48           	pha
 16103 00:4B90: 22 xx xx xx  	jsl	~~memcpy
 16104                        ;				memcpy(&djn, &djo, sizeo
  Thu May 20 2021 21:37                                                Page 322


                    f (DIR));		/* Duplicate the directory object */
 16105 00:4B94: F4 2C 00     	pea	#<$2c
 16106 00:4B97: F4 00 00     	pea	#0
 16107 00:4B9A: 18           	clc
 16108 00:4B9B: 7B           	tdc
 16109 00:4B9C: 69 07 00     	adc	#<L687+djo_1
 16110 00:4B9F: 48           	pha
 16111 00:4BA0: F4 00 00     	pea	#0
 16112 00:4BA3: 18           	clc
 16113 00:4BA4: 7B           	tdc
 16114 00:4BA5: 69 33 00     	adc	#<L687+djn_1
 16115 00:4BA8: 48           	pha
 16116 00:4BA9: 22 xx xx xx  	jsl	~~memcpy
 16117                        ;				res = follow_path(&djn, 
                    path_new);		/* Make sure if new object name is not i
                    n use */
 16118 00:4BAD: D4 94        	pei	<L686+path_new_0+2
 16119 00:4BAF: D4 92        	pei	<L686+path_new_0
 16120 00:4BB1: F4 00 00     	pea	#0
 16121 00:4BB4: 18           	clc
 16122 00:4BB5: 7B           	tdc
 16123 00:4BB6: 69 33 00     	adc	#<L687+djn_1
 16124 00:4BB9: 48           	pha
 16125 00:4BBA: 22 xx xx xx  	jsl	~~follow_path
 16126 00:4BBE: 85 05        	sta	<L687+res_1
 16127                        ;				if (res == FR_OK) {	
                    					/* Is new name already i
                    n use by any other object? */
 16128 00:4BC0: A5 05        	lda	<L687+res_1
 16129 00:4BC2: F0 03        	beq	L692
 16130 00:4BC4: 82 28 00     	brl	L10397
 16131                        L692:
 16132                        ;					res = (djn.obj.s
                    clust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FIL
                    E : FR_EXIST;
 16133 00:4BC7: A5 3B        	lda	<L687+djn_1+8
 16134 00:4BC9: C5 0F        	cmp	<L687+djo_1+8
 16135 00:4BCB: D0 04        	bne	L694
 16136 00:4BCD: A5 3D        	lda	<L687+djn_1+10
 16137 00:4BCF: C5 11        	cmp	<L687+djo_1+10
 16138                        L694:
 16139 00:4BD1: F0 03        	beq	L695
 16140 00:4BD3: 82 14 00     	brl	L693
 16141                        L695:
 16142 00:4BD6: A5 43        	lda	<L687+djn_1+16
 16143 00:4BD8: C5 17        	cmp	<L687+djo_1+16
 16144 00:4BDA: D0 04        	bne	L696
 16145 00:4BDC: A5 45        	lda	<L687+djn_1+18
 16146 00:4BDE: C5 19        	cmp	<L687+djo_1+18
 16147                        L696:
 16148 00:4BE0: F0 03        	beq	L697
 16149 00:4BE2: 82 05 00     	brl	L693
 16150                        L697:
 16151 00:4BE5: A9 04 00     	lda	#$4
 16152 00:4BE8: 80 03        	bra	L698
 16153                        L693:
 16154 00:4BEA: A9 08 00     	lda	#$8
 16155                        L698:
  Thu May 20 2021 21:37                                                Page 323


 16156 00:4BED: 85 05        	sta	<L687+res_1
 16157                        ;				}
 16158                        ;				if (res == FR_NO_FILE) {
                     				/* It is a valid path and no nam
                    e collision */
 16159                        L10397:
 16160 00:4BEF: A5 05        	lda	<L687+res_1
 16161 00:4BF1: C9 04 00     	cmp	#<$4
 16162 00:4BF4: F0 03        	beq	L699
 16163 00:4BF6: 82 1D 01     	brl	L10398
 16164                        L699:
 16165                        ;					res = dir_regist
                    er(&djn);			/* Register the new entry */
 16166 00:4BF9: F4 00 00     	pea	#0
 16167 00:4BFC: 18           	clc
 16168 00:4BFD: 7B           	tdc
 16169 00:4BFE: 69 33 00     	adc	#<L687+djn_1
 16170 00:4C01: 48           	pha
 16171 00:4C02: 22 xx xx xx  	jsl	~~dir_register
 16172 00:4C06: 85 05        	sta	<L687+res_1
 16173                        ;					if (res == FR_OK
                    ) {
 16174 00:4C08: A5 05        	lda	<L687+res_1
 16175 00:4C0A: F0 03        	beq	L700
 16176 00:4C0C: 82 07 01     	brl	L10399
 16177                        L700:
 16178                        ;						dir = dj
                    n.dir;					/* Copy director
                    y entry of the object except name */
 16179 00:4C0F: A5 4F        	lda	<L687+djn_1+28
 16180 00:4C11: 85 83        	sta	<L687+dir_1
 16181 00:4C13: A5 51        	lda	<L687+djn_1+30
 16182 00:4C15: 85 85        	sta	<L687+dir_1+2
 16183                        ;						memcpy(d
                    ir + 13, buf + 13, SZDIRE - 13);
 16184 00:4C17: F4 13 00     	pea	#<$13
 16185 00:4C1A: F4 00 00     	pea	#0
 16186 00:4C1D: 18           	clc
 16187 00:4C1E: 7B           	tdc
 16188 00:4C1F: 69 70 00     	adc	#<L687+buf_1+13
 16189 00:4C22: 48           	pha
 16190 00:4C23: 18           	clc
 16191 00:4C24: A9 0D 00     	lda	#$d
 16192 00:4C27: 65 83        	adc	<L687+dir_1
 16193 00:4C29: 85 01        	sta	<R0
 16194 00:4C2B: A9 00 00     	lda	#$0
 16195 00:4C2E: 65 85        	adc	<L687+dir_1+2
 16196 00:4C30: 85 03        	sta	<R0+2
 16197 00:4C32: D4 03        	pei	<R0+2
 16198 00:4C34: D4 01        	pei	<R0
 16199 00:4C36: 22 xx xx xx  	jsl	~~memcpy
 16200                        ;						dir[DIR_
                    Attr] = buf[DIR_Attr];
 16201 00:4C3A: E2 20        	sep	#$20
 16202                        	longa	off
 16203 00:4C3C: A5 6E        	lda	<L687+buf_1+11
 16204 00:4C3E: A0 0B 00     	ldy	#$b
 16205 00:4C41: 97 83        	sta	[<L687+dir_1],Y
  Thu May 20 2021 21:37                                                Page 324


 16206 00:4C43: C2 20        	rep	#$20
 16207                        	longa	on
 16208                        ;						if (!(di
                    r[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set a
                    rchive attribute if it is a file */
 16209 00:4C45: E2 20        	sep	#$20
 16210                        	longa	off
 16211 00:4C47: A0 0B 00     	ldy	#$b
 16212 00:4C4A: B7 83        	lda	[<L687+dir_1],Y
 16213 00:4C4C: 29 10        	and	#<$10
 16214 00:4C4E: C2 20        	rep	#$20
 16215                        	longa	on
 16216 00:4C50: F0 03        	beq	L701
 16217 00:4C52: 82 19 00     	brl	L10400
 16218                        L701:
 16219 00:4C55: 18           	clc
 16220 00:4C56: A9 0B 00     	lda	#$b
 16221 00:4C59: 65 83        	adc	<L687+dir_1
 16222 00:4C5B: 85 01        	sta	<R0
 16223 00:4C5D: A9 00 00     	lda	#$0
 16224 00:4C60: 65 85        	adc	<L687+dir_1+2
 16225 00:4C62: 85 03        	sta	<R0+2
 16226 00:4C64: E2 20        	sep	#$20
 16227                        	longa	off
 16228 00:4C66: A7 01        	lda	[<R0]
 16229 00:4C68: 09 20        	ora	#<$20
 16230 00:4C6A: 87 01        	sta	[<R0]
 16231 00:4C6C: C2 20        	rep	#$20
 16232                        	longa	on
 16233                        ;						fs->wfla
                    g = 1;
 16234                        L10400:
 16235 00:4C6E: E2 20        	sep	#$20
 16236                        	longa	off
 16237 00:4C70: A9 01        	lda	#$1
 16238 00:4C72: A0 03 00     	ldy	#$3
 16239 00:4C75: 97 5F        	sta	[<L687+fs_1],Y
 16240 00:4C77: C2 20        	rep	#$20
 16241                        	longa	on
 16242                        ;						if ((dir
                    [DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	
                    /* Update .. entry in the sub-directory if needed */
 16243 00:4C79: E2 20        	sep	#$20
 16244                        	longa	off
 16245 00:4C7B: A0 0B 00     	ldy	#$b
 16246 00:4C7E: B7 83        	lda	[<L687+dir_1],Y
 16247 00:4C80: 29 10        	and	#<$10
 16248 00:4C82: C2 20        	rep	#$20
 16249                        	longa	on
 16250 00:4C84: D0 03        	bne	L702
 16251 00:4C86: 82 8D 00     	brl	L10401
 16252                        L702:
 16253 00:4C89: A5 0F        	lda	<L687+djo_1+8
 16254 00:4C8B: C5 3B        	cmp	<L687+djn_1+8
 16255 00:4C8D: D0 04        	bne	L703
 16256 00:4C8F: A5 11        	lda	<L687+djo_1+10
 16257 00:4C91: C5 3D        	cmp	<L687+djn_1+10
 16258                        L703:
  Thu May 20 2021 21:37                                                Page 325


 16259 00:4C93: D0 03        	bne	L704
 16260 00:4C95: 82 7E 00     	brl	L10401
 16261                        L704:
 16262                        ;							
                    sect = clst2sect(fs, ld_clust(fs, dir));
 16263 00:4C98: D4 85        	pei	<L687+dir_1+2
 16264 00:4C9A: D4 83        	pei	<L687+dir_1
 16265 00:4C9C: D4 61        	pei	<L687+fs_1+2
 16266 00:4C9E: D4 5F        	pei	<L687+fs_1
 16267 00:4CA0: 22 xx xx xx  	jsl	~~ld_clust
 16268 00:4CA4: 85 01        	sta	<R0
 16269 00:4CA6: 86 03        	stx	<R0+2
 16270 00:4CA8: DA           	phx
 16271 00:4CA9: 48           	pha
 16272 00:4CAA: D4 61        	pei	<L687+fs_1+2
 16273 00:4CAC: D4 5F        	pei	<L687+fs_1
 16274 00:4CAE: 22 xx xx xx  	jsl	~~clst2sect
 16275 00:4CB2: 85 87        	sta	<L687+sect_1
 16276 00:4CB4: 86 89        	stx	<L687+sect_1+2
 16277                        ;							
                    if (sect == 0) {
 16278 00:4CB6: A5 87        	lda	<L687+sect_1
 16279 00:4CB8: 05 89        	ora	<L687+sect_1+2
 16280 00:4CBA: F0 03        	beq	L705
 16281 00:4CBC: 82 08 00     	brl	L10402
 16282                        L705:
 16283                        ;							
                    	res = FR_INT_ERR;
 16284 00:4CBF: A9 02 00     	lda	#$2
 16285 00:4CC2: 85 05        	sta	<L687+res_1
 16286                        ;							
                    } else {
 16287 00:4CC4: 82 4F 00     	brl	L10403
 16288                        L10402:
 16289                        ;/* Start of critical section where an interruptio
                    n can cause a cross-link */
 16290                        ;							
                    	res = move_window(fs, sect);
 16291 00:4CC7: D4 89        	pei	<L687+sect_1+2
 16292 00:4CC9: D4 87        	pei	<L687+sect_1
 16293 00:4CCB: D4 61        	pei	<L687+fs_1+2
 16294 00:4CCD: D4 5F        	pei	<L687+fs_1
 16295 00:4CCF: 22 xx xx xx  	jsl	~~move_window
 16296 00:4CD3: 85 05        	sta	<L687+res_1
 16297                        ;							
                    	dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
 16298 00:4CD5: 18           	clc
 16299 00:4CD6: A9 4F 00     	lda	#$4f
 16300 00:4CD9: 65 5F        	adc	<L687+fs_1
 16301 00:4CDB: 85 83        	sta	<L687+dir_1
 16302 00:4CDD: A9 00 00     	lda	#$0
 16303 00:4CE0: 65 61        	adc	<L687+fs_1+2
 16304 00:4CE2: 85 85        	sta	<L687+dir_1+2
 16305                        ;							
                    	if (res == FR_OK && dir[1] == '.') {
 16306 00:4CE4: A5 05        	lda	<L687+res_1
 16307 00:4CE6: F0 03        	beq	L706
 16308 00:4CE8: 82 2B 00     	brl	L10404
  Thu May 20 2021 21:37                                                Page 326


 16309                        L706:
 16310 00:4CEB: E2 20        	sep	#$20
 16311                        	longa	off
 16312 00:4CED: A0 01 00     	ldy	#$1
 16313 00:4CF0: B7 83        	lda	[<L687+dir_1],Y
 16314 00:4CF2: C9 2E        	cmp	#<$2e
 16315 00:4CF4: C2 20        	rep	#$20
 16316                        	longa	on
 16317 00:4CF6: F0 03        	beq	L707
 16318 00:4CF8: 82 1B 00     	brl	L10404
 16319                        L707:
 16320                        ;							
                    		st_clust(fs, dir, djn.obj.sclust);
 16321 00:4CFB: D4 3D        	pei	<L687+djn_1+10
 16322 00:4CFD: D4 3B        	pei	<L687+djn_1+8
 16323 00:4CFF: D4 85        	pei	<L687+dir_1+2
 16324 00:4D01: D4 83        	pei	<L687+dir_1
 16325 00:4D03: D4 61        	pei	<L687+fs_1+2
 16326 00:4D05: D4 5F        	pei	<L687+fs_1
 16327 00:4D07: 22 xx xx xx  	jsl	~~st_clust
 16328                        ;							
                    		fs->wflag = 1;
 16329 00:4D0B: E2 20        	sep	#$20
 16330                        	longa	off
 16331 00:4D0D: A9 01        	lda	#$1
 16332 00:4D0F: A0 03 00     	ldy	#$3
 16333 00:4D12: 97 5F        	sta	[<L687+fs_1],Y
 16334 00:4D14: C2 20        	rep	#$20
 16335                        	longa	on
 16336                        ;							
                    	}
 16337                        ;							
                    }
 16338                        L10404:
 16339                        L10403:
 16340                        ;						}
 16341                        ;					}
 16342                        L10401:
 16343                        ;				}
 16344                        L10399:
 16345                        ;			}
 16346                        L10398:
 16347                        ;			if (res == FR_OK) {
 16348 00:4D16: A5 05        	lda	<L687+res_1
 16349 00:4D18: F0 03        	beq	L708
 16350 00:4D1A: 82 20 00     	brl	L10405
 16351                        L708:
 16352                        ;				res = dir_remove(&djo);	
                    	/* Remove old entry */
 16353 00:4D1D: F4 00 00     	pea	#0
 16354 00:4D20: 18           	clc
 16355 00:4D21: 7B           	tdc
 16356 00:4D22: 69 07 00     	adc	#<L687+djo_1
 16357 00:4D25: 48           	pha
 16358 00:4D26: 22 xx xx xx  	jsl	~~dir_remove
 16359 00:4D2A: 85 05        	sta	<L687+res_1
 16360                        ;				if (res == FR_OK) {
 16361 00:4D2C: A5 05        	lda	<L687+res_1
  Thu May 20 2021 21:37                                                Page 327


 16362 00:4D2E: F0 03        	beq	L709
 16363 00:4D30: 82 0A 00     	brl	L10406
 16364                        L709:
 16365                        ;					res = sync_fs(fs
                    );
 16366 00:4D33: D4 61        	pei	<L687+fs_1+2
 16367 00:4D35: D4 5F        	pei	<L687+fs_1
 16368 00:4D37: 22 xx xx xx  	jsl	~~sync_fs
 16369 00:4D3B: 85 05        	sta	<L687+res_1
 16370                        ;				}
 16371                        ;			}
 16372                        L10406:
 16373                        ;/* End of the critical section */
 16374                        ;		}
 16375                        L10405:
 16376                        ;		FREE_NAMBUF();
 16377                        L10396:
 16378                        ;	}
 16379                        ;
 16380                        ;	LEAVE_FF(fs, res);
 16381                        L10394:
 16382 00:4D3D: A5 05        	lda	<L687+res_1
 16383                        L710:
 16384 00:4D3F: A8           	tay
 16385 00:4D40: A5 8C        	lda	<L686+2
 16386 00:4D42: 85 94        	sta	<L686+2+8
 16387 00:4D44: A5 8B        	lda	<L686+1
 16388 00:4D46: 85 93        	sta	<L686+1+8
 16389 00:4D48: 2B           	pld
 16390 00:4D49: 3B           	tsc
 16391 00:4D4A: 18           	clc
 16392 00:4D4B: 69 92 00     	adc	#L686+8
 16393 00:4D4E: 1B           	tcs
 16394 00:4D4F: 98           	tya
 16395 00:4D50: 6B           	rtl
 16396                        ;}
 16397             0000008A   L686	equ	138
 16398             00000005   L687	equ	5
 16399                        	ends
 16400                        	efunc
 16401                        ;
 16402                        ;#endif /* !FF_FS_READONLY */
 16403                        ;#endif /* FF_FS_MINIMIZE == 0 */
 16404                        ;#endif /* FF_FS_MINIMIZE <= 1 */
 16405                        ;#endif /* FF_FS_MINIMIZE <= 2 */
 16406                        ;
 16407                        ;
 16408                        ;
 16409                        ;#if FF_USE_CHMOD && !FF_FS_READONLY
 16410                        ;/*-----------------------------------------------
                    ------------------------*/
 16411                        ;/* Change Attribute                              
                                            */
 16412                        ;/*-----------------------------------------------
                    ------------------------*/
 16413                        ;
 16414                        ;FRESULT f_chmod (
 16415                        ;	const TCHAR* path,	/* Pointer to the file p
  Thu May 20 2021 21:37                                                Page 328


                    ath */
 16416                        ;	BYTE attr,			/* Attribute bit
                    s */
 16417                        ;	BYTE mask			/* Attribute mas
                    k to change */
 16418                        ;)
 16419                        ;{
 16420                        ;	FRESULT res;
 16421                        ;	DIR dj;
 16422                        ;	FATFS *fs;
 16423                        ;	DEF_NAMBUF
 16424                        ;
 16425                        ;
 16426                        ;	res = mount_volume(&path, &fs, FA_WRITE);	
                    /* Get logical drive */
 16427                        ;	if (res == FR_OK) {
 16428                        ;		dj.obj.fs = fs;
 16429                        ;		INIT_NAMBUF(fs);
 16430                        ;		res = follow_path(&dj, path);	/* Follo
                    w the file path */
 16431                        ;		if (res == FR_OK && (dj.fn[NSFLAG] & (NS
                    _DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object 
                    validity */
 16432                        ;		if (res == FR_OK) {
 16433                        ;			mask &= AM_RDO|AM_HID|AM_SYS|AM_
                    ARC;	/* Valid attribute mask */
 16434                        ;#if FF_FS_EXFAT
 16435                        ;			if (fs->fs_type == FS_EXFAT) {
 16436                        ;				fs->dirbuf[XDIR_Attr] = 
                    (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	
                    /* Apply attribute change */
 16437                        ;				res = store_xdir(&dj);
 16438                        ;			} else
 16439                        ;#endif
 16440                        ;			{
 16441                        ;				dj.dir[DIR_Attr] = (attr
                     & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply
                     attribute change */
 16442                        ;				fs->wflag = 1;
 16443                        ;			}
 16444                        ;			if (res == FR_OK) {
 16445                        ;				res = sync_fs(fs);
 16446                        ;			}
 16447                        ;		}
 16448                        ;		FREE_NAMBUF();
 16449                        ;	}
 16450                        ;
 16451                        ;	LEAVE_FF(fs, res);
 16452                        ;}
 16453                        ;
 16454                        ;
 16455                        ;
 16456                        ;
 16457                        ;/*-----------------------------------------------
                    ------------------------*/
 16458                        ;/* Change Timestamp                              
                                            */
 16459                        ;/*-----------------------------------------------
  Thu May 20 2021 21:37                                                Page 329


                    ------------------------*/
 16460                        ;
 16461                        ;FRESULT f_utime (
 16462                        ;	const TCHAR* path,	/* Pointer to the file/d
                    irectory name */
 16463                        ;	const FILINFO* fno	/* Pointer to the timest
                    amp to be set */
 16464                        ;)
 16465                        ;{
 16466                        ;	FRESULT res;
 16467                        ;	DIR dj;
 16468                        ;	FATFS *fs;
 16469                        ;	DEF_NAMBUF
 16470                        ;
 16471                        ;
 16472                        ;	res = mount_volume(&path, &fs, FA_WRITE);	
                    /* Get logical drive */
 16473                        ;	if (res == FR_OK) {
 16474                        ;		dj.obj.fs = fs;
 16475                        ;		INIT_NAMBUF(fs);
 16476                        ;		res = follow_path(&dj, path);	/* Follo
                    w the file path */
 16477                        ;		if (res == FR_OK && (dj.fn[NSFLAG] & (NS
                    _DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object 
                    validity */
 16478                        ;		if (res == FR_OK) {
 16479                        ;#if FF_FS_EXFAT
 16480                        ;			if (fs->fs_type == FS_EXFAT) {
 16481                        ;				st_dword(fs->dirbuf + XD
                    IR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
 16482                        ;				res = store_xdir(&dj);
 16483                        ;			} else
 16484                        ;#endif
 16485                        ;			{
 16486                        ;				st_dword(dj.dir + DIR_Mo
                    dTime, (DWORD)fno->fdate << 16 | fno->ftime);
 16487                        ;				fs->wflag = 1;
 16488                        ;			}
 16489                        ;			if (res == FR_OK) {
 16490                        ;				res = sync_fs(fs);
 16491                        ;			}
 16492                        ;		}
 16493                        ;		FREE_NAMBUF();
 16494                        ;	}
 16495                        ;
 16496                        ;	LEAVE_FF(fs, res);
 16497                        ;}
 16498                        ;
 16499                        ;#endif	/* FF_USE_CHMOD && !FF_FS_READONLY */
 16500                        ;
 16501                        ;
 16502                        ;
 16503                        ;#if FF_USE_LABEL
 16504                        ;/*-----------------------------------------------
                    ------------------------*/
 16505                        ;/* Get Volume Label                              
                                            */
 16506                        ;/*-----------------------------------------------
  Thu May 20 2021 21:37                                                Page 330


                    ------------------------*/
 16507                        ;
 16508                        ;FRESULT f_getlabel (
 16509                        ;	const TCHAR* path,	/* Logical drive number 
                    */
 16510                        ;	TCHAR* label,		/* Buffer to store the v
                    olume label */
 16511                        ;	DWORD* vsn			/* Variable to s
                    tore the volume serial number */
 16512                        ;)
 16513                        ;{
 16514                        ;	FRESULT res;
 16515                        ;	DIR dj;
 16516                        ;	FATFS *fs;
 16517                        ;	UINT si, di;
 16518                        ;	WCHAR wc;
 16519                        ;
 16520                        ;	/* Get logical drive */
 16521                        ;	res = mount_volume(&path, &fs, 0);
 16522                        ;
 16523                        ;	/* Get volume label */
 16524                        ;	if (res == FR_OK && label) {
 16525                        ;		dj.obj.fs = fs; dj.obj.sclust = 0;	
                    /* Open root directory */
 16526                        ;		res = dir_sdi(&dj, 0);
 16527                        ;		if (res == FR_OK) {
 16528                        ;		 	res = DIR_READ_LABEL(&dj);	
                    	/* Find a volume label entry */
 16529                        ;		 	if (res == FR_OK) {
 16530                        ;#if FF_FS_EXFAT
 16531                        ;				if (fs->fs_type == FS_EX
                    FAT) {
 16532                        ;					WCHAR hs;
 16533                        ;					UINT nw;
 16534                        ;
 16535                        ;					for (si = di = h
                    s = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volum
                    e label from 83 entry */
 16536                        ;						wc = ld_
                    word(dj.dir + XDIR_Label + si * 2);
 16537                        ;						if (hs =
                    = 0 && IsSurrogate(wc)) {	/* Is the code a surrogate? */
 16538                        ;							
                    hs = wc; continue;
 16539                        ;						}
 16540                        ;						nw = put
                    _utf((DWORD)hs << 16 | wc, &label[di], 4);	/* Store it in A
                    PI encoding */
 16541                        ;						if (nw =
                    = 0) { di = 0; break; }		/* Encode error? */
 16542                        ;						di += nw
                    ;
 16543                        ;						hs = 0;
 16544                        ;					}
 16545                        ;					if (hs != 0) di 
                    = 0;	/* Broken surrogate pair? */
 16546                        ;					label[di] = 0;
 16547                        ;				} else
  Thu May 20 2021 21:37                                                Page 331


 16548                        ;#endif
 16549                        ;				{
 16550                        ;					si = di = 0;	
                    	/* Extract volume label from AM_VOL entry */
 16551                        ;					while (si < 11) 
                    {
 16552                        ;						wc = dj.
                    dir[si++];
 16553                        ;#if FF_USE_LFN && FF_LFN_UNICODE >= 1 	/* Unico
                    de output */
 16554                        ;						if (dbc_
                    1st((BYTE)wc) && si < 11) wc = wc << 8 | dj.dir[si++];	
                    /* Is it a DBC? */
 16555                        ;						wc = ff_
                    oem2uni(wc, CODEPAGE);		/* Convert it into Unico
                    de */
 16556                        ;						if (wc =
                    = 0) { di = 0; break; }		/* Invalid char in curre
                    nt code page? */
 16557                        ;						di += pu
                    t_utf(wc, &label[di], 4);	/* Store it in Unicode */
 16558                        ;#else						
                    			/* ANSI/OEM output */
 16559                        ;						label[di
                    ++] = (TCHAR)wc;
 16560                        ;#endif
 16561                        ;					}
 16562                        ;					do {		
                    		/* Truncate trailing spaces */
 16563                        ;						label[di
                    ] = 0;
 16564                        ;						if (di =
                    = 0) break;
 16565                        ;					} while (label[-
                    -di] == ' ');
 16566                        ;				}
 16567                        ;			}
 16568                        ;		}
 16569                        ;		if (res == FR_NO_FILE) {	/* No la
                    bel entry and return nul string */
 16570                        ;			label[0] = 0;
 16571                        ;			res = FR_OK;
 16572                        ;		}
 16573                        ;	}
 16574                        ;
 16575                        ;	/* Get volume serial number */
 16576                        ;	if (res == FR_OK && vsn) {
 16577                        ;		res = move_window(fs, fs->volbase);
 16578                        ;		if (res == FR_OK) {
 16579                        ;			switch (fs->fs_type) {
 16580                        ;			case FS_EXFAT:
 16581                        ;				di = BPB_VolIDEx;
 16582                        ;				break;
 16583                        ;
 16584                        ;			case FS_FAT32:
 16585                        ;				di = BS_VolID32;
 16586                        ;				break;
 16587                        ;
  Thu May 20 2021 21:37                                                Page 332


 16588                        ;			default:
 16589                        ;				di = BS_VolID;
 16590                        ;			}
 16591                        ;			*vsn = ld_dword(fs->win + di);
 16592                        ;		}
 16593                        ;	}
 16594                        ;
 16595                        ;	LEAVE_FF(fs, res);
 16596                        ;}
 16597                        ;
 16598                        ;
 16599                        ;
 16600                        ;#if !FF_FS_READONLY
 16601                        ;/*-----------------------------------------------
                    ------------------------*/
 16602                        ;/* Set Volume Label                              
                                            */
 16603                        ;/*-----------------------------------------------
                    ------------------------*/
 16604                        ;
 16605                        ;FRESULT f_setlabel (
 16606                        ;	const TCHAR* label	/* Volume label to set w
                    ith heading logical drive number */
 16607                        ;)
 16608                        ;{
 16609                        ;	FRESULT res;
 16610                        ;	DIR dj;
 16611                        ;	FATFS *fs;
 16612                        ;	BYTE dirvn[22];
 16613                        ;	UINT di;
 16614                        ;	WCHAR wc;
 16615                        ;	static const char badchr[18] = "+.,;=[]" "/*:<>|
                    \\\"\?\x7F";	/* [0..16] for FAT, [7..16] for exFAT */
 16616                        ;#if FF_USE_LFN
 16617                        ;	DWORD dc;
 16618                        ;#endif
 16619                        ;
 16620                        ;	/* Get logical drive */
 16621                        ;	res = mount_volume(&label, &fs, FA_WRITE);
 16622                        ;	if (res != FR_OK) LEAVE_FF(fs, res);
 16623                        ;
 16624                        ;#if FF_FS_EXFAT
 16625                        ;	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT 
                    volume */
 16626                        ;		memset(dirvn, 0, 22);
 16627                        ;		di = 0;
 16628                        ;		while ((UINT)*label >= ' ') {	/* Creat
                    e volume label */
 16629                        ;			dc = tchar2uni(&label);	/* Get a
                     Unicode character */
 16630                        ;			if (dc >= 0x10000) {
 16631                        ;				if (dc == 0xFFFFFFFF || 
                    di >= 10) {	/* Wrong surrogate or buffer overflow */
 16632                        ;					dc = 0;
 16633                        ;				} else {
 16634                        ;					st_word(dirvn + 
                    di * 2, (WCHAR)(dc >> 16)); di++;
 16635                        ;				}
  Thu May 20 2021 21:37                                                Page 333


 16636                        ;			}
 16637                        ;			if (dc == 0 || strchr(&badchr[7]
                    , (int)dc) || di >= 11) {	/* Check validity of the volume 
                    label */
 16638                        ;				LEAVE_FF(fs, FR_INVALID_
                    NAME);
 16639                        ;			}
 16640                        ;			st_word(dirvn + di * 2, (WCHAR)d
                    c); di++;
 16641                        ;		}
 16642                        ;	} else
 16643                        ;#endif
 16644                        ;	{	/* On the FAT/FAT32 volume */
 16645                        ;		memset(dirvn, ' ', 11);
 16646                        ;		di = 0;
 16647                        ;		while ((UINT)*label >= ' ') {	/* Creat
                    e volume label */
 16648                        ;#if FF_USE_LFN
 16649                        ;			dc = tchar2uni(&label);
 16650                        ;			wc = (dc < 0x10000) ? ff_uni2oem
                    (ff_wtoupper(dc), CODEPAGE) : 0;
 16651                        ;#else						
                    			/* ANSI/OEM input */
 16652                        ;			wc = (BYTE)*label++;
 16653                        ;			if (dbc_1st((BYTE)wc)) wc = dbc_
                    2nd((BYTE)*label) ? wc << 8 | (BYTE)*label++ : 0;
 16654                        ;			if (IsLower(wc)) wc -= 0x20;	
                    	/* To upper ASCII characters */
 16655                        ;#if FF_CODE_PAGE == 0
 16656                        ;			if (ExCvt && wc >= 0x80) wc = Ex
                    Cvt[wc - 0x80];	/* To upper extended characters (SBCS cf
                    g) */
 16657                        ;#elif FF_CODE_PAGE < 900
 16658                        ;			if (wc >= 0x80) wc = ExCvt[wc - 
                    0x80];	/* To upper extended characters (SBCS cfg) */
 16659                        ;#endif
 16660                        ;#endif
 16661                        ;			if (wc == 0 || strchr(&badchr[0]
                    , (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {	
                    /* Reject invalid characters for volume label */
 16662                        ;				LEAVE_FF(fs, FR_INVALID_
                    NAME);
 16663                        ;			}
 16664                        ;			if (wc >= 0x100) dirvn[di++] = (
                    BYTE)(wc >> 8);
 16665                        ;			dirvn[di++] = (BYTE)wc;
 16666                        ;		}
 16667                        ;		if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_IN
                    VALID_NAME);	/* Reject illegal name (heading DDEM) */
 16668                        ;		while (di && dirvn[di - 1] == ' ') di--;
                    				/* Snip trailing spaces */
 16669                        ;	}
 16670                        ;
 16671                        ;	/* Set volume label */
 16672                        ;	dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open 
                    root directory */
 16673                        ;	res = dir_sdi(&dj, 0);
 16674                        ;	if (res == FR_OK) {
  Thu May 20 2021 21:37                                                Page 334


 16675                        ;		res = DIR_READ_LABEL(&dj);	/* Get v
                    olume label entry */
 16676                        ;		if (res == FR_OK) {
 16677                        ;			if (FF_FS_EXFAT && fs->fs_type =
                    = FS_EXFAT) {
 16678                        ;				dj.dir[XDIR_NumLabel] = 
                    (BYTE)di;	/* Change the volume label */
 16679                        ;				memcpy(dj.dir + XDIR_Lab
                    el, dirvn, 22);
 16680                        ;			} else {
 16681                        ;				if (di != 0) {
 16682                        ;					memcpy(dj.dir, d
                    irvn, 11);	/* Change the volume label */
 16683                        ;				} else {
 16684                        ;					dj.dir[DIR_Name]
                     = DDEM;	/* Remove the volume label */
 16685                        ;				}
 16686                        ;			}
 16687                        ;			fs->wflag = 1;
 16688                        ;			res = sync_fs(fs);
 16689                        ;		} else {			/* No vo
                    lume label entry or an error */
 16690                        ;			if (res == FR_NO_FILE) {
 16691                        ;				res = FR_OK;
 16692                        ;				if (di != 0) {	/* Creat
                    e a volume label entry */
 16693                        ;					res = dir_alloc(
                    &dj, 1);	/* Allocate an entry */
 16694                        ;					if (res == FR_OK
                    ) {
 16695                        ;						memset(d
                    j.dir, 0, SZDIRE);	/* Clean the entry */
 16696                        ;						if (FF_F
                    S_EXFAT && fs->fs_type == FS_EXFAT) {
 16697                        ;							
                    dj.dir[XDIR_Type] = ET_VLABEL;	/* Create volume label e
                    ntry */
 16698                        ;							
                    dj.dir[XDIR_NumLabel] = (BYTE)di;
 16699                        ;							
                    memcpy(dj.dir + XDIR_Label, dirvn, 22);
 16700                        ;						} else {
 16701                        ;							
                    dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label e
                    ntry */
 16702                        ;							
                    memcpy(dj.dir, dirvn, 11);
 16703                        ;						}
 16704                        ;						fs->wfla
                    g = 1;
 16705                        ;						res = sy
                    nc_fs(fs);
 16706                        ;					}
 16707                        ;				}
 16708                        ;			}
 16709                        ;		}
 16710                        ;	}
 16711                        ;
  Thu May 20 2021 21:37                                                Page 335


 16712                        ;	LEAVE_FF(fs, res);
 16713                        ;}
 16714                        ;
 16715                        ;#endif /* !FF_FS_READONLY */
 16716                        ;#endif /* FF_USE_LABEL */
 16717                        ;
 16718                        ;
 16719                        ;
 16720                        ;#if FF_USE_EXPAND && !FF_FS_READONLY
 16721                        ;/*-----------------------------------------------
                    ------------------------*/
 16722                        ;/* Allocate a Contiguous Blocks to the File      
                                            */
 16723                        ;/*-----------------------------------------------
                    ------------------------*/
 16724                        ;
 16725                        ;FRESULT f_expand (
 16726                        ;	FIL* fp,		/* Pointer to the file o
                    bject */
 16727                        ;	FSIZE_t fsz,	/* File size to be expanded to *
                    /
 16728                        ;	BYTE opt		/* Operation mode 0:Find
                     and prepare or 1:Find and allocate */
 16729                        ;)
 16730                        ;{
 16731                        ;	FRESULT res;
 16732                        ;	FATFS *fs;
 16733                        ;	DWORD n, clst, stcl, scl, ncl, tcl, lclst;
 16734                        ;
 16735                        ;
 16736                        ;	res = validate(&fp->obj, &fs);		/* Check
                     validity of the file object */
 16737                        ;	if (res != FR_OK || (res = (FRESULT)fp->err) != 
                    FR_OK) LEAVE_FF(fs, res);
 16738                        ;	if (fsz == 0 || fp->obj.objsize != 0 || !(fp->fl
                    ag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
 16739                        ;#if FF_FS_EXFAT
 16740                        ;	if (fs->fs_type != FS_EXFAT && fsz >= 0x10000000
                    0) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
 16741                        ;#endif
 16742                        ;	n = (DWORD)fs->csize * SS(fs);	/* Cluster size 
                    */
 16743                        ;	tcl = (DWORD)(fsz / n) + ((fsz & (n - 1)) ? 1 : 
                    0);	/* Number of clusters required */
 16744                        ;	stcl = fs->last_clst; lclst = 0;
 16745                        ;	if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
 16746                        ;
 16747                        ;#if FF_FS_EXFAT
 16748                        ;	if (fs->fs_type == FS_EXFAT) {
 16749                        ;		scl = find_bitmap(fs, stcl, tcl);	
                    		/* Find a contiguous cluster block */
 16750                        ;		if (scl == 0) res = FR_DENIED;		
                    		/* No contiguous cluster block was found */
 16751                        ;		if (scl == 0xFFFFFFFF) res = FR_DISK_ERR
                    ;
 16752                        ;		if (res == FR_OK) {	/* A contiguous 
                    free area is found */
 16753                        ;			if (opt) {		/* Alloc
  Thu May 20 2021 21:37                                                Page 336


                    ate it now */
 16754                        ;				res = change_bitmap(fs, 
                    scl, tcl, 1);	/* Mark the cluster block 'in use' */
 16755                        ;				lclst = scl + tcl - 1;
 16756                        ;			} else {		/* Set i
                    t as suggested point for next allocation */
 16757                        ;				lclst = scl - 1;
 16758                        ;			}
 16759                        ;		}
 16760                        ;	} else
 16761                        ;#endif
 16762                        ;	{
 16763                        ;		scl = clst = stcl; ncl = 0;
 16764                        ;		for (;;) {	/* Find a contiguous clu
                    ster block */
 16765                        ;			n = get_fat(&fp->obj, clst);
 16766                        ;			if (++clst >= fs->n_fatent) clst
                     = 2;
 16767                        ;			if (n == 1) { res = FR_INT_ERR; 
                    break; }
 16768                        ;			if (n == 0xFFFFFFFF) { res = FR_
                    DISK_ERR; break; }
 16769                        ;			if (n == 0) {	/* Is it a free 
                    cluster? */
 16770                        ;				if (++ncl == tcl) break;
                    	/* Break if a contiguous cluster block is found */
 16771                        ;			} else {
 16772                        ;				scl = clst; ncl = 0;	
                    	/* Not a free cluster */
 16773                        ;			}
 16774                        ;			if (clst == stcl) { res = FR_DEN
                    IED; break; }	/* No contiguous cluster? */
 16775                        ;		}
 16776                        ;		if (res == FR_OK) {	/* A contiguous 
                    free area is found */
 16777                        ;			if (opt) {		/* Alloc
                    ate it now */
 16778                        ;				for (clst = scl, n = tcl
                    ; n; clst++, n--) {	/* Create a cluster chain on the FAT */
 16779                        ;					res = put_fat(fs
                    , clst, (n == 1) ? 0xFFFFFFFF : clst + 1);
 16780                        ;					if (res != FR_OK
                    ) break;
 16781                        ;					lclst = clst;
 16782                        ;				}
 16783                        ;			} else {		/* Set i
                    t as suggested point for next allocation */
 16784                        ;				lclst = scl - 1;
 16785                        ;			}
 16786                        ;		}
 16787                        ;	}
 16788                        ;
 16789                        ;	if (res == FR_OK) {
 16790                        ;		fs->last_clst = lclst;		/* Set s
                    uggested start cluster to start next */
 16791                        ;		if (opt) {	/* Is it allocated now? 
                    */
 16792                        ;			fp->obj.sclust = scl;		
  Thu May 20 2021 21:37                                                Page 337


                    /* Update object allocation information */
 16793                        ;			fp->obj.objsize = fsz;
 16794                        ;			if (FF_FS_EXFAT) fp->obj.stat = 
                    2;	/* Set status 'contiguous chain' */
 16795                        ;			fp->flag |= FA_MODIFIED;
 16796                        ;			if (fs->free_clst <= fs->n_faten
                    t - 2) {	/* Update FSINFO */
 16797                        ;				fs->free_clst -= tcl;
 16798                        ;				fs->fsi_flag |= 1;
 16799                        ;			}
 16800                        ;		}
 16801                        ;	}
 16802                        ;
 16803                        ;	LEAVE_FF(fs, res);
 16804                        ;}
 16805                        ;
 16806                        ;#endif /* FF_USE_EXPAND && !FF_FS_READONLY */
 16807                        ;
 16808                        ;
 16809                        ;
 16810                        ;#if FF_USE_FORWARD
 16811                        ;/*-----------------------------------------------
                    ------------------------*/
 16812                        ;/* Forward Data to the Stream Directly           
                                            */
 16813                        ;/*-----------------------------------------------
                    ------------------------*/
 16814                        ;
 16815                        ;FRESULT f_forward (
 16816                        ;	FIL* fp, 					
                    	/* Pointer to the file object */
 16817                        ;	UINT (*func)(const BYTE*,UINT),	/* Pointer to th
                    e streaming function */
 16818                        ;	UINT btf,					
                    	/* Number of bytes to forward */
 16819                        ;	UINT* bf					
                    	/* Pointer to number of bytes forwarded */
 16820                        ;)
 16821                        ;{
 16822                        ;	FRESULT res;
 16823                        ;	FATFS *fs;
 16824                        ;	DWORD clst;
 16825                        ;	LBA_t sect;
 16826                        ;	FSIZE_t remain;
 16827                        ;	UINT rcnt, csect;
 16828                        ;	BYTE *dbuf;
 16829                        ;
 16830                        ;
 16831                        ;	*bf = 0;	/* Clear transfer byte counter *
                    /
 16832                        ;	res = validate(&fp->obj, &fs);		/* Check
                     validity of the file object */
 16833                        ;	if (res != FR_OK || (res = (FRESULT)fp->err) != 
                    FR_OK) LEAVE_FF(fs, res);
 16834                        ;	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIE
                    D);	/* Check access mode */
 16835                        ;
 16836                        ;	remain = fp->obj.objsize - fp->fptr;
  Thu May 20 2021 21:37                                                Page 338


 16837                        ;	if (btf > remain) btf = (UINT)remain;		
                    	/* Truncate btf by remaining bytes */
 16838                        ;
 16839                        ;	for ( ; btf > 0 && (*func)(0, 0); fp->fptr += rc
                    nt, *bf += rcnt, btf -= rcnt) {	/* Repeat until all data
                     transferred or stream goes busy */
 16840                        ;		csect = (UINT)(fp->fptr / SS(fs) & (fs->
                    csize - 1));	/* Sector offset in the cluster */
 16841                        ;		if (fp->fptr % SS(fs) == 0) {		
                    		/* On the sector boundary? */
 16842                        ;			if (csect == 0) {		
                    				/* On the cluster boundary? */
 16843                        ;				clst = (fp->fptr == 0) ?
                    			/* On the top of the file? */
 16844                        ;					fp->obj.sclust :
                     get_fat(&fp->obj, fp->clust);
 16845                        ;				if (clst <= 1) ABORT(fs,
                     FR_INT_ERR);
 16846                        ;				if (clst == 0xFFFFFFFF) 
                    ABORT(fs, FR_DISK_ERR);
 16847                        ;				fp->clust = clst;	
                    				/* Update current cluster */
 16848                        ;			}
 16849                        ;		}
 16850                        ;		sect = clst2sect(fs, fp->clust);	
                    		/* Get current data sector */
 16851                        ;		if (sect == 0) ABORT(fs, FR_INT_ERR);
 16852                        ;		sect += csect;
 16853                        ;#if FF_FS_TINY
 16854                        ;		if (move_window(fs, sect) != FR_OK) ABOR
                    T(fs, FR_DISK_ERR);	/* Move sector window to the file data *
                    /
 16855                        ;		dbuf = fs->win;
 16856                        ;#else
 16857                        ;		if (fp->sect != sect) {		/* Fill 
                    sector cache with file data */
 16858                        ;#if !FF_FS_READONLY
 16859                        ;			if (fp->flag & FA_DIRTY) {	
                    	/* Write-back dirty sector cache */
 16860                        ;				if (disk_write(fs->pdrv,
                     fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 16861                        ;				fp->flag &= (BYTE)~FA_DI
                    RTY;
 16862                        ;			}
 16863                        ;#endif
 16864                        ;			if (disk_read(fs->pdrv, fp->buf,
                     sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 16865                        ;		}
 16866                        ;		dbuf = fp->buf;
 16867                        ;#endif
 16868                        ;		fp->sect = sect;
 16869                        ;		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);
                    	/* Number of bytes remains in the sector */
 16870                        ;		if (rcnt > btf) rcnt = btf;		
                    			/* Clip it by btr if needed */
 16871                        ;		rcnt = (*func)(dbuf + ((UINT)fp->fptr % 
                    SS(fs)), rcnt);	/* Forward the file data */
 16872                        ;		if (rcnt == 0) ABORT(fs, FR_INT_ERR);
  Thu May 20 2021 21:37                                                Page 339


 16873                        ;	}
 16874                        ;
 16875                        ;	LEAVE_FF(fs, FR_OK);
 16876                        ;}
 16877                        ;#endif /* FF_USE_FORWARD */
 16878                        ;
 16879                        ;
 16880                        ;
 16881                        ;#if !FF_FS_READONLY && FF_USE_MKFS
 16882                        ;/*-----------------------------------------------
                    ------------------------*/
 16883                        ;/* Create FAT/exFAT volume (with sub-functions)  
                                            */
 16884                        ;/*-----------------------------------------------
                    ------------------------*/
 16885                        ;
 16886                        ;#define N_SEC_TRACK 63			/* Secto
                    rs per track for determination of drive CHS */
 16887                        ;#define	GPT_ALIGN	0x100000	/* Align
                    ment of partitions in GPT [byte] (>=128KB) */
 16888                        ;#define GPT_ITEMS	128			
                    /* Number of GPT table size (>=128, sector aligned) */
 16889                        ;
 16890                        ;
 16891                        ;/* Create partitions on the physical drive in for
                    mat of MBR or GPT */
 16892                        ;
 16893                        ;static FRESULT create_partition (
 16894                        ;	BYTE drv,			/* Physical driv
                    e number */
 16895                        ;	const LBA_t plst[],	/* Partition list */
 16896                        ;	BYTE sys,			/* System ID (fo
                    r only MBR, temp setting) */
 16897                        ;	BYTE* buf			/* Working buffe
                    r for a sector */
 16898                        ;)
 16899                        ;{
 16900                        ;	UINT i, cy;
 16901                        ;	LBA_t sz_drv;
 16902                        ;	DWORD sz_drv32, nxt_alloc32, sz_part32;
 16903                        ;	BYTE *pte;
 16904                        ;	BYTE hd, n_hd, sc, n_sc;
 16905                        ;
 16906                        ;	/* Get physical drive size */
 16907                        ;	if (disk_ioctl(drv, GET_SECTOR_COUNT, &sz_drv) !
                    = RES_OK) return FR_DISK_ERR;
 16908                        ;
 16909                        ;#if FF_LBA64
 16910                        ;	if (sz_drv >= FF_MIN_GPT) {	/* Create partit
                    ions in GPT format */
 16911                        ;		WORD ss;
 16912                        ;		UINT sz_ptbl, pi, si, ofs;
 16913                        ;		DWORD bcc, rnd, align;
 16914                        ;		QWORD nxt_alloc, sz_part, sz_pool, top_b
                    pt;
 16915                        ;		static const BYTE gpt_mbr[16] = {0x00, 0
                    x00, 0x02, 0x00, 0xEE, 0xFE, 0xFF, 0x00, 0x01, 0x00, 0x00, 0
                    x00, 0xFF, 0xFF, 0xFF, 0xFF};
  Thu May 20 2021 21:37                                                Page 340


 16916                        ;
 16917                        ;#if FF_MAX_SS != FF_MIN_SS
 16918                        ;		if (disk_ioctl(drv, GET_SECTOR_SIZE, &ss
                    ) != RES_OK) return FR_DISK_ERR;	/* Get sector size */
 16919                        ;		if (ss > FF_MAX_SS || ss < FF_MIN_SS || 
                    (ss & (ss - 1))) return FR_DISK_ERR;
 16920                        ;#else
 16921                        ;		ss = FF_MAX_SS;
 16922                        ;#endif
 16923                        ;		rnd = (DWORD)sz_drv + GET_FATTIME();	
                    /* Random seed */
 16924                        ;		align = GPT_ALIGN / ss;			
                    	/* Partition alignment for GPT [sector] */
 16925                        ;		sz_ptbl = GPT_ITEMS * SZ_GPTE / ss;	
                    /* Size of partition table [sector] */
 16926                        ;		top_bpt = sz_drv - sz_ptbl - 1;		
                    /* Backup partiiton table start sector */
 16927                        ;		nxt_alloc = 2 + sz_ptbl;		
                    	/* First allocatable sector */
 16928                        ;		sz_pool = top_bpt - nxt_alloc;		
                    /* Size of allocatable area */
 16929                        ;		bcc = 0xFFFFFFFF; sz_part = 1;
 16930                        ;		pi = si = 0;	/* partition table index
                    , size table index */
 16931                        ;		do {
 16932                        ;			if (pi * SZ_GPTE % ss == 0) mems
                    et(buf, 0, ss);	/* Clean the buffer if needed */
 16933                        ;			if (sz_part != 0) {		
                    		/* Is the size table not termintated? */
 16934                        ;				nxt_alloc = (nxt_alloc +
                     align - 1) & ((QWORD)0 - align);	/* Align partition start
                     */
 16935                        ;				sz_part = plst[si++];	
                    	/* Get a partition size */
 16936                        ;				if (sz_part <= 100) {	
                    	/* Is the size in percentage? */
 16937                        ;					sz_part = sz_poo
                    l * sz_part / 100;
 16938                        ;					sz_part = (sz_pa
                    rt + align - 1) & ((QWORD)0 - align);	/* Align partiti
                    on end (only if in percentage) */
 16939                        ;				}
 16940                        ;				if (nxt_alloc + sz_part 
                    > top_bpt) {	/* Clip the size at end of the pool */
 16941                        ;					sz_part = (nxt_a
                    lloc < top_bpt) ? top_bpt - nxt_alloc : 0;
 16942                        ;				}
 16943                        ;			}
 16944                        ;			if (sz_part != 0) {		
                    		/* Add a partition? */
 16945                        ;				ofs = pi * SZ_GPTE % ss;
 16946                        ;				memcpy(buf + ofs + GPTE_
                    PtGuid, GUID_MS_Basic, 16);	/* Set partition GUID (Microsoft
                     Basic Data) */
 16947                        ;				rnd = make_rand(rnd, buf
                     + ofs + GPTE_UpGuid, 16);	/* Set unique partition GUID */
 16948                        ;				st_qword(buf + ofs + GPT
                    E_FstLba, nxt_alloc);		/* Set partition start s
  Thu May 20 2021 21:37                                                Page 341


                    ector */
 16949                        ;				st_qword(buf + ofs + GPT
                    E_LstLba, nxt_alloc + sz_part - 1);	/* Set partition end sec
                    tor */
 16950                        ;				nxt_alloc += sz_part;	
                    							/* Next 
                    allocatable sector */
 16951                        ;			}
 16952                        ;			if ((pi + 1) * SZ_GPTE % ss == 0
                    ) {		/* Write the buffer if it is filled up */
 16953                        ;				for (i = 0; i < ss; bcc 
                    = crc32(bcc, buf[i++])) ;	/* Calculate table check sum */
 16954                        ;				if (disk_write(drv, buf,
                     2 + pi * SZ_GPTE / ss, 1) != RES_OK) return FR_DISK_ERR;	
                    	/* Write to primary table */
 16955                        ;				if (disk_write(drv, buf,
                     top_bpt + pi * SZ_GPTE / ss, 1) != RES_OK) return FR_DISK_E
                    RR;	/* Write to secondary table */
 16956                        ;			}
 16957                        ;		} while (++pi < GPT_ITEMS);
 16958                        ;
 16959                        ;		/* Create primary GPT header */
 16960                        ;		memset(buf, 0, ss);
 16961                        ;		memcpy(buf + GPTH_Sign, "EFI PART" "\0\0
                    \1\0" "\x5C\0\0", 16);	/* Signature, version (1.0) and 
                    size (92) */
 16962                        ;		st_dword(buf + GPTH_PtBcc, ~bcc);	
                    		/* Table check sum */
 16963                        ;		st_qword(buf + GPTH_CurLba, 1);		
                    		/* LBA of this header */
 16964                        ;		st_qword(buf + GPTH_BakLba, sz_drv - 1);
                    	/* LBA of secondary header */
 16965                        ;		st_qword(buf + GPTH_FstLba, 2 + sz_ptbl)
                    ;	/* LBA of first allocatable sector */
 16966                        ;		st_qword(buf + GPTH_LstLba, top_bpt - 1)
                    ;	/* LBA of last allocatable sector */
 16967                        ;		st_dword(buf + GPTH_PteSize, SZ_GPTE);	
                    	/* Size of a table entry */
 16968                        ;		st_dword(buf + GPTH_PtNum, GPT_ITEMS);	
                    	/* Number of table entries */
 16969                        ;		st_dword(buf + GPTH_PtOfs, 2);		
                    		/* LBA of this table */
 16970                        ;		rnd = make_rand(rnd, buf + GPTH_DskGuid,
                     16);	/* Disk GUID */
 16971                        ;		for (i = 0, bcc= 0xFFFFFFFF; i < 92; bcc
                     = crc32(bcc, buf[i++])) ;	/* Calculate header check sum */
 16972                        ;		st_dword(buf + GPTH_Bcc, ~bcc);		
                    		/* Header check sum */
 16973                        ;		if (disk_write(drv, buf, 1, 1) != RES_OK
                    ) return FR_DISK_ERR;
 16974                        ;
 16975                        ;		/* Create secondary GPT header */
 16976                        ;		st_qword(buf + GPTH_CurLba, sz_drv - 1);
                    	/* LBA of this header */
 16977                        ;		st_qword(buf + GPTH_BakLba, 1);		
                    		/* LBA of primary header */
 16978                        ;		st_qword(buf + GPTH_PtOfs, top_bpt);	
                    	/* LBA of this table */
  Thu May 20 2021 21:37                                                Page 342


 16979                        ;		st_dword(buf + GPTH_Bcc, 0);
 16980                        ;		for (i = 0, bcc= 0xFFFFFFFF; i < 92; bcc
                     = crc32(bcc, buf[i++])) ;	/* Calculate header check sum */
 16981                        ;		st_dword(buf + GPTH_Bcc, ~bcc);		
                    		/* Header check sum */
 16982                        ;		if (disk_write(drv, buf, sz_drv - 1, 1) 
                    != RES_OK) return FR_DISK_ERR;
 16983                        ;
 16984                        ;		/* Create protective MBR */
 16985                        ;		memset(buf, 0, ss);
 16986                        ;		memcpy(buf + MBR_Table, gpt_mbr, 16);	
                    	/* Create a GPT partition */
 16987                        ;		st_word(buf + BS_55AA, 0xAA55);
 16988                        ;		if (disk_write(drv, buf, 0, 1) != RES_OK
                    ) return FR_DISK_ERR;
 16989                        ;
 16990                        ;	} else
 16991                        ;#endif
 16992                        ;	{	/* Create partitions in MBR format */
 16993                        ;		sz_drv32 = (DWORD)sz_drv;
 16994                        ;		n_sc = N_SEC_TRACK;			
                    	/* Determine drive CHS without any consideration of the 
                    drive geometry */
 16995                        ;		for (n_hd = 8; n_hd != 0 && sz_drv32 / n
                    _hd / n_sc > 1024; n_hd *= 2) ;
 16996                        ;		if (n_hd == 0) n_hd = 255;		
                    /* Number of heads needs to be <256 */
 16997                        ;
 16998                        ;		memset(buf, 0, FF_MAX_SS);		
                    /* Clear MBR */
 16999                        ;		pte = buf + MBR_Table;	/* Partition tab
                    le in the MBR */
 17000                        ;		for (i = 0, nxt_alloc32 = n_sc; i < 4 &&
                     nxt_alloc32 != 0 && nxt_alloc32 < sz_drv32; i++, nxt_alloc3
                    2 += sz_part32) {
 17001                        ;			sz_part32 = (DWORD)plst[i];	
                    /* Get partition size */
 17002                        ;			if (sz_part32 <= 100) sz_part32 
                    = (sz_part32 == 100) ? sz_drv32 : sz_drv32 / 100 * sz_part32
                    ;	/* Size in percentage? */
 17003                        ;			if (nxt_alloc32 + sz_part32 > sz
                    _drv32 || nxt_alloc32 + sz_part32 < nxt_alloc32) sz_part32 =
                     sz_drv32 - nxt_alloc32;	/* Clip at drive size */
 17004                        ;			if (sz_part32 == 0) break;	
                    /* End of table or no sector to allocate? */
 17005                        ;
 17006                        ;			st_dword(pte + PTE_StLba, nxt_al
                    loc32);	/* Start LBA */
 17007                        ;			st_dword(pte + PTE_SizLba, sz_pa
                    rt32);	/* Number of sectors */
 17008                        ;			pte[PTE_System] = sys;		
                    			/* System type */
 17009                        ;
 17010                        ;			cy = (UINT)(nxt_alloc32 / n_sc /
                     n_hd);	/* Start cylinder */
 17011                        ;			hd = (BYTE)(nxt_alloc32 / n_sc %
                     n_hd);	/* Start head */
 17012                        ;			sc = (BYTE)(nxt_alloc32 % n_sc +
  Thu May 20 2021 21:37                                                Page 343


                     1);	/* Start sector */
 17013                        ;			pte[PTE_StHead] = hd;
 17014                        ;			pte[PTE_StSec] = (BYTE)((cy >> 2
                     & 0xC0) | sc);
 17015                        ;			pte[PTE_StCyl] = (BYTE)cy;
 17016                        ;
 17017                        ;			cy = (UINT)((nxt_alloc32 + sz_pa
                    rt32 - 1) / n_sc / n_hd);	/* End cylinder */
 17018                        ;			hd = (BYTE)((nxt_alloc32 + sz_pa
                    rt32 - 1) / n_sc % n_hd);	/* End head */
 17019                        ;			sc = (BYTE)((nxt_alloc32 + sz_pa
                    rt32 - 1) % n_sc + 1);		/* End sector */
 17020                        ;			pte[PTE_EdHead] = hd;
 17021                        ;			pte[PTE_EdSec] = (BYTE)((cy >> 2
                     & 0xC0) | sc);
 17022                        ;			pte[PTE_EdCyl] = (BYTE)cy;
 17023                        ;
 17024                        ;			pte += SZ_PTE;		/* Next 
                    entry */
 17025                        ;		}
 17026                        ;
 17027                        ;		st_word(buf + BS_55AA, 0xAA55);		
                    /* MBR signature */
 17028                        ;		if (disk_write(drv, buf, 0, 1) != RES_OK
                    ) return FR_DISK_ERR;	/* Write it to the MBR */
 17029                        ;	}
 17030                        ;
 17031                        ;	return FR_OK;
 17032                        ;}
 17033                        ;
 17034                        ;
 17035                        ;
 17036                        ;FRESULT f_mkfs (
 17037                        ;	const TCHAR* path,		/* Logical drive
                     number */
 17038                        ;	const MKFS_PARM* opt,	/* Format options */
 17039                        ;	void* work,				/* Point
                    er to working buffer (null: use heap memory) */
 17040                        ;	UINT len				/* Size 
                    of working buffer [byte] */
 17041                        ;)
 17042                        ;{
 17043                        ;	static const WORD cst[] = {1, 4, 16, 64, 256, 51
                    2, 0};	/* Cluster size boundary for FAT volume (4Ks uni
                    t) */
 17044                        ;	static const WORD cst32[] = {1, 2, 4, 8, 16, 32,
                     0};	/* Cluster size boundary for FAT32 volume (128Ks
                     unit) */
 17045                        ;	static const MKFS_PARM defopt = {FM_ANY, 0, 0, 0
                    , 0};	/* Default parameter */
 17046                        ;	BYTE fsopt, fsty, sys, *buf, *pte, pdrv, ipart;
 17047                        ;	WORD ss;	/* Sector size */
 17048                        ;	DWORD sz_buf, sz_blk, n_clst, pau, nsect, n, vsn
                    ;
 17049                        ;	LBA_t sz_vol, b_vol, b_fat, b_data;		
                    /* Size of volume, Base LBA of volume, fat, data */
 17050                        ;	LBA_t sect, lba[2];
 17051                        ;	DWORD sz_rsv, sz_fat, sz_dir, sz_au;	/* Size 
  Thu May 20 2021 21:37                                                Page 344


                    of reserved, fat, dir, data, cluster */
 17052                        ;	UINT n_fat, n_root, i;				
                    	/* Index, Number of FATs and Number of roor dir entries 
                    */
 17053                        ;	int vol;
 17054                        ;	DSTATUS ds;
 17055                        ;	FRESULT fr;
 17056                        ;
 17057                        ;
 17058                        ;	/* Check mounted drive and clear work area */
 17059                        ;	vol = get_ldnumber(&path);			
                    		/* Get target logical drive */
 17060                        ;	if (vol < 0) return FR_INVALID_DRIVE;
 17061                        ;	if (FatFs[vol]) FatFs[vol]->fs_type = 0;	
                    /* Clear the fs object if mounted */
 17062                        ;	pdrv = LD2PD(vol);			/* Physi
                    cal drive */
 17063                        ;	ipart = LD2PT(vol);			/* Parti
                    tion (0:create as new, 1..:get from partition table) */
 17064                        ;	if (!opt) opt = &defopt;	/* Use default p
                    arameter if it is not given */
 17065                        ;
 17066                        ;	/* Get physical drive status (sz_drv, sz_blk, ss
                    ) */
 17067                        ;	ds = disk_initialize(pdrv);
 17068                        ;	if (ds & STA_NOINIT) return FR_NOT_READY;
 17069                        ;	if (ds & STA_PROTECT) return FR_WRITE_PROTECTED;
 17070                        ;	sz_blk = opt->align;
 17071                        ;	if (sz_blk == 0 && disk_ioctl(pdrv, GET_BLOCK_SI
                    ZE, &sz_blk) != RES_OK) sz_blk = 1;
 17072                        ; 	if (sz_blk == 0 || sz_blk > 0x8000 || (s
                    z_blk & (sz_blk - 1))) sz_blk = 1;
 17073                        ;#if FF_MAX_SS != FF_MIN_SS
 17074                        ;	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RE
                    S_OK) return FR_DISK_ERR;
 17075                        ;	if (ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (s
                    s - 1))) return FR_DISK_ERR;
 17076                        ;#else
 17077                        ;	ss = FF_MAX_SS;
 17078                        ;#endif
 17079                        ;	/* Options for FAT sub-type and FAT parameters *
                    /
 17080                        ;	fsopt = opt->fmt & (FM_ANY | FM_SFD);
 17081                        ;	n_fat = (opt->n_fat >= 1 && opt->n_fat <= 2) ? o
                    pt->n_fat : 1;
 17082                        ;	n_root = (opt->n_root >= 1 && opt->n_root <= 327
                    68 && (opt->n_root % (ss / SZDIRE)) == 0) ? opt->n_root : 51
                    2;
 17083                        ;	sz_au = (opt->au_size <= 0x1000000 && (opt->au_s
                    ize & (opt->au_size - 1)) == 0) ? opt->au_size : 0;
 17084                        ;	sz_au /= ss;	/* Byte --> Sector */
 17085                        ;
 17086                        ;	/* Get working buffer */
 17087                        ;	sz_buf = len / ss;		/* Size of worki
                    ng buffer [sector] */
 17088                        ;	if (sz_buf == 0) return FR_NOT_ENOUGH_CORE;
 17089                        ;	buf = (BYTE*)work;		/* Working buffe
                    r */
  Thu May 20 2021 21:37                                                Page 345


 17090                        ;#if FF_USE_LFN == 3
 17091                        ;	if (!buf) buf = ff_memalloc(sz_buf * ss);	
                    /* Use heap memory for working buffer */
 17092                        ;#endif
 17093                        ;	if (!buf) return FR_NOT_ENOUGH_CORE;
 17094                        ;
 17095                        ;	/* Determine where the volume to be located (b_v
                    ol, sz_vol) */
 17096                        ;	b_vol = sz_vol = 0;
 17097                        ;	if (FF_MULTI_PARTITION && ipart != 0) {	/* Is th
                    e volume associated with any specific partition? */
 17098                        ;		/* Get partition location from the exist
                    ing partition table */
 17099                        ;		if (disk_read(pdrv, buf, 0, 1) != RES_OK
                    ) LEAVE_MKFS(FR_DISK_ERR);	/* Load MBR */
 17100                        ;		if (ld_word(buf + BS_55AA) != 0xAA55) LE
                    AVE_MKFS(FR_MKFS_ABORTED);	/* Check if MBR is valid */
 17101                        ;#if FF_LBA64
 17102                        ;		if (buf[MBR_Table + PTE_System] == 0xEE)
                     {	/* GPT protective MBR? */
 17103                        ;			DWORD n_ent, ofs;
 17104                        ;			QWORD pt_lba;
 17105                        ;
 17106                        ;			/* Get the partition location fr
                    om GPT */
 17107                        ;			if (disk_read(pdrv, buf, 1, 1) !
                    = RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Load GPT header secto
                    r (next to MBR) */
 17108                        ;			if (!test_gpt_header(buf)) LEAVE
                    _MKFS(FR_MKFS_ABORTED);	/* Check if GPT header is valid 
                    */
 17109                        ;			n_ent = ld_dword(buf + GPTH_PtNu
                    m);		/* Number of entries */
 17110                        ;			pt_lba = ld_qword(buf + GPTH_PtO
                    fs);	/* Table start sector */
 17111                        ;			ofs = i = 0;
 17112                        ;			while (n_ent) {		/* Find 
                    MS Basic partition with order of ipart */
 17113                        ;				if (ofs == 0 && disk_rea
                    d(pdrv, buf, pt_lba++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR)
                    ;	/* Get PT sector */
 17114                        ;				if (!memcmp(buf + ofs + 
                    GPTE_PtGuid, GUID_MS_Basic, 16) && ++i == ipart) {	/* MS ba
                    sic data partition? */
 17115                        ;					b_vol = ld_qword
                    (buf + ofs + GPTE_FstLba);
 17116                        ;					sz_vol = ld_qwor
                    d(buf + ofs + GPTE_LstLba) - b_vol + 1;
 17117                        ;					break;
 17118                        ;				}
 17119                        ;				n_ent--; ofs = (ofs + SZ
                    _GPTE) % ss;	/* Next entry */
 17120                        ;			}
 17121                        ;			if (n_ent == 0) LEAVE_MKFS(FR_MK
                    FS_ABORTED);	/* Partition not found */
 17122                        ;			fsopt |= 0x80;	/* Partitioning 
                    is in GPT */
 17123                        ;		} else
  Thu May 20 2021 21:37                                                Page 346


 17124                        ;#endif
 17125                        ;		{	/* Get the partition location fr
                    om MBR partition table */
 17126                        ;			pte = buf + (MBR_Table + (ipart 
                    - 1) * SZ_PTE);
 17127                        ;			if (ipart > 4 || pte[PTE_System]
                     == 0) LEAVE_MKFS(FR_MKFS_ABORTED);	/* No partition? */
 17128                        ;			b_vol = ld_dword(pte + PTE_StLba
                    );		/* Get volume start sector */
 17129                        ;			sz_vol = ld_dword(pte + PTE_SizL
                    ba);	/* Get volume size */
 17130                        ;		}
 17131                        ;	} else {	/* The volume is associated with
                     a physical drive */
 17132                        ;		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &
                    sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17133                        ;		if (!(fsopt & FM_SFD)) {	/* To be
                     partitioned? */
 17134                        ;			/* Create a single-partition on 
                    the drive in this function */
 17135                        ;#if FF_LBA64
 17136                        ;			if (sz_vol >= FF_MIN_GPT) {	
                    /* Which partition type to create, MBR or GPT? */
 17137                        ;				fsopt |= 0x80;		
                    /* Partitioning is in GPT */
 17138                        ;				b_vol = GPT_ALIGN / ss; 
                    sz_vol -= b_vol + GPT_ITEMS * SZ_GPTE / ss + 1;	/* Estim
                    ated partition offset and size */
 17139                        ;			} else
 17140                        ;#endif
 17141                        ;			{	/* Partitioning is in MB
                    R */
 17142                        ;				if (sz_vol > N_SEC_TRACK
                    ) {
 17143                        ;					b_vol = N_SEC_TR
                    ACK; sz_vol -= b_vol;	/* Estimated partition offset an
                    d size */
 17144                        ;				}
 17145                        ;			}
 17146                        ;		}
 17147                        ;	}
 17148                        ;	if (sz_vol < 128) LEAVE_MKFS(FR_MKFS_ABORTED);	
                    /* Check if volume size is >=128s */
 17149                        ;
 17150                        ;	/* Now start to create an FAT volume at b_vol an
                    d sz_vol */
 17151                        ;
 17152                        ;	do {	/* Pre-determine the FAT type */
 17153                        ;		if (FF_FS_EXFAT && (fsopt & FM_EXFAT)) {
                    	/* exFAT possible? */
 17154                        ;			if ((fsopt & FM_ANY) == FM_EXFAT
                     || sz_vol >= 0x4000000 || sz_au > 128) {	/* exFAT only, v
                    ol >= 64MS or sz_au > 128S ? */
 17155                        ;				fsty = FS_EXFAT; break;
 17156                        ;			}
 17157                        ;		}
 17158                        ;#if FF_LBA64
 17159                        ;		if (sz_vol >= 0x100000000) LEAVE_MKFS(FR
  Thu May 20 2021 21:37                                                Page 347


                    _MKFS_ABORTED);	/* Too large volume for FAT/FAT32 */
 17160                        ;#endif
 17161                        ;		if (sz_au > 128) sz_au = 128;	/* Inval
                    id AU for FAT/FAT32? */
 17162                        ;		if (fsopt & FM_FAT32) {	/* FAT32 possibl
                    e? */
 17163                        ;			if (!(fsopt & FM_FAT)) {	
                    /* no-FAT? */
 17164                        ;				fsty = FS_FAT32; break;
 17165                        ;			}
 17166                        ;		}
 17167                        ;		if (!(fsopt & FM_FAT)) LEAVE_MKFS(FR_INV
                    ALID_PARAMETER);	/* no-FAT? */
 17168                        ;		fsty = FS_FAT16;
 17169                        ;	} while (0);
 17170                        ;
 17171                        ;	vsn = (DWORD)sz_vol + GET_FATTIME();	/* VSN g
                    enerated from current time and partitiion size */
 17172                        ;
 17173                        ;#if FF_FS_EXFAT
 17174                        ;	if (fsty == FS_EXFAT) {	/* Create an exFAT volum
                    e */
 17175                        ;		DWORD szb_bit, szb_case, sum, nbit, clu,
                     clen[3];
 17176                        ;		WCHAR ch, si;
 17177                        ;		UINT j, st;
 17178                        ;
 17179                        ;		if (sz_vol < 0x1000) LEAVE_MKFS(FR_MKFS_
                    ABORTED);	/* Too small volume for exFAT? */
 17180                        ;#if FF_USE_TRIM
 17181                        ;		lba[0] = b_vol; lba[1] = b_vol + sz_vol 
                    - 1;	/* Inform storage device that the volume area ma
                    y be erased */
 17182                        ;		disk_ioctl(pdrv, CTRL_TRIM, lba);
 17183                        ;#endif
 17184                        ;		/* Determine FAT location, data location
                     and number of clusters */
 17185                        ;		if (sz_au == 0) {	/* AU auto-selec
                    tion */
 17186                        ;			sz_au = 8;
 17187                        ;			if (sz_vol >= 0x80000) sz_au = 6
                    4;		/* >= 512Ks */
 17188                        ;			if (sz_vol >= 0x4000000) sz_au =
                     256;	/* >= 64Ms */
 17189                        ;		}
 17190                        ;		b_fat = b_vol + 32;			
                    							/* FAT s
                    tart at offset 32 */
 17191                        ;		sz_fat = (DWORD)((sz_vol / sz_au + 2) * 
                    4 + ss - 1) / ss;	/* Number of FAT sectors */
 17192                        ;		b_data = (b_fat + sz_fat + sz_blk - 1) &
                     ~((LBA_t)sz_blk - 1);	/* Align data area to the erase 
                    block boundary */
 17193                        ;		if (b_data - b_vol >= sz_vol / 2) LEAVE_
                    MKFS(FR_MKFS_ABORTED);	/* Too small volume? */
 17194                        ;		n_clst = (DWORD)(sz_vol - (b_data - b_vo
                    l)) / sz_au;	/* Number of clusters */
 17195                        ;		if (n_clst <16) LEAVE_MKFS(FR_MKFS_ABORT
  Thu May 20 2021 21:37                                                Page 348


                    ED);			/* Too few clusters? */
 17196                        ;		if (n_clst > MAX_EXFAT) LEAVE_MKFS(FR_MK
                    FS_ABORTED);	/* Too many clusters? */
 17197                        ;
 17198                        ;		szb_bit = (n_clst + 7) / 8;		
                    						/* Size of alloc
                    ation bitmap */
 17199                        ;		clen[0] = (szb_bit + sz_au * ss - 1) / (
                    sz_au * ss);	/* Number of allocation bitmap clusters 
                    */
 17200                        ;
 17201                        ;		/* Create a compressed up-case table */
 17202                        ;		sect = b_data + sz_au * clen[0];	
                    /* Table start sector */
 17203                        ;		sum = 0;				
                    			/* Table checksum to be stored in the 82
                     entry */
 17204                        ;		st = 0; si = 0; i = 0; j = 0; szb_case =
                     0;
 17205                        ;		do {
 17206                        ;			switch (st) {
 17207                        ;			case 0:
 17208                        ;				ch = (WCHAR)ff_wtoupper(
                    si);	/* Get an up-case char */
 17209                        ;				if (ch != si) {
 17210                        ;					si++; break;	
                    	/* Store the up-case char if exist */
 17211                        ;				}
 17212                        ;				for (j = 1; (WCHAR)(si +
                     j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++)
                     ;	/* Get run length of no-case block */
 17213                        ;				if (j >= 128) {
 17214                        ;					ch = 0xFFFF; st 
                    = 2; break;	/* Compress the no-case block if run is >= 128 c
                    hars */
 17215                        ;				}
 17216                        ;				st = 1;			
                    /* Do not compress short run */
 17217                        ;				/* FALLTHROUGH */
 17218                        ;			case 1:
 17219                        ;				ch = si++;		
                    /* Fill the short run */
 17220                        ;				if (--j == 0) st = 0;
 17221                        ;				break;
 17222                        ;
 17223                        ;			default:
 17224                        ;				ch = (WCHAR)j; si += (WC
                    HAR)j;	/* Number of chars to skip */
 17225                        ;				st = 0;
 17226                        ;			}
 17227                        ;			sum = xsum32(buf[i + 0] = (BYTE)
                    ch, sum);	/* Put it into the write buffer */
 17228                        ;			sum = xsum32(buf[i + 1] = (BYTE)
                    (ch >> 8), sum);
 17229                        ;			i += 2; szb_case += 2;
 17230                        ;			if (si == 0 || i == sz_buf * ss)
                     {		/* Write buffered data when buffer full or end o
                    f process */
  Thu May 20 2021 21:37                                                Page 349


 17231                        ;				n = (i + ss - 1) / ss;
 17232                        ;				if (disk_write(pdrv, buf
                    , sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17233                        ;				sect += n; i = 0;
 17234                        ;			}
 17235                        ;		} while (si);
 17236                        ;		clen[1] = (szb_case + sz_au * ss - 1) / 
                    (sz_au * ss);	/* Number of up-case table clusters */
 17237                        ;		clen[2] = 1;	/* Number of root dir cl
                    usters */
 17238                        ;
 17239                        ;		/* Initialize the allocation bitmap */
 17240                        ;		sect = b_data; nsect = (szb_bit + ss - 1
                    ) / ss;	/* Start of bitmap and number of bitmap sectors 
                    */
 17241                        ;		nbit = clen[0] + clen[1] + clen[2];	
                    			/* Number of clusters in-use by system (
                    bitmap, up-case and root-dir) */
 17242                        ;		do {
 17243                        ;			memset(buf, 0, sz_buf * ss);	
                    			/* Initialize bitmap buffer */
 17244                        ;			for (i = 0; nbit != 0 && i / 8 <
                     sz_buf * ss; buf[i / 8] |= 1 << (i % 8), i++, nbit--) ;	
                    /* Mark used clusters */
 17245                        ;			n = (nsect > sz_buf) ? sz_buf : 
                    nsect;		/* Write the buffered data */
 17246                        ;			if (disk_write(pdrv, buf, sect, 
                    n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17247                        ;			sect += n; nsect -= n;
 17248                        ;		} while (nsect);
 17249                        ;
 17250                        ;		/* Initialize the FAT */
 17251                        ;		sect = b_fat; nsect = sz_fat;	/* Start
                     of FAT and number of FAT sectors */
 17252                        ;		j = nbit = clu = 0;
 17253                        ;		do {
 17254                        ;			memset(buf, 0, sz_buf * ss); i =
                     0;	/* Clear work area and reset write offset */
 17255                        ;			if (clu == 0) {	/* Initialize FA
                    T [0] and FAT[1] */
 17256                        ;				st_dword(buf + i, 0xFFFF
                    FFF8); i += 4; clu++;
 17257                        ;				st_dword(buf + i, 0xFFFF
                    FFFF); i += 4; clu++;
 17258                        ;			}
 17259                        ;			do {			/* Creat
                    e chains of bitmap, up-case and root dir */
 17260                        ;				while (nbit != 0 && i < 
                    sz_buf * ss) {	/* Create a chain */
 17261                        ;					st_dword(buf + i
                    , (nbit > 1) ? clu + 1 : 0xFFFFFFFF);
 17262                        ;					i += 4; clu++; n
                    bit--;
 17263                        ;				}
 17264                        ;				if (nbit == 0 && j < 3) 
                    nbit = clen[j++];	/* Get next chain length */
 17265                        ;			} while (nbit != 0 && i < sz_buf
                     * ss);
  Thu May 20 2021 21:37                                                Page 350


 17266                        ;			n = (nsect > sz_buf) ? sz_buf : 
                    nsect;	/* Write the buffered data */
 17267                        ;			if (disk_write(pdrv, buf, sect, 
                    n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17268                        ;			sect += n; nsect -= n;
 17269                        ;		} while (nsect);
 17270                        ;
 17271                        ;		/* Initialize the root directory */
 17272                        ;		memset(buf, 0, sz_buf * ss);
 17273                        ;		buf[SZDIRE * 0 + 0] = ET_VLABEL;	
                    			/* Volume label entry (no label) */
 17274                        ;		buf[SZDIRE * 1 + 0] = ET_BITMAP;	
                    			/* Bitmap entry */
 17275                        ;		st_dword(buf + SZDIRE * 1 + 20, 2);	
                    			/*  cluster */
 17276                        ;		st_dword(buf + SZDIRE * 1 + 24, szb_bit)
                    ;		/*  size */
 17277                        ;		buf[SZDIRE * 2 + 0] = ET_UPCASE;	
                    			/* Up-case table entry */
 17278                        ;		st_dword(buf + SZDIRE * 2 + 4, sum);	
                    		/*  sum */
 17279                        ;		st_dword(buf + SZDIRE * 2 + 20, 2 + clen
                    [0]);	/*  cluster */
 17280                        ;		st_dword(buf + SZDIRE * 2 + 24, szb_case
                    );		/*  size */
 17281                        ;		sect = b_data + sz_au * (clen[0] + clen[
                    1]); nsect = sz_au;	/* Start of the root directory and numbe
                    r of sectors */
 17282                        ;		do {	/* Fill root directory sectors *
                    /
 17283                        ;			n = (nsect > sz_buf) ? sz_buf : 
                    nsect;
 17284                        ;			if (disk_write(pdrv, buf, sect, 
                    n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17285                        ;			memset(buf, 0, ss);	/* Rest 
                    of entries are filled with zero */
 17286                        ;			sect += n; nsect -= n;
 17287                        ;		} while (nsect);
 17288                        ;
 17289                        ;		/* Create two set of the exFAT VBR block
                    s */
 17290                        ;		sect = b_vol;
 17291                        ;		for (n = 0; n < 2; n++) {
 17292                        ;			/* Main record (+0) */
 17293                        ;			memset(buf, 0, ss);
 17294                        ;			memcpy(buf + BS_JmpBoot, "\xEB\x
                    76\x90" "EXFAT   ", 11);	/* Boot jump code (x86), OEM nam
                    e */
 17295                        ;			st_qword(buf + BPB_VolOfsEx, b_v
                    ol);					/* Volume offset
                     in the physical drive [sector] */
 17296                        ;			st_qword(buf + BPB_TotSecEx, sz_
                    vol);					/* Volume size [
                    sector] */
 17297                        ;			st_dword(buf + BPB_FatOfsEx, (DW
                    ORD)(b_fat - b_vol));	/* FAT offset [sector] */
 17298                        ;			st_dword(buf + BPB_FatSzEx, sz_f
                    at);					/* FAT size [sec
  Thu May 20 2021 21:37                                                Page 351


                    tor] */
 17299                        ;			st_dword(buf + BPB_DataOfsEx, (D
                    WORD)(b_data - b_vol));	/* Data offset [sector] */
 17300                        ;			st_dword(buf + BPB_NumClusEx, n_
                    clst);					/* Number of clu
                    sters */
 17301                        ;			st_dword(buf + BPB_RootClusEx, 2
                     + clen[0] + clen[1]);	/* Root dir cluster # */
 17302                        ;			st_dword(buf + BPB_VolIDEx, vsn)
                    ;						/* VSN */
 17303                        ;			st_word(buf + BPB_FSVerEx, 0x100
                    );						/* Filesystem ve
                    rsion (1.00) */
 17304                        ;			for (buf[BPB_BytsPerSecEx] = 0, 
                    i = ss; i >>= 1; buf[BPB_BytsPerSecEx]++) ;	/* Log2 of secto
                    r size [byte] */
 17305                        ;			for (buf[BPB_SecPerClusEx] = 0, 
                    i = sz_au; i >>= 1; buf[BPB_SecPerClusEx]++) ;	/* Log2 
                    of cluster size [sector] */
 17306                        ;			buf[BPB_NumFATsEx] = 1;		
                    			/* Number of FATs */
 17307                        ;			buf[BPB_DrvNumEx] = 0x80;	
                    			/* Drive number (for int13) */
 17308                        ;			st_word(buf + BS_BootCodeEx, 0xF
                    EEB);	/* Boot code (x86) */
 17309                        ;			st_word(buf + BS_55AA, 0xAA55);	
                    		/* Signature (placed here regardless of sector s
                    ize) */
 17310                        ;			for (i = sum = 0; i < ss; i++) {
                    		/* VBR checksum */
 17311                        ;				if (i != BPB_VolFlagEx &
                    & i != BPB_VolFlagEx + 1 && i != BPB_PercInUseEx) sum = xsum
                    32(buf[i], sum);
 17312                        ;			}
 17313                        ;			if (disk_write(pdrv, buf, sect++
                    , 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17314                        ;			/* Extended bootstrap record (+1
                    ..+8) */
 17315                        ;			memset(buf, 0, ss);
 17316                        ;			st_word(buf + ss - 2, 0xAA55);	
                    /* Signature (placed at end of sector) */
 17317                        ;			for (j = 1; j < 9; j++) {
 17318                        ;				for (i = 0; i < ss; sum 
                    = xsum32(buf[i++], sum)) ;	/* VBR checksum */
 17319                        ;				if (disk_write(pdrv, buf
                    , sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17320                        ;			}
 17321                        ;			/* OEM/Reserved record (+9..+10)
                     */
 17322                        ;			memset(buf, 0, ss);
 17323                        ;			for ( ; j < 11; j++) {
 17324                        ;				for (i = 0; i < ss; sum 
                    = xsum32(buf[i++], sum)) ;	/* VBR checksum */
 17325                        ;				if (disk_write(pdrv, buf
                    , sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17326                        ;			}
 17327                        ;			/* Sum record (+11) */
 17328                        ;			for (i = 0; i < ss; i += 4) st_d
  Thu May 20 2021 21:37                                                Page 352


                    word(buf + i, sum);		/* Fill with checksum value */
 17329                        ;			if (disk_write(pdrv, buf, sect++
                    , 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17330                        ;		}
 17331                        ;
 17332                        ;	} else
 17333                        ;#endif	/* FF_FS_EXFAT */
 17334                        ;	{	/* Create an FAT/FAT32 volume */
 17335                        ;		do {
 17336                        ;			pau = sz_au;
 17337                        ;			/* Pre-determine number of clust
                    ers and FAT sub-type */
 17338                        ;			if (fsty == FS_FAT32) {	/* FAT32
                     volume */
 17339                        ;				if (pau == 0) {	/* AU au
                    to-selection */
 17340                        ;					n = (DWORD)sz_vo
                    l / 0x20000;	/* Volume size in unit of 128KS */
 17341                        ;					for (i = 0, pau 
                    = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;	/* Get f
                    rom table */
 17342                        ;				}
 17343                        ;				n_clst = (DWORD)sz_vol /
                     pau;	/* Number of clusters */
 17344                        ;				sz_fat = (n_clst * 4 + 8
                     + ss - 1) / ss;	/* FAT size [sector] */
 17345                        ;				sz_rsv = 32;	/* Numbe
                    r of reserved sectors */
 17346                        ;				sz_dir = 0;		
                    /* No static directory */
 17347                        ;				if (n_clst <= MAX_FAT16 
                    || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);
 17348                        ;			} else {			
                    	/* FAT volume */
 17349                        ;				if (pau == 0) {	/* au au
                    to-selection */
 17350                        ;					n = (DWORD)sz_vo
                    l / 0x1000;	/* Volume size in unit of 4KS */
 17351                        ;					for (i = 0, pau 
                    = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;	/* Get f
                    rom table */
 17352                        ;				}
 17353                        ;				n_clst = (DWORD)sz_vol /
                     pau;
 17354                        ;				if (n_clst > MAX_FAT12) 
                    {
 17355                        ;					n = n_clst * 2 +
                     4;		/* FAT size [byte] */
 17356                        ;				} else {
 17357                        ;					fsty = FS_FAT12;
 17358                        ;					n = (n_clst * 3 
                    + 1) / 2 + 3;	/* FAT size [byte] */
 17359                        ;				}
 17360                        ;				sz_fat = (n + ss - 1) / 
                    ss;		/* FAT size [sector] */
 17361                        ;				sz_rsv = 1;		
                    				/* Number of reserved sectors */
 17362                        ;				sz_dir = (DWORD)n_root *
  Thu May 20 2021 21:37                                                Page 353


                     SZDIRE / ss;	/* Root dir size [sector] */
 17363                        ;			}
 17364                        ;			b_fat = b_vol + sz_rsv;		
                    				/* FAT base */
 17365                        ;			b_data = b_fat + sz_fat * n_fat 
                    + sz_dir;	/* Data base */
 17366                        ;
 17367                        ;			/* Align data area to erase bloc
                    k boundary (for flash memory media) */
 17368                        ;			n = (DWORD)(((b_data + sz_blk - 
                    1) & ~(sz_blk - 1)) - b_data);	/* Sectors to next neare
                    st from current data base */
 17369                        ;			if (fsty == FS_FAT32) {		
                    /* FAT32: Move FAT */
 17370                        ;				sz_rsv += n; b_fat += n;
 17371                        ;			} else {			
                    		/* FAT: Expand FAT */
 17372                        ;				if (n % n_fat) {	
                    /* Adjust fractional error if needed */
 17373                        ;					n--; sz_rsv++; b
                    _fat++;
 17374                        ;				}
 17375                        ;				sz_fat += n / n_fat;
 17376                        ;			}
 17377                        ;
 17378                        ;			/* Determine number of clusters 
                    and final check of validity of the FAT sub-type */
 17379                        ;			if (sz_vol < b_data + pau * 16 -
                     b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small vol
                    ume? */
 17380                        ;			n_clst = ((DWORD)sz_vol - sz_rsv
                     - sz_fat * n_fat - sz_dir) / pau;
 17381                        ;			if (fsty == FS_FAT32) {
 17382                        ;				if (n_clst <= MAX_FAT16)
                     {	/* Too few clusters for FAT32? */
 17383                        ;					if (sz_au == 0 &
                    & (sz_au = pau / 2) != 0) continue;	/* Adjust cluster size a
                    nd retry */
 17384                        ;					LEAVE_MKFS(FR_MK
                    FS_ABORTED);
 17385                        ;				}
 17386                        ;			}
 17387                        ;			if (fsty == FS_FAT16) {
 17388                        ;				if (n_clst > MAX_FAT16) 
                    {	/* Too many clusters for FAT16 */
 17389                        ;					if (sz_au == 0 &
                    & (pau * 2) <= 64) {
 17390                        ;						sz_au = 
                    pau * 2; continue;	/* Adjust cluster size and retry */
 17391                        ;					}
 17392                        ;					if ((fsopt & FM_
                    FAT32)) {
 17393                        ;						fsty = F
                    S_FAT32; continue;	/* Switch type to FAT32 and retry */
 17394                        ;					}
 17395                        ;					if (sz_au == 0 &
                    & (sz_au = pau * 2) <= 128) continue;	/* Adjust cluste
                    r size and retry */
  Thu May 20 2021 21:37                                                Page 354


 17396                        ;					LEAVE_MKFS(FR_MK
                    FS_ABORTED);
 17397                        ;				}
 17398                        ;				if  (n_clst <= MAX_FAT12
                    ) {	/* Too few clusters for FAT16 */
 17399                        ;					if (sz_au == 0 &
                    & (sz_au = pau * 2) <= 128) continue;	/* Adjust cluste
                    r size and retry */
 17400                        ;					LEAVE_MKFS(FR_MK
                    FS_ABORTED);
 17401                        ;				}
 17402                        ;			}
 17403                        ;			if (fsty == FS_FAT12 && n_clst >
                     MAX_FAT12) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clus
                    ters for FAT12 */
 17404                        ;
 17405                        ;			/* Ok, it is the valid cluster c
                    onfiguration */
 17406                        ;			break;
 17407                        ;		} while (1);
 17408                        ;
 17409                        ;#if FF_USE_TRIM
 17410                        ;		lba[0] = b_vol; lba[1] = b_vol + sz_vol 
                    - 1;	/* Inform storage device that the volume area ma
                    y be erased */
 17411                        ;		disk_ioctl(pdrv, CTRL_TRIM, lba);
 17412                        ;#endif
 17413                        ;		/* Create FAT VBR */
 17414                        ;		memset(buf, 0, ss);
 17415                        ;		memcpy(buf + BS_JmpBoot, "\xEB\xFE\x90" 
                    "MSDOS5.0", 11);	/* Boot jump code (x86), OEM name */
 17416                        ;		st_word(buf + BPB_BytsPerSec, ss);	
                    			/* Sector size [byte] */
 17417                        ;		buf[BPB_SecPerClus] = (BYTE)pau;	
                    			/* Cluster size [sector] */
 17418                        ;		st_word(buf + BPB_RsvdSecCnt, (WORD)sz_r
                    sv);	/* Size of reserved area */
 17419                        ;		buf[BPB_NumFATs] = (BYTE)n_fat;		
                    			/* Number of FATs */
 17420                        ;		st_word(buf + BPB_RootEntCnt, (WORD)((fs
                    ty == FS_FAT32) ? 0 : n_root));	/* Number of root direct
                    ory entries */
 17421                        ;		if (sz_vol < 0x10000) {
 17422                        ;			st_word(buf + BPB_TotSec16, (WOR
                    D)sz_vol);	/* Volume size in 16-bit LBA */
 17423                        ;		} else {
 17424                        ;			st_dword(buf + BPB_TotSec32, (DW
                    ORD)sz_vol);	/* Volume size in 32-bit LBA */
 17425                        ;		}
 17426                        ;		buf[BPB_Media] = 0xF8;			
                    				/* Media descriptor byte */
 17427                        ;		st_word(buf + BPB_SecPerTrk, 63);	
                    			/* Number of sectors per track (for int1
                    3) */
 17428                        ;		st_word(buf + BPB_NumHeads, 255);	
                    			/* Number of heads (for int13) */
 17429                        ;		st_dword(buf + BPB_HiddSec, (DWORD)b_vol
                    );		/* Volume offset in the physical drive [sector] 
  Thu May 20 2021 21:37                                                Page 355


                    */
 17430                        ;		if (fsty == FS_FAT32) {
 17431                        ;			st_dword(buf + BS_VolID32, vsn);
                    			/* VSN */
 17432                        ;			st_dword(buf + BPB_FATSz32, sz_f
                    at);		/* FAT size [sector] */
 17433                        ;			st_dword(buf + BPB_RootClus32, 2
                    );			/* Root directory cluster # (2) */
 17434                        ;			st_word(buf + BPB_FSInfo32, 1);	
                    			/* Offset of FSINFO sector (VBR + 1) */
 17435                        ;			st_word(buf + BPB_BkBootSec32, 6
                    );			/* Offset of backup VBR (VBR + 6) */
 17436                        ;			buf[BS_DrvNum32] = 0x80;	
                    				/* Drive number (for int13) */
 17437                        ;			buf[BS_BootSig32] = 0x29;	
                    				/* Extended boot signature */
 17438                        ;			memcpy(buf + BS_VolLab32, "NO NA
                    ME    " "FAT32   ", 19);	/* Volume label, FAT signature *
                    /
 17439                        ;		} else {
 17440                        ;			st_dword(buf + BS_VolID, vsn);	
                    			/* VSN */
 17441                        ;			st_word(buf + BPB_FATSz16, (WORD
                    )sz_fat);	/* FAT size [sector] */
 17442                        ;			buf[BS_DrvNum] = 0x80;		
                    				/* Drive number (for int13) */
 17443                        ;			buf[BS_BootSig] = 0x29;		
                    				/* Extended boot signature */
 17444                        ;			memcpy(buf + BS_VolLab, "NO NAME
                        " "FAT     ", 19);	/* Volume label, FAT signature *
                    /
 17445                        ;		}
 17446                        ;		st_word(buf + BS_55AA, 0xAA55);		
                    			/* Signature (offset is fixed here regar
                    dless of sector size) */
 17447                        ;		if (disk_write(pdrv, buf, b_vol, 1) != R
                    ES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it to the VBR s
                    ector */
 17448                        ;
 17449                        ;		/* Create FSINFO record if needed */
 17450                        ;		if (fsty == FS_FAT32) {
 17451                        ;			disk_write(pdrv, buf, b_vol + 6,
                     1);		/* Write backup VBR (VBR + 6) */
 17452                        ;			memset(buf, 0, ss);
 17453                        ;			st_dword(buf + FSI_LeadSig, 0x41
                    615252);
 17454                        ;			st_dword(buf + FSI_StrucSig, 0x6
                    1417272);
 17455                        ;			st_dword(buf + FSI_Free_Count, n
                    _clst - 1);	/* Number of free clusters */
 17456                        ;			st_dword(buf + FSI_Nxt_Free, 2);
                    			/* Last allocated cluster# */
 17457                        ;			st_word(buf + BS_55AA, 0xAA55);
 17458                        ;			disk_write(pdrv, buf, b_vol + 7,
                     1);		/* Write backup FSINFO (VBR + 7) */
 17459                        ;			disk_write(pdrv, buf, b_vol + 1,
                     1);		/* Write original FSINFO (VBR + 1) */
 17460                        ;		}
  Thu May 20 2021 21:37                                                Page 356


 17461                        ;
 17462                        ;		/* Initialize FAT area */
 17463                        ;		memset(buf, 0, sz_buf * ss);
 17464                        ;		sect = b_fat;		/* FAT start sec
                    tor */
 17465                        ;		for (i = 0; i < n_fat; i++) {		
                    	/* Initialize FATs each */
 17466                        ;			if (fsty == FS_FAT32) {
 17467                        ;				st_dword(buf + 0, 0xFFFF
                    FFF8);	/* FAT[0] */
 17468                        ;				st_dword(buf + 4, 0xFFFF
                    FFFF);	/* FAT[1] */
 17469                        ;				st_dword(buf + 8, 0x0FFF
                    FFFF);	/* FAT[2] (root directory) */
 17470                        ;			} else {
 17471                        ;				st_dword(buf + 0, (fsty 
                    == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);	/* FAT[0] and FA
                    T[1] */
 17472                        ;			}
 17473                        ;			nsect = sz_fat;		/* Numbe
                    r of FAT sectors */
 17474                        ;			do {	/* Fill FAT sectors */
 17475                        ;				n = (nsect > sz_buf) ? s
                    z_buf : nsect;
 17476                        ;				if (disk_write(pdrv, buf
                    , sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17477                        ;				memset(buf, 0, ss);	
                    /* Rest of FAT all are cleared */
 17478                        ;				sect += n; nsect -= n;
 17479                        ;			} while (nsect);
 17480                        ;		}
 17481                        ;
 17482                        ;		/* Initialize root directory (fill with 
                    zero) */
 17483                        ;		nsect = (fsty == FS_FAT32) ? pau : sz_di
                    r;	/* Number of root directory sectors */
 17484                        ;		do {
 17485                        ;			n = (nsect > sz_buf) ? sz_buf : 
                    nsect;
 17486                        ;			if (disk_write(pdrv, buf, sect, 
                    (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);
 17487                        ;			sect += n; nsect -= n;
 17488                        ;		} while (nsect);
 17489                        ;	}
 17490                        ;
 17491                        ;	/* A FAT volume has been created here */
 17492                        ;
 17493                        ;	/* Determine system ID in the MBR partition tabl
                    e */
 17494                        ;	if (FF_FS_EXFAT && fsty == FS_EXFAT) {
 17495                        ;		sys = 0x07;			/* exFAT
                     */
 17496                        ;	} else {
 17497                        ;		if (fsty == FS_FAT32) {
 17498                        ;			sys = 0x0C;		/* FAT32
                    X */
 17499                        ;		} else {
 17500                        ;			if (sz_vol >= 0x10000) {
  Thu May 20 2021 21:37                                                Page 357


 17501                        ;				sys = 0x06;	/* FAT12
                    /16 (large) */
 17502                        ;			} else {
 17503                        ;				sys = (fsty == FS_FAT16)
                     ? 0x04 : 0x01;	/* FAT16 : FAT12 */
 17504                        ;			}
 17505                        ;		}
 17506                        ;	}
 17507                        ;
 17508                        ;	/* Update partition information */
 17509                        ;	if (FF_MULTI_PARTITION && ipart != 0) {	/* Volum
                    e is in the existing partition */
 17510                        ;		if (!FF_LBA64 || !(fsopt & 0x80)) {
 17511                        ;			/* Update system ID in the parti
                    tion table */
 17512                        ;			if (disk_read(pdrv, buf, 0, 1) !
                    = RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Read the MBR */
 17513                        ;			buf[MBR_Table + (ipart - 1) * SZ
                    _PTE + PTE_System] = sys;			/* Set system ID
                     */
 17514                        ;			if (disk_write(pdrv, buf, 0, 1) 
                    != RES_OK) LEAVE_MKFS(FR_DISK_ERR);	/* Write it back to the 
                    MBR */
 17515                        ;		}
 17516                        ;	} else {					
                    			/* Volume as a new single partition */
 17517                        ;		if (!(fsopt & FM_SFD)) {		
                    	/* Create partition table if not in SFD */
 17518                        ;			lba[0] = sz_vol; lba[1] = 0;
 17519                        ;			fr = create_partition(pdrv, lba,
                     sys, buf);
 17520                        ;			if (fr != FR_OK) LEAVE_MKFS(fr);
 17521                        ;		}
 17522                        ;	}
 17523                        ;
 17524                        ;	if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) LE
                    AVE_MKFS(FR_DISK_ERR);
 17525                        ;
 17526                        ;	LEAVE_MKFS(FR_OK);
 17527                        ;}
 17528                        ;
 17529                        ;
 17530                        ;
 17531                        ;
 17532                        ;#if FF_MULTI_PARTITION
 17533                        ;/*-----------------------------------------------
                    ------------------------*/
 17534                        ;/* Create Partition Table on the Physical Drive  
                                            */
 17535                        ;/*-----------------------------------------------
                    ------------------------*/
 17536                        ;
 17537                        ;FRESULT f_fdisk (
 17538                        ;	BYTE pdrv,			/* Physical driv
                    e number */
 17539                        ;	const LBA_t ptbl[],	/* Pointer to the size t
                    able for each partitions */
 17540                        ;	void* work			/* Pointer to th
  Thu May 20 2021 21:37                                                Page 358


                    e working buffer (null: use heap memory) */
 17541                        ;)
 17542                        ;{
 17543                        ;	BYTE *buf = (BYTE*)work;
 17544                        ;	DSTATUS stat;
 17545                        ;
 17546                        ;
 17547                        ;	stat = disk_initialize(pdrv);
 17548                        ;	if (stat & STA_NOINIT) return FR_NOT_READY;
 17549                        ;	if (stat & STA_PROTECT) return FR_WRITE_PROTECTE
                    D;
 17550                        ;#if FF_USE_LFN == 3
 17551                        ;	if (!buf) buf = ff_memalloc(FF_MAX_SS);	/* Use h
                    eap memory for working buffer */
 17552                        ;#endif
 17553                        ;	if (!buf) return FR_NOT_ENOUGH_CORE;
 17554                        ;
 17555                        ;	LEAVE_MKFS(create_partition(pdrv, ptbl, 0x07, bu
                    f));
 17556                        ;}
 17557                        ;
 17558                        ;#endif /* FF_MULTI_PARTITION */
 17559                        ;#endif /* !FF_FS_READONLY && FF_USE_MKFS */
 17560                        ;
 17561                        ;
 17562                        ;
 17563                        ;
 17564                        ;#if FF_USE_STRFUNC
 17565                        ;#if FF_USE_LFN && FF_LFN_UNICODE && (FF_STRF_ENCO
                    DE < 0 || FF_STRF_ENCODE > 3)
 17566                        ;#error Wrong FF_STRF_ENCODE setting
 17567                        ;#endif
 17568                        ;/*-----------------------------------------------
                    ------------------------*/
 17569                        ;/* Get a String from the File                    
                                            */
 17570                        ;/*-----------------------------------------------
                    ------------------------*/
 17571                        ;
 17572                        ;TCHAR* f_gets (
 17573                        ;	TCHAR* buff,	/* Pointer to the buffer to stor
                    e read string */
 17574                        ;	int len,		/* Size of string buffer
                     (items) */
 17575                        ;	FIL* fp			/* Pointer to the file o
                    bject */
 17576                        ;)
 17577                        ;{
 17578                        ;	int nc = 0;
 17579                        ;	TCHAR *p = buff;
 17580                        ;	BYTE s[4];
 17581                        ;	UINT rc;
 17582                        ;	DWORD dc;
 17583                        ;#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCOD
                    E <= 2
 17584                        ;	WCHAR wc;
 17585                        ;#endif
 17586                        ;#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCOD
  Thu May 20 2021 21:37                                                Page 359


                    E == 3
 17587                        ;	UINT ct;
 17588                        ;#endif
 17589                        ;
 17590                        ;#if FF_USE_LFN && FF_LFN_UNICODE			
                    /* With code conversion (Unicode API) */
 17591                        ;	/* Make a room for the character and terminator 
                     */
 17592                        ;	if (FF_LFN_UNICODE == 1) len -= (FF_STRF_ENCODE 
                    == 0) ? 1 : 2;
 17593                        ;	if (FF_LFN_UNICODE == 2) len -= (FF_STRF_ENCODE 
                    == 0) ? 3 : 4;
 17594                        ;	if (FF_LFN_UNICODE == 3) len -= 1;
 17595                        ;	while (nc < len) {
 17596                        ;#if FF_STRF_ENCODE == 0				
                    /* Read a character in ANSI/OEM */
 17597                        ;		f_read(fp, s, 1, &rc);		/* Get a
                     code unit */
 17598                        ;		if (rc != 1) break;			
                    /* EOF? */
 17599                        ;		wc = s[0];
 17600                        ;		if (dbc_1st((BYTE)wc)) {	/* DBC 1
                    st byte? */
 17601                        ;			f_read(fp, s, 1, &rc);	/* Get 2
                    nd byte */
 17602                        ;			if (rc != 1 || !dbc_2nd(s[0])) c
                    ontinue;	/* Wrong code? */
 17603                        ;			wc = wc << 8 | s[0];
 17604                        ;		}
 17605                        ;		dc = ff_oem2uni(wc, CODEPAGE);	/* Conve
                    rt ANSI/OEM into Unicode */
 17606                        ;		if (dc == 0) continue;		/* Conve
                    rsion error? */
 17607                        ;#elif FF_STRF_ENCODE == 1 || FF_STRF_ENCODE == 2 
                    	/* Read a character in UTF-16LE/BE */
 17608                        ;		f_read(fp, s, 2, &rc);		/* Get a
                     code unit */
 17609                        ;		if (rc != 2) break;			
                    /* EOF? */
 17610                        ;		dc = (FF_STRF_ENCODE == 1) ? ld_word(s) 
                    : s[0] << 8 | s[1];
 17611                        ;		if (IsSurrogateL(dc)) continue;	/* Broke
                    n surrogate pair? */
 17612                        ;		if (IsSurrogateH(dc)) {		/* High 
                    surrogate? */
 17613                        ;			f_read(fp, s, 2, &rc);	/* Get l
                    ow surrogate */
 17614                        ;			if (rc != 2) break;		
                    /* EOF? */
 17615                        ;			wc = (FF_STRF_ENCODE == 1) ? ld_
                    word(s) : s[0] << 8 | s[1];
 17616                        ;			if (!IsSurrogateL(wc)) continue;
                    	/* Broken surrogate pair? */
 17617                        ;			dc = ((dc & 0x3FF) + 0x40) << 10
                     | (wc & 0x3FF);	/* Merge surrogate pair */
 17618                        ;		}
 17619                        ;#else	/* Read a character in UTF-8 */
 17620                        ;		f_read(fp, s, 1, &rc);		/* Get a
  Thu May 20 2021 21:37                                                Page 360


                     code unit */
 17621                        ;		if (rc != 1) break;			
                    /* EOF? */
 17622                        ;		dc = s[0];
 17623                        ;		if (dc >= 0x80) {			
                    /* Multi-byte sequence? */
 17624                        ;			ct = 0;
 17625                        ;			if ((dc & 0xE0) == 0xC0) { dc &=
                     0x1F; ct = 1; }	/* 2-byte sequence? */
 17626                        ;			if ((dc & 0xF0) == 0xE0) { dc &=
                     0x0F; ct = 2; }	/* 3-byte sequence? */
 17627                        ;			if ((dc & 0xF8) == 0xF0) { dc &=
                     0x07; ct = 3; }	/* 4-byte sequence? */
 17628                        ;			if (ct == 0) continue;
 17629                        ;			f_read(fp, s, ct, &rc);	/* Get t
                    railing bytes */
 17630                        ;			if (rc != ct) break;
 17631                        ;			rc = 0;
 17632                        ;			do {	/* Merge the byte sequen
                    ce */
 17633                        ;				if ((s[rc] & 0xC0) != 0x
                    80) break;
 17634                        ;				dc = dc << 6 | (s[rc] & 
                    0x3F);
 17635                        ;			} while (++rc < ct);
 17636                        ;			if (rc != ct || dc < 0x80 || IsS
                    urrogate(dc) || dc >= 0x110000) continue;	/* Wrong encodin
                    g? */
 17637                        ;		}
 17638                        ;#endif
 17639                        ;		/* A code point is avaialble in dc to be
                     output */
 17640                        ;
 17641                        ;		if (FF_USE_STRFUNC == 2 && dc == '\r') c
                    ontinue;	/* Strip \r off if needed */
 17642                        ;#if FF_LFN_UNICODE == 1	|| FF_LFN_UNICODE == 3	
                    /* Output it in UTF-16/32 encoding */
 17643                        ;		if (FF_LFN_UNICODE == 1 && dc >= 0x10000
                    ) {	/* Out of BMP at UTF-16? */
 17644                        ;			*p++ = (TCHAR)(0xD800 | ((dc >> 
                    10) - 0x40)); nc++;	/* Make and output high surrogate */
 17645                        ;			dc = 0xDC00 | (dc & 0x3FF);	
                    	/* Make low surrogate */
 17646                        ;		}
 17647                        ;		*p++ = (TCHAR)dc; nc++;
 17648                        ;		if (dc == '\n') break;	/* End of line? 
                    */
 17649                        ;#elif FF_LFN_UNICODE == 2		/* Outpu
                    t it in UTF-8 encoding */
 17650                        ;		if (dc < 0x80) {	/* Single byte? 
                    */
 17651                        ;			*p++ = (TCHAR)dc;
 17652                        ;			nc++;
 17653                        ;			if (dc == '\n') break;	/* End o
                    f line? */
 17654                        ;		} else {
 17655                        ;			if (dc < 0x800) {		
                    /* 2-byte sequence? */
  Thu May 20 2021 21:37                                                Page 361


 17656                        ;				*p++ = (TCHAR)(0xC0 | (d
                    c >> 6 & 0x1F));
 17657                        ;				*p++ = (TCHAR)(0x80 | (d
                    c >> 0 & 0x3F));
 17658                        ;				nc += 2;
 17659                        ;			} else {
 17660                        ;				if (dc < 0x10000) {	
                    /* 3-byte sequence? */
 17661                        ;					*p++ = (TCHAR)(0
                    xE0 | (dc >> 12 & 0x0F));
 17662                        ;					*p++ = (TCHAR)(0
                    x80 | (dc >> 6 & 0x3F));
 17663                        ;					*p++ = (TCHAR)(0
                    x80 | (dc >> 0 & 0x3F));
 17664                        ;					nc += 3;
 17665                        ;				} else {		
                    	/* 4-byte sequence? */
 17666                        ;					*p++ = (TCHAR)(0
                    xF0 | (dc >> 18 & 0x07));
 17667                        ;					*p++ = (TCHAR)(0
                    x80 | (dc >> 12 & 0x3F));
 17668                        ;					*p++ = (TCHAR)(0
                    x80 | (dc >> 6 & 0x3F));
 17669                        ;					*p++ = (TCHAR)(0
                    x80 | (dc >> 0 & 0x3F));
 17670                        ;					nc += 4;
 17671                        ;				}
 17672                        ;			}
 17673                        ;		}
 17674                        ;#endif
 17675                        ;	}
 17676                        ;
 17677                        ;#else			/* Byte-by-byte read wit
                    hout any conversion (ANSI/OEM API) */
 17678                        ;	len -= 1;	/* Make a room for the terminato
                    r */
 17679                        ;	while (nc < len) {
 17680                        ;		f_read(fp, s, 1, &rc);	/* Get a byte */
 17681                        ;		if (rc != 1) break;		/* EOF? 
                    */
 17682                        ;		dc = s[0];
 17683                        ;		if (FF_USE_STRFUNC == 2 && dc == '\r') c
                    ontinue;
 17684                        ;		*p++ = (TCHAR)dc; nc++;
 17685                        ;		if (dc == '\n') break;
 17686                        ;	}
 17687                        ;#endif
 17688                        ;
 17689                        ;	*p = 0;		/* Terminate the string */
 17690                        ;	return nc ? buff : 0;	/* When no data read due
                     to EOF or error, return with error. */
 17691                        ;}
 17692                        ;
 17693                        ;
 17694                        ;
 17695                        ;
 17696                        ;#if !FF_FS_READONLY
 17697                        ;#include <stdarg.h>
  Thu May 20 2021 21:37                                                Page 362


 17698                        ;#define SZ_PUTC_BUF	64
 17699                        ;#define SZ_NUM_BUF	32
 17700                        ;
 17701                        ;/*-----------------------------------------------
                    ------------------------*/
 17702                        ;/* Put a Character to the File (with sub-function
                    s)                      */
 17703                        ;/*-----------------------------------------------
                    ------------------------*/
 17704                        ;
 17705                        ;/* Output buffer and work area */
 17706                        ;
 17707                        ;typedef struct {
 17708                        ;	FIL *fp;		/* Ptr to the writing fi
                    le */
 17709                        ;	int idx, nchr;	/* Write index of buf[] (-1:erro
                    r), number of encoding units written */
 17710                        ;#if FF_USE_LFN && FF_LFN_UNICODE == 1
 17711                        ;	WCHAR hs;
 17712                        ;#elif FF_USE_LFN && FF_LFN_UNICODE == 2
 17713                        ;	BYTE bs[4];
 17714                        ;	UINT wi, ct;
 17715                        ;#endif
 17716                        ;	BYTE buf[SZ_PUTC_BUF];	/* Write buffer */
 17717                        ;} putbuff;
 17718                        ;
 17719                        ;
 17720                        ;/* Buffered file write with code conversion */
 17721                        ;
 17722                        ;static void putc_bfd (putbuff* pb, TCHAR c)
 17723                        ;{
 17724                        ;	UINT n;
 17725                        ;	int i, nc;
 17726                        ;#if FF_USE_LFN && FF_LFN_UNICODE
 17727                        ;	WCHAR hs, wc;
 17728                        ;#if FF_LFN_UNICODE == 2
 17729                        ;	DWORD dc;
 17730                        ;	const TCHAR *tp;
 17731                        ;#endif
 17732                        ;#endif
 17733                        ;
 17734                        ;	if (FF_USE_STRFUNC == 2 && c == '\n') {	 /* LF -
                    > CRLF conversion */
 17735                        ;		putc_bfd(pb, '\r');
 17736                        ;	}
 17737                        ;
 17738                        ;	i = pb->idx;			/* Write index o
                    f pb->buf[] */
 17739                        ;	if (i < 0) return;		/* In write erro
                    r? */
 17740                        ;	nc = pb->nchr;			/* Write unit co
                    unter */
 17741                        ;
 17742                        ;#if FF_USE_LFN && FF_LFN_UNICODE
 17743                        ;#if FF_LFN_UNICODE == 1		/* UTF-16 input 
                    */
 17744                        ;	if (IsSurrogateH(c)) {	/* High surrogate? */
 17745                        ;		pb->hs = c; return;	/* Save it for n
  Thu May 20 2021 21:37                                                Page 363


                    ext */
 17746                        ;	}
 17747                        ;	hs = pb->hs; pb->hs = 0;
 17748                        ;	if (hs != 0) {			/* There is a le
                    ading high surrogate */
 17749                        ;		if (!IsSurrogateL(c)) hs = 0;	/* Disca
                    rd high surrogate if not a surrogate pair */
 17750                        ;	} else {
 17751                        ;		if (IsSurrogateL(c)) return;	/* Disca
                    rd stray low surrogate */
 17752                        ;	}
 17753                        ;	wc = c;
 17754                        ;#elif FF_LFN_UNICODE == 2	/* UTF-8 input *
                    /
 17755                        ;	for (;;) {
 17756                        ;		if (pb->ct == 0) {	/* Out of multi-
                    byte sequence? */
 17757                        ;			pb->bs[pb->wi = 0] = (BYTE)c;	
                    /* Save 1st byte */
 17758                        ;			if ((BYTE)c < 0x80) break;	
                    				/* Single byte? */
 17759                        ;			if (((BYTE)c & 0xE0) == 0xC0) pb
                    ->ct = 1;	/* 2-byte sequence? */
 17760                        ;			if (((BYTE)c & 0xF0) == 0xE0) pb
                    ->ct = 2;	/* 3-byte sequence? */
 17761                        ;			if (((BYTE)c & 0xF1) == 0xF0) pb
                    ->ct = 3;	/* 4-byte sequence? */
 17762                        ;			return;
 17763                        ;		} else {				
                    /* In the multi-byte sequence */
 17764                        ;			if (((BYTE)c & 0xC0) != 0x80) {	
                    /* Broken sequence? */
 17765                        ;				pb->ct = 0; continue;
 17766                        ;			}
 17767                        ;			pb->bs[++pb->wi] = (BYTE)c;	
                    /* Save the trailing byte */
 17768                        ;			if (--pb->ct == 0) break;	
                    /* End of multi-byte sequence? */
 17769                        ;			return;
 17770                        ;		}
 17771                        ;	}
 17772                        ;	tp = (const TCHAR*)pb->bs;
 17773                        ;	dc = tchar2uni(&tp);	/* UTF-8 ==> UTF-16 */
 17774                        ;	if (dc == 0xFFFFFFFF) return;	/* Wrong code? *
                    /
 17775                        ;	wc = (WCHAR)dc;
 17776                        ;	hs = (WCHAR)(dc >> 16);
 17777                        ;#elif FF_LFN_UNICODE == 3	/* UTF-32 input 
                    */
 17778                        ;	if (IsSurrogate(c) || c >= 0x110000) return;	
                    /* Discard invalid code */
 17779                        ;	if (c >= 0x10000) {		/* Out of BMP? *
                    /
 17780                        ;		hs = (WCHAR)(0xD800 | ((c >> 10) - 0x40)
                    ); 	/* Make high surrogate */
 17781                        ;		wc = 0xDC00 | (c & 0x3FF);		
                    			/* Make low surrogate */
 17782                        ;	} else {
  Thu May 20 2021 21:37                                                Page 364


 17783                        ;		hs = 0;
 17784                        ;		wc = (WCHAR)c;
 17785                        ;	}
 17786                        ;#endif
 17787                        ;	/* A code point in UTF-16 is available in hs and
                     wc */
 17788                        ;
 17789                        ;#if FF_STRF_ENCODE == 1		/* Write a code 
                    point in UTF-16LE */
 17790                        ;	if (hs != 0) {	/* Surrogate pair? */
 17791                        ;		st_word(&pb->buf[i], hs);
 17792                        ;		i += 2;
 17793                        ;		nc++;
 17794                        ;	}
 17795                        ;	st_word(&pb->buf[i], wc);
 17796                        ;	i += 2;
 17797                        ;#elif FF_STRF_ENCODE == 2	/* Write a code 
                    point in UTF-16BE */
 17798                        ;	if (hs != 0) {	/* Surrogate pair? */
 17799                        ;		pb->buf[i++] = (BYTE)(hs >> 8);
 17800                        ;		pb->buf[i++] = (BYTE)hs;
 17801                        ;		nc++;
 17802                        ;	}
 17803                        ;	pb->buf[i++] = (BYTE)(wc >> 8);
 17804                        ;	pb->buf[i++] = (BYTE)wc;
 17805                        ;#elif FF_STRF_ENCODE == 3	/* Write a code 
                    point in UTF-8 */
 17806                        ;	if (hs != 0) {	/* 4-byte sequence? */
 17807                        ;		nc += 3;
 17808                        ;		hs = (hs & 0x3FF) + 0x40;
 17809                        ;		pb->buf[i++] = (BYTE)(0xF0 | hs >> 8);
 17810                        ;		pb->buf[i++] = (BYTE)(0x80 | (hs >> 2 & 
                    0x3F));
 17811                        ;		pb->buf[i++] = (BYTE)(0x80 | (hs & 3) <<
                     4 | (wc >> 6 & 0x0F));
 17812                        ;		pb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F)
                    );
 17813                        ;	} else {
 17814                        ;		if (wc < 0x80) {	/* Single byte? 
                    */
 17815                        ;			pb->buf[i++] = (BYTE)wc;
 17816                        ;		} else {
 17817                        ;			if (wc < 0x800) {	/* 2-byt
                    e sequence? */
 17818                        ;				nc += 1;
 17819                        ;				pb->buf[i++] = (BYTE)(0x
                    C0 | wc >> 6);
 17820                        ;			} else {			
                    /* 3-byte sequence */
 17821                        ;				nc += 2;
 17822                        ;				pb->buf[i++] = (BYTE)(0x
                    E0 | wc >> 12);
 17823                        ;				pb->buf[i++] = (BYTE)(0x
                    80 | (wc >> 6 & 0x3F));
 17824                        ;			}
 17825                        ;			pb->buf[i++] = (BYTE)(0x80 | (wc
                     & 0x3F));
 17826                        ;		}
  Thu May 20 2021 21:37                                                Page 365


 17827                        ;	}
 17828                        ;#else						
                    /* Write a code point in ANSI/OEM */
 17829                        ;	if (hs != 0) return;
 17830                        ;	wc = ff_uni2oem(wc, CODEPAGE);	/* UTF-16 ==> AN
                    SI/OEM */
 17831                        ;	if (wc == 0) return;
 17832                        ;	if (wc >= 0x100) {
 17833                        ;		pb->buf[i++] = (BYTE)(wc >> 8); nc++;
 17834                        ;	}
 17835                        ;	pb->buf[i++] = (BYTE)wc;
 17836                        ;#endif
 17837                        ;
 17838                        ;#else						
                    	/* ANSI/OEM input (without re-encoding) */
 17839                        ;	pb->buf[i++] = (BYTE)c;
 17840                        ;#endif
 17841                        ;
 17842                        ;	if (i >= (int)(sizeof pb->buf) - 4) {	/* Write
                     buffered characters to the file */
 17843                        ;		f_write(pb->fp, pb->buf, (UINT)i, &n);
 17844                        ;		i = (n == (UINT)i) ? 0 : -1;
 17845                        ;	}
 17846                        ;	pb->idx = i;
 17847                        ;	pb->nchr = nc + 1;
 17848                        ;}
 17849                        ;
 17850                        ;
 17851                        ;/* Flush remaining characters in the buffer */
 17852                        ;
 17853                        ;static int putc_flush (putbuff* pb)
 17854                        ;{
 17855                        ;	UINT nw;
 17856                        ;
 17857                        ;	if (   pb->idx >= 0	/* Flush buffered charac
                    ters to the file */
 17858                        ;		&& f_write(pb->fp, pb->buf, (UINT)pb->id
                    x, &nw) == FR_OK
 17859                        ;		&& (UINT)pb->idx == nw) return pb->nchr;
 17860                        ;	return -1;
 17861                        ;}
 17862                        ;
 17863                        ;
 17864                        ;/* Initialize write buffer */
 17865                        ;
 17866                        ;static void putc_init (putbuff* pb, FIL* fp)
 17867                        ;{
 17868                        ;	memset(pb, 0, sizeof (putbuff));
 17869                        ;	pb->fp = fp;
 17870                        ;}
 17871                        ;
 17872                        ;
 17873                        ;
 17874                        ;int f_putc (
 17875                        ;	TCHAR c,	/* A character to be output */
 17876                        ;	FIL* fp		/* Pointer to the file object */
 17877                        ;)
 17878                        ;{
  Thu May 20 2021 21:37                                                Page 366


 17879                        ;	putbuff pb;
 17880                        ;
 17881                        ;
 17882                        ;	putc_init(&pb, fp);
 17883                        ;	putc_bfd(&pb, c);	/* Put the character */
 17884                        ;	return putc_flush(&pb);
 17885                        ;}
 17886                        ;
 17887                        ;
 17888                        ;
 17889                        ;
 17890                        ;/*-----------------------------------------------
                    ------------------------*/
 17891                        ;/* Put a String to the File                      
                                            */
 17892                        ;/*-----------------------------------------------
                    ------------------------*/
 17893                        ;
 17894                        ;int f_puts (
 17895                        ;	const TCHAR* str,	/* Pointer to the string
                     to be output */
 17896                        ;	FIL* fp				/* Pointer to th
                    e file object */
 17897                        ;)
 17898                        ;{
 17899                        ;	putbuff pb;
 17900                        ;
 17901                        ;
 17902                        ;	putc_init(&pb, fp);
 17903                        ;	while (*str) putc_bfd(&pb, *str++);		
                    /* Put the string */
 17904                        ;	return putc_flush(&pb);
 17905                        ;}
 17906                        ;
 17907                        ;
 17908                        ;
 17909                        ;
 17910                        ;/*-----------------------------------------------
                    ------------------------*/
 17911                        ;/* Put a Formatted String to the File (with sub-f
                    unctions)               */
 17912                        ;/*-----------------------------------------------
                    ------------------------*/
 17913                        ;#if FF_PRINT_FLOAT && FF_INTDEF == 2
 17914                        ;#include <math.h>
 17915                        ;
 17916                        ;static int ilog10 (double n)	/* Calculate log
                    10(n) in integer output */
 17917                        ;{
 17918                        ;	int rv = 0;
 17919                        ;
 17920                        ;	while (n >= 10) {	/* Decimate digit in rig
                    ht shift */
 17921                        ;		if (n >= 100000) {
 17922                        ;			n /= 100000; rv += 5;
 17923                        ;		} else {
 17924                        ;			n /= 10; rv++;
 17925                        ;		}
  Thu May 20 2021 21:37                                                Page 367


 17926                        ;	}
 17927                        ;	while (n < 1) {		/* Decimate digit in lef
                    t shift */
 17928                        ;		if (n < 0.00001) {
 17929                        ;			n *= 100000; rv -= 5;
 17930                        ;		} else {
 17931                        ;			n *= 10; rv--;
 17932                        ;		}
 17933                        ;	}
 17934                        ;	return rv;
 17935                        ;}
 17936                        ;
 17937                        ;
 17938                        ;static double i10x (int n)	/* Calculate 10^
                    n in integer input */
 17939                        ;{
 17940                        ;	double rv = 1;
 17941                        ;
 17942                        ;	while (n > 0) {		/* Left shift */
 17943                        ;		if (n >= 5) {
 17944                        ;			rv *= 100000; n -= 5;
 17945                        ;		} else {
 17946                        ;			rv *= 10; n--;
 17947                        ;		}
 17948                        ;	}
 17949                        ;	while (n < 0) {		/* Right shift */
 17950                        ;		if (n <= -5) {
 17951                        ;			rv /= 100000; n += 5;
 17952                        ;		} else {
 17953                        ;			rv /= 10; n++;
 17954                        ;		}
 17955                        ;	}
 17956                        ;	return rv;
 17957                        ;}
 17958                        ;
 17959                        ;
 17960                        ;static void ftoa (
 17961                        ;	char* buf,	/* Buffer to output the floating
                     point string */
 17962                        ;	double val,	/* Value to output */
 17963                        ;	int prec,	/* Number of fractional digits *
                    /
 17964                        ;	TCHAR fmt	/* Notation */
 17965                        ;)
 17966                        ;{
 17967                        ;	int d;
 17968                        ;	int e = 0, m = 0;
 17969                        ;	char sign = 0;
 17970                        ;	double w;
 17971                        ;	const char *er = 0;
 17972                        ;	const char ds = FF_PRINT_FLOAT == 2 ? ',' : '.';
 17973                        ;
 17974                        ;
 17975                        ;	if (isnan(val)) {			/* Not a
                     number? */
 17976                        ;		er = "NaN";
 17977                        ;	} else {
 17978                        ;		if (prec < 0) prec = 6;	/* Default preci
  Thu May 20 2021 21:37                                                Page 368


                    sion? (6 fractional digits) */
 17979                        ;		if (val < 0) {			/* Nagat
                    ive? */
 17980                        ;			val = 0 - val; sign = '-';
 17981                        ;		} else {
 17982                        ;			sign = '+';
 17983                        ;		}
 17984                        ;		if (isinf(val)) {		/* Infin
                    ite? */
 17985                        ;			er = "INF";
 17986                        ;		} else {
 17987                        ;			if (fmt == 'f') {	/* Decim
                    al notation? */
 17988                        ;				val += i10x(0 - prec) / 
                    2;	/* Round (nearest) */
 17989                        ;				m = ilog10(val);
 17990                        ;				if (m < 0) m = 0;
 17991                        ;				if (m + prec + 3 >= SZ_N
                    UM_BUF) er = "OV";	/* Buffer overflow? */
 17992                        ;			} else {			
                    /* E notation */
 17993                        ;				if (val != 0) {		
                    /* Not a true zero? */
 17994                        ;					val += i10x(ilog
                    10(val) - prec) / 2;	/* Round (nearest) */
 17995                        ;					e = ilog10(val);
 17996                        ;					if (e > 99 || pr
                    ec + 7 >= SZ_NUM_BUF) {	/* Buffer overflow or E > +99? *
                    /
 17997                        ;						er = "OV
                    ";
 17998                        ;					} else {
 17999                        ;						if (e < 
                    -99) e = -99;
 18000                        ;						val /= i
                    10x(e);	/* Normalize */
 18001                        ;					}
 18002                        ;				}
 18003                        ;			}
 18004                        ;		}
 18005                        ;		if (!er) {	/* Not error condition *
                    /
 18006                        ;			if (sign == '-') *buf++ = sign;	
                    /* Add a - if negative value */
 18007                        ;			do {				
                    /* Put decimal number */
 18008                        ;				if (m == -1) *buf++ = ds
                    ;	/* Insert a decimal separator when get into fractional p
                    art */
 18009                        ;				w = i10x(m);		
                    		/* Snip the highest digit d */
 18010                        ;				d = (int)(val / w); val 
                    -= d * w;
 18011                        ;				*buf++ = (char)('0' + d)
                    ;	/* Put the digit */
 18012                        ;			} while (--m >= -prec);		
                    	/* Output all digits specified by prec */
 18013                        ;			if (fmt != 'f') {	/* Put e
  Thu May 20 2021 21:37                                                Page 369


                    xponent if needed */
 18014                        ;				*buf++ = (char)fmt;
 18015                        ;				if (e < 0) {
 18016                        ;					e = 0 - e; *buf+
                    + = '-';
 18017                        ;				} else {
 18018                        ;					*buf++ = '+';
 18019                        ;				}
 18020                        ;				*buf++ = (char)('0' + e 
                    / 10);
 18021                        ;				*buf++ = (char)('0' + e 
                    % 10);
 18022                        ;			}
 18023                        ;		}
 18024                        ;	}
 18025                        ;	if (er) {	/* Error condition */
 18026                        ;		if (sign) *buf++ = sign;		
                    /* Add sign if needed */
 18027                        ;		do *buf++ = *er++; while (*er);	/* Put e
                    rror symbol */
 18028                        ;	}
 18029                        ;	*buf = 0;	/* Term */
 18030                        ;}
 18031                        ;#endif	/* FF_PRINT_FLOAT && FF_INTDEF == 2 */
 18032                        ;
 18033                        ;
 18034                        ;
 18035                        ;int f_printf (
 18036                        ;	FIL* fp,			/* Pointer to th
                    e file object */
 18037                        ;	const TCHAR* fmt,	/* Pointer to the format
                     string */
 18038                        ;	...					/* Optio
                    nal arguments... */
 18039                        ;)
 18040                        ;{
 18041                        ;	va_list arp;
 18042                        ;	putbuff pb;
 18043                        ;	UINT i, j, w, f, r;
 18044                        ;	int prec;
 18045                        ;#if FF_PRINT_LLI && FF_INTDEF == 2
 18046                        ;	QWORD v;
 18047                        ;#else
 18048                        ;	DWORD v;
 18049                        ;#endif
 18050                        ;	TCHAR tc, pad, *tp;
 18051                        ;	TCHAR nul = 0;
 18052                        ;	char d, str[SZ_NUM_BUF];
 18053                        ;
 18054                        ;
 18055                        ;	putc_init(&pb, fp);
 18056                        ;
 18057                        ;	va_start(arp, fmt);
 18058                        ;
 18059                        ;	for (;;) {
 18060                        ;		tc = *fmt++;
 18061                        ;		if (tc == 0) break;			
                    /* End of format string */
  Thu May 20 2021 21:37                                                Page 370


 18062                        ;		if (tc != '%') {			
                    /* Not an escape character (pass-through) */
 18063                        ;			putc_bfd(&pb, tc);
 18064                        ;			continue;
 18065                        ;		}
 18066                        ;		f = w = 0; pad = ' '; prec = -1;	
                    /* Initialize parms */
 18067                        ;		tc = *fmt++;
 18068                        ;		if (tc == '0') {			
                    /* Flag: '0' padded */
 18069                        ;			pad = '0'; tc = *fmt++;
 18070                        ;		} else if (tc == '-') {		/* Flag:
                     Left aligned */
 18071                        ;			f = 2; tc = *fmt++;
 18072                        ;		}
 18073                        ;		if (tc == '*') {			
                    /* Minimum width from an argument */
 18074                        ;			w = va_arg(arp, int);
 18075                        ;			tc = *fmt++;
 18076                        ;		} else {
 18077                        ;			while (IsDigit(tc)) {	/* Minim
                    um width */
 18078                        ;				w = w * 10 + tc - '0';
 18079                        ;				tc = *fmt++;
 18080                        ;			}
 18081                        ;		}
 18082                        ;		if (tc == '.') {			
                    /* Precision */
 18083                        ;			tc = *fmt++;
 18084                        ;			if (tc == '*') {		
                    /* Precision from an argument */
 18085                        ;				prec = va_arg(arp, int);
 18086                        ;				tc = *fmt++;
 18087                        ;			} else {
 18088                        ;				prec = 0;
 18089                        ;				while (IsDigit(tc)) {	
                    /* Precision */
 18090                        ;					prec = prec * 10
                     + tc - '0';
 18091                        ;					tc = *fmt++;
 18092                        ;				}
 18093                        ;			}
 18094                        ;		}
 18095                        ;		if (tc == 'l') {			
                    /* Size: long int */
 18096                        ;			f |= 4; tc = *fmt++;
 18097                        ;#if FF_PRINT_LLI && FF_INTDEF == 2
 18098                        ;			if (tc == 'l') {		
                    /* Size: long long int */
 18099                        ;				f |= 8; tc = *fmt++;
 18100                        ;			}
 18101                        ;#endif
 18102                        ;		}
 18103                        ;		if (tc == 0) break;			
                    /* End of format string */
 18104                        ;		switch (tc) {				
                    /* Atgument type is... */
 18105                        ;		case 'b':				
  Thu May 20 2021 21:37                                                Page 371


                    	/* Unsigned binary */
 18106                        ;			r = 2; break;
 18107                        ;		case 'o':				
                    	/* Unsigned octal */
 18108                        ;			r = 8; break;
 18109                        ;		case 'd':				
                    	/* Signed decimal */
 18110                        ;		case 'u':				
                    	/* Unsigned decimal */
 18111                        ;			r = 10; break;
 18112                        ;		case 'x':				
                    	/* Unsigned hexdecimal (lower case) */
 18113                        ;		case 'X':				
                    	/* Unsigned hexdecimal (upper case) */
 18114                        ;			r = 16; break;
 18115                        ;		case 'c':				
                    	/* Character */
 18116                        ;			putc_bfd(&pb, (TCHAR)va_arg(arp,
                     int));
 18117                        ;			continue;
 18118                        ;		case 's':				
                    	/* String */
 18119                        ;			tp = va_arg(arp, TCHAR*);	
                    /* Get a pointer argument */
 18120                        ;			if (!tp) tp = &nul;		
                    /* Null ptr generates a null string */
 18121                        ;			for (j = 0; tp[j]; j++) ;	
                    /* j = tcslen(tp) */
 18122                        ;			if (prec >= 0 && j > (UINT)prec)
                     j = prec;	/* Limited length of string body */
 18123                        ;			for ( ; !(f & 2) && j < w; j++) 
                    putc_bfd(&pb, pad);	/* Left pads */
 18124                        ;			while (*tp && prec--) putc_bfd(&
                    pb, *tp++);	/* Body */
 18125                        ;			while (j++ < w) putc_bfd(&pb, ' 
                    ');			/* Right pads */
 18126                        ;			continue;
 18127                        ;#if FF_PRINT_FLOAT && FF_INTDEF == 2
 18128                        ;		case 'f':				
                    	/* Floating point (decimal) */
 18129                        ;		case 'e':				
                    	/* Floating point (e) */
 18130                        ;		case 'E':				
                    	/* Floating point (E) */
 18131                        ;			ftoa(str, va_arg(arp, double), p
                    rec, tc);	/* Make a flaoting point string */
 18132                        ;			for (j = strlen(str); !(f & 2) &
                    & j < w; j++) putc_bfd(&pb, pad);	/* Left pads */
 18133                        ;			for (i = 0; str[i]; putc_bfd(&pb
                    , str[i++])) ;	/* Body */
 18134                        ;			while (j++ < w) putc_bfd(&pb, ' 
                    ');	/* Right pads */
 18135                        ;			continue;
 18136                        ;#endif
 18137                        ;		default:				
                    	/* Unknown type (pass-through) */
 18138                        ;			putc_bfd(&pb, tc); continue;
 18139                        ;		}
  Thu May 20 2021 21:37                                                Page 372


 18140                        ;
 18141                        ;		/* Get an integer argument and put it in
                     numeral */
 18142                        ;#if FF_PRINT_LLI && FF_INTDEF == 2
 18143                        ;		if (f & 8) {	/* long long argument? *
                    /
 18144                        ;			v = (QWORD)va_arg(arp, LONGLONG)
                    ;
 18145                        ;		} else {
 18146                        ;			if (f & 4) {	/* long argument
                    ? */
 18147                        ;				v = (tc == 'd') ? (QWORD
                    )(LONGLONG)va_arg(arp, long) : (QWORD)va_arg(arp, unsigned l
                    ong);
 18148                        ;			} else {		/* int/s
                    hort/char argument */
 18149                        ;				v = (tc == 'd') ? (QWORD
                    )(LONGLONG)va_arg(arp, int) : (QWORD)va_arg(arp, unsigned in
                    t);
 18150                        ;			}
 18151                        ;		}
 18152                        ;		if (tc == 'd' && (v & 0x8000000000000000
                    )) {	/* Negative value? */
 18153                        ;			v = 0 - v; f |= 1;
 18154                        ;		}
 18155                        ;#else
 18156                        ;		if (f & 4) {	/* long argument? */
 18157                        ;			v = (DWORD)va_arg(arp, long);
 18158                        ;		} else {		/* int/short/cha
                    r argument */
 18159                        ;			v = (tc == 'd') ? (DWORD)(long)v
                    a_arg(arp, int) : (DWORD)va_arg(arp, unsigned int);
 18160                        ;		}
 18161                        ;		if (tc == 'd' && (v & 0x80000000)) {	
                    /* Negative value? */
 18162                        ;			v = 0 - v; f |= 1;
 18163                        ;		}
 18164                        ;#endif
 18165                        ;		i = 0;
 18166                        ;		do {	/* Make an integer number string
                     */
 18167                        ;			d = (char)(v % r); v /= r;
 18168                        ;			if (d > 9) d += (tc == 'x') ? 0x
                    27 : 0x07;
 18169                        ;			str[i++] = d + '0';
 18170                        ;		} while (v && i < SZ_NUM_BUF);
 18171                        ;		if (f & 1) str[i++] = '-';	/* Sign 
                    */
 18172                        ;		/* Write it */
 18173                        ;		for (j = i; !(f & 2) && j < w; j++) putc
                    _bfd(&pb, pad);	/* Left pads */
 18174                        ;		do putc_bfd(&pb, (TCHAR)str[--i]); while
                     (i);	/* Body */
 18175                        ;		while (j++ < w) putc_bfd(&pb, ' ');	
                    	/* Right pads */
 18176                        ;	}
 18177                        ;
 18178                        ;	va_end(arp);
  Thu May 20 2021 21:37                                                Page 373


 18179                        ;
 18180                        ;	return putc_flush(&pb);
 18181                        ;}
 18182                        ;
 18183                        ;#endif /* !FF_FS_READONLY */
 18184                        ;#endif /* FF_USE_STRFUNC */
 18185                        ;
 18186                        ;
 18187                        ;
 18188                        ;#if FF_CODE_PAGE == 0
 18189                        ;/*-----------------------------------------------
                    ------------------------*/
 18190                        ;/* Set Active Codepage for the Path Name         
                                            */
 18191                        ;/*-----------------------------------------------
                    ------------------------*/
 18192                        ;
 18193                        ;FRESULT f_setcp (
 18194                        ;	WORD cp		/* Value to be set as active cod
                    e page */
 18195                        ;)
 18196                        ;{
 18197                        ;	static const WORD       validcp[22] = {  437,   
                    720,   737,   771,   775,   850,   852,   855,   857,   860,
                       861,   862,   863,   864,   865,   866,   869,   932,   9
                    36,   949,   950, 0};
 18198                        ;	static const BYTE* const tables[22] = {Ct437, Ct
                    720, Ct737, Ct771, Ct775, Ct850, Ct852, Ct855, Ct857, Ct860,
                     Ct861, Ct862, Ct863, Ct864, Ct865, Ct866, Ct869, Dc932, Dc9
                    36, Dc949, Dc950, 0};
 18199                        ;	UINT i;
 18200                        ;
 18201                        ;
 18202                        ;	for (i = 0; validcp[i] != 0 && validcp[i] != cp;
                     i++) ;	/* Find the code page */
 18203                        ;	if (validcp[i] != cp) return FR_INVALID_PARAMETE
                    R;	/* Not found? */
 18204                        ;
 18205                        ;	CodePage = cp;
 18206                        ;	if (cp >= 900) {	/* DBCS */
 18207                        ;		ExCvt = 0;
 18208                        ;		DbcTbl = tables[i];
 18209                        ;	} else {			/* SBCS */
 18210                        ;		ExCvt = tables[i];
 18211                        ;		DbcTbl = 0;
 18212                        ;	}
 18213                        ;	return FR_OK;
 18214                        ;}
 18215                        ;#endif	/* FF_CODE_PAGE == 0 */
 18216                        ;
 18217                        ;
 18218                        	xref	~~disk_ioctl
 18219                        	xref	~~disk_write
 18220                        	xref	~~disk_read
 18221                        	xref	~~disk_status
 18222                        	xref	~~disk_initialize
 18223                        	xref	~~strchr
 18224                        	xref	~~memset
  Thu May 20 2021 21:37                                                Page 374


 18225                        	xref	~~memcpy
 18226                        	xref	~~memcmp
 18227                        	udata
 18228                        ~~Fsid
 18229 00:0000:              	ds	2
 18230 00:0002:              	ends
 18231                        	udata
 18232                        ~~FatFs
 18233 00:0002:              	ds	4
 18234 00:0006:              	ends
 18235                        	end


      Lines assembled: 18235
      Errors: 0
